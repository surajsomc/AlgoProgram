export function getRecursionData() {
  return {
    name: "Recursion & Divide and Conquer",
    slug: "recursion",
    description: "Break problems into smaller subproblems, solve each recursively, and combine results. Foundation of many algorithms.",
    icon: "\uD83D\uDD04", order: 20,
    concepts: { create: [
      { title: "Divide and Conquer", content: "Split the problem into subproblems, solve each recursively, combine results.\n\nExamples: merge sort (split, sort halves, merge), binary search (split, search one half), quick sort (partition, sort halves).\n\nKey: identify how to split and how to combine.\n\nTime complexity often follows the Master Theorem: T(n) = aT(n/b) + O(n^d).", timeComplexity: "O(n log n) typical", spaceComplexity: "O(log n) to O(n)", whenToUse: "When the problem can be split into independent subproblems of the same type. Merge sort, quick select, closest pair of points.", codeExample: "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)", flashcardFront: "What are the three steps of divide and conquer, and what does the Master Theorem tell us?", flashcardBack: "1) Divide: split into subproblems. 2) Conquer: solve subproblems recursively. 3) Combine: merge results. The Master Theorem gives the time complexity for recurrences T(n) = aT(n/b) + O(n^d): if d < log_b(a) then O(n^log_b(a)), if d = log_b(a) then O(n^d log n), if d > log_b(a) then O(n^d).", order: 1 },
      { title: "Recursion Fundamentals", content: "Every recursive solution needs:\n1. Base case: when to stop (prevents infinite recursion)\n2. Recursive case: break the problem into smaller instances\n3. Progress: each recursive call must move toward the base case\n\nCommon patterns:\n- Linear recursion: one recursive call (factorial, linked list traversal)\n- Binary recursion: two calls (tree traversal, merge sort)\n- Tail recursion: recursive call is the last operation (can be optimized to a loop)", timeComplexity: "Depends on branching and depth", spaceComplexity: "O(depth) for call stack", whenToUse: "Tree/graph traversal, problems with natural recursive structure, when the problem can be defined in terms of smaller versions of itself.", codeExample: "# Linear recursion\ndef factorial(n):\n    if n <= 1: return 1  # base case\n    return n * factorial(n - 1)  # recursive case\n\n# Binary recursion\ndef fib(n):\n    if n <= 1: return n\n    return fib(n-1) + fib(n-2)", flashcardFront: "What are the three essential components of a recursive solution?", flashcardBack: "1) Base case: the simplest instance that can be solved directly (stops recursion). 2) Recursive case: breaks the problem into smaller subproblems and makes recursive calls. 3) Progress guarantee: each recursive call must move closer to the base case to prevent infinite recursion.", order: 2 },
      { title: "Kadane's Algorithm and Subproblem Reduction", content: "Some problems that look like they need recursion can be solved with a simple scan by framing the decision at each element:\n\nKadane's Algorithm: at each element, decide whether to extend the previous subarray or start fresh.\ncurr_max = max(num, curr_max + num)\n\nThis is actually a form of dynamic programming / recursion where each subproblem depends on the previous one, collapsed into a single variable.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "Maximum subarray sum, when the recursive structure can be linearized into a single scan with O(1) state.", codeExample: "def max_subarray(nums):\n    curr = best = nums[0]\n    for num in nums[1:]:\n        curr = max(num, curr + num)\n        best = max(best, curr)\n    return best", flashcardFront: "How does Kadane's algorithm work and what problem does it solve?", flashcardBack: "Kadane's solves maximum subarray sum in O(n) time, O(1) space. At each element, decide: extend the current subarray (curr + num) or start a new one (num). curr_max = max(num, curr_max + num). Track the global maximum. It's a linearized form of the recurrence: maxEndingHere(i) = max(nums[i], maxEndingHere(i-1) + nums[i]).", order: 3 },
    ]},
    problems: { create: [
      { title: "Sort an Array (Merge Sort)", slug: "sort-array", difficulty: "Medium", description: "Given an array of integers nums, sort the array in ascending order and return it. You must solve it in O(n log n) time and with the smallest space complexity possible.", examples: JSON.stringify([{input:"nums = [5,2,3,1]",output:"[1,2,3,5]"},{input:"nums = [5,1,1,2,0,0]",output:"[0,0,1,1,2,5]"}]), hints: JSON.stringify(["Merge sort splits the array in half, sorts each, and merges.","Base case: array of size 0 or 1 is already sorted.","The merge step combines two sorted arrays into one."]), solution: "def sort_array(nums):\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = sort_array(nums[:mid])\n    right = sort_array(nums[mid:])\n    return merge(left, right)\n\ndef merge(l, r):\n    result = []\n    i = j = 0\n    while i < len(l) and j < len(r):\n        if l[i] <= r[j]:\n            result.append(l[i]); i += 1\n        else:\n            result.append(r[j]); j += 1\n    result.extend(l[i:])\n    result.extend(r[j:])\n    return result", explanation: "Divide and Conquer (Merge Sort): Split array in half, recursively sort each half, merge the sorted halves. O(n log n) time, O(n) space for merge step.", pattern: "Divide and Conquer", order: 1 },
      { title: "Maximum Subarray", slug: "maximum-subarray-kadane", difficulty: "Medium", description: "Given an integer array nums, find the subarray with the largest sum, and return its sum.", examples: JSON.stringify([{input:"nums = [-2,1,-3,4,-1,2,1,-5,4]",output:"6",explanation:"The subarray [4,-1,2,1] has the largest sum 6."},{input:"nums = [1]",output:"1"}]), hints: JSON.stringify(["At each position, decide: start a new subarray or extend the previous one?","If the previous subarray sum is negative, starting fresh is better.","Kadane's algorithm: curr_max = max(num, curr_max + num)."]), solution: "def max_subarray(nums):\n    curr_max = global_max = nums[0]\n    for num in nums[1:]:\n        curr_max = max(num, curr_max + num)\n        global_max = max(global_max, curr_max)\n    return global_max", explanation: "Kadane's Algorithm: At each element, either extend the current subarray or start a new one. Track the global maximum. O(n) time, O(1) space.", pattern: "Kadane's Algorithm", order: 2 },
      { title: "Reverse Linked List", slug: "reverse-linked-list-recursive", difficulty: "Easy", description: "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nSolve it both iteratively and recursively.", examples: JSON.stringify([{input:"head = [1,2,3,4,5]",output:"[5,4,3,2,1]"},{input:"head = [1,2]",output:"[2,1]"},{input:"head = []",output:"[]"}]), hints: JSON.stringify(["Recursive approach: reverse the rest of the list, then fix the pointers.","Base case: empty list or single node -- already reversed.","After reversing the rest, head.next.next = head and head.next = None."]), solution: "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef reverse_list(head):\n    # Recursive solution\n    if not head or not head.next:\n        return head\n    new_head = reverse_list(head.next)\n    head.next.next = head\n    head.next = None\n    return new_head\n\n# Iterative solution for reference\ndef reverse_list_iterative(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev", explanation: "Recursive reversal: Recursively reverse everything after head. Then head.next (which is now the tail of the reversed sublist) should point back to head. Set head.next = None. The recursion returns the new head (original tail). O(n) time, O(n) stack space.", pattern: "Recursion", order: 3 },
      { title: "Fibonacci Number", slug: "fibonacci-number", difficulty: "Easy", description: "The Fibonacci numbers form a sequence where each number is the sum of the two preceding ones: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) for n > 1.\n\nGiven n, calculate F(n).", examples: JSON.stringify([{input:"n = 2",output:"1",explanation:"F(2) = F(1) + F(0) = 1 + 0 = 1."},{input:"n = 3",output:"2"},{input:"n = 4",output:"3"}]), hints: JSON.stringify(["The naive recursive solution has exponential time complexity due to repeated subproblems.","Use memoization to cache results of subproblems.","Even better: use bottom-up iteration with just two variables."]), solution: "def fib(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\n# Recursive with memoization\ndef fib_memo(n, memo={}):\n    if n <= 1:\n        return n\n    if n not in memo:\n        memo[n] = fib_memo(n-1) + fib_memo(n-2)\n    return memo[n]", explanation: "Bottom-up iteration: Track the last two values and update. O(n) time, O(1) space. The recursive solution with memoization is O(n) time, O(n) space. Without memoization, naive recursion is O(2^n) -- a classic example of why memoization matters.", pattern: "Recursion / Dynamic Programming", order: 4 },
      { title: "Power of Two", slug: "power-of-two-recursive", difficulty: "Easy", description: "Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a power of two if there exists an integer x such that n == 2^x.", examples: JSON.stringify([{input:"n = 1",output:"true",explanation:"2^0 = 1."},{input:"n = 16",output:"true",explanation:"2^4 = 16."},{input:"n = 3",output:"false"}]), hints: JSON.stringify(["A power of two divided by 2 is still a power of two.","Base cases: n <= 0 is false, n == 1 is true.","Bit manipulation trick: n & (n-1) == 0 for powers of two (they have exactly one bit set)."]), solution: "def is_power_of_two(n):\n    # Bit manipulation - O(1)\n    return n > 0 and (n & (n - 1)) == 0\n\n# Recursive approach\ndef is_power_of_two_recursive(n):\n    if n <= 0:\n        return False\n    if n == 1:\n        return True\n    if n % 2 != 0:\n        return False\n    return is_power_of_two_recursive(n // 2)", explanation: "Bit manipulation: A power of 2 has exactly one bit set. n & (n-1) clears the lowest set bit. If the result is 0 and n > 0, it's a power of 2. O(1) time. Recursive approach divides by 2 until reaching 1 or an odd number. O(log n) time.", pattern: "Recursion / Bit Manipulation", order: 5 },
      { title: "Merge k Sorted Lists", slug: "merge-k-sorted-lists-recursive", difficulty: "Medium", description: "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.", examples: JSON.stringify([{input:"lists = [[1,4,5],[1,3,4],[2,6]]",output:"[1,1,2,3,4,4,5,6]"},{input:"lists = []",output:"[]"}]), hints: JSON.stringify(["You know how to merge 2 sorted lists. Can you extend that?","Divide and conquer: pair up the lists and merge each pair. Repeat until one list remains.","This is like merge sort but on lists instead of array halves."]), solution: "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef merge_k_lists(lists):\n    if not lists:\n        return None\n    if len(lists) == 1:\n        return lists[0]\n    mid = len(lists) // 2\n    left = merge_k_lists(lists[:mid])\n    right = merge_k_lists(lists[mid:])\n    return merge_two(left, right)\n\ndef merge_two(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    while l1 and l2:\n        if l1.val <= l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 or l2\n    return dummy.next", explanation: "Divide and conquer: Split the k lists into two halves, recursively merge each half, then merge the two results. This gives O(log k) levels of merging, each level processes all N nodes total. O(N log k) time, O(log k) stack space.", pattern: "Divide and Conquer", order: 6 },
      { title: "Count Good Numbers", slug: "count-good-numbers", difficulty: "Hard", description: "A digit string is good if the digits at even indices (0-indexed) are even (0, 2, 4, 6, 8) and the digits at odd indices are prime (2, 3, 5, 7).\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 10^9 + 7.", examples: JSON.stringify([{input:"n = 1",output:"5",explanation:"Good strings of length 1: '0', '2', '4', '6', '8'."},{input:"n = 4",output:"400",explanation:"Even positions have 5 choices, odd positions have 4 choices: 5 * 4 * 5 * 4 = 400."},{input:"n = 50",output:"564908303"}]), hints: JSON.stringify(["Even indices: 5 choices each. Odd indices: 4 choices each.","The answer is 5^(ceil(n/2)) * 4^(floor(n/2)) mod 10^9+7.","Use fast modular exponentiation (recursive or iterative) to compute large powers mod p."]), solution: "def count_good_numbers(n):\n    MOD = 10**9 + 7\n    \n    def mod_pow(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp % 2 == 1:\n                result = result * base % mod\n            exp //= 2\n            base = base * base % mod\n        return result\n    \n    even_positions = (n + 1) // 2  # ceil(n/2)\n    odd_positions = n // 2         # floor(n/2)\n    \n    return mod_pow(5, even_positions, MOD) * mod_pow(4, odd_positions, MOD) % MOD", explanation: "Combinatorics + fast exponentiation: Count choices per position -- 5 for even indices, 4 for odd. Total = 5^ceil(n/2) * 4^floor(n/2). Use binary exponentiation for O(log n) modular power computation.", pattern: "Recursion / Math", order: 7 },
      { title: "Different Ways to Add Parentheses", slug: "different-ways-add-parentheses", difficulty: "Hard", description: "Given a string expression of numbers and operators (+, -, *), return all possible results from computing all the different possible ways to group numbers and operators using parentheses.\n\nYou may return the answer in any order.", examples: JSON.stringify([{input:'expression = "2-1-1"',output:"[0, 2]",explanation:"((2-1)-1) = 0, (2-(1-1)) = 2"},{input:'expression = "2*3-4*5"',output:"[-34, -14, -10, -10, 10]"}]), hints: JSON.stringify(["For each operator, split the expression into left and right parts.","Recursively compute all possible results for the left and right parts.","Combine every left result with every right result using the operator."]), solution: "def diff_ways_to_compute(expression):\n    if expression.isdigit():\n        return [int(expression)]\n    \n    results = []\n    for i, char in enumerate(expression):\n        if char in '+-*':\n            left = diff_ways_to_compute(expression[:i])\n            right = diff_ways_to_compute(expression[i+1:])\n            for l in left:\n                for r in right:\n                    if char == '+': results.append(l + r)\n                    elif char == '-': results.append(l - r)\n                    else: results.append(l * r)\n    \n    return results", explanation: "Divide and conquer on operators: For each operator position, split into left and right subexpressions. Recursively compute all results for each side. Combine every pair of left/right results. Base case: a pure number returns itself. This explores all possible parenthesizations.", pattern: "Divide and Conquer", order: 8 },
    ]},
  };
}
