export function getPrefixSumData() {
  return {
    name: "Prefix Sum",
    slug: "prefix-sum",
    description: "Precompute cumulative sums for O(1) range sum queries. Combines with hash maps for subarray sum problems.",
    icon: "\u2795", order: 19,
    concepts: { create: [
      { title: "Prefix Sum Array", content: "Build an array where prefix[i] = sum of elements from index 0 to i.\n\nRange sum from i to j = prefix[j] - prefix[i-1].\n\nThis converts O(n) range queries into O(1) after O(n) preprocessing.\n\nCommon pattern: build prefix sum, then answer multiple range queries efficiently.", timeComplexity: "O(n) build, O(1) query", spaceComplexity: "O(n)", whenToUse: "Multiple range sum queries, finding subarrays with specific sums, running totals.", codeExample: "def build_prefix(nums):\n    prefix = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix[i+1] = prefix[i] + nums[i]\n    return prefix\n\ndef range_sum(prefix, i, j):\n    return prefix[j+1] - prefix[i]", flashcardFront: "How do you compute the sum of elements from index i to j in O(1) time?", flashcardBack: "Build a prefix sum array where prefix[k] = sum of nums[0..k-1]. Then range_sum(i, j) = prefix[j+1] - prefix[i]. Building takes O(n), each query is O(1). Use 1-indexed prefix array with prefix[0] = 0 to avoid edge cases.", order: 1 },
      { title: "Prefix Sum + Hash Map", content: "Combine prefix sums with a hash map to find subarrays with a target sum.\n\nKey insight: if prefix[j] - prefix[i] = k, then the subarray from i+1 to j sums to k.\n\nSo for each prefix sum, check if (current_prefix - k) exists in the hash map of previously seen prefix sums.\n\nThis pattern solves 'count/find subarrays with sum = k' in O(n).", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "Count subarrays with given sum, find subarray summing to target, longest subarray with sum k.", codeExample: "def subarray_sum(nums, k):\n    count = 0\n    prefix = 0\n    seen = {0: 1}\n    for num in nums:\n        prefix += num\n        if prefix - k in seen:\n            count += seen[prefix - k]\n        seen[prefix] = seen.get(prefix, 0) + 1\n    return count", flashcardFront: "How do you count the number of subarrays with sum equal to k in O(n) time?", flashcardBack: "Use prefix sum + hash map. Maintain a running prefix sum and a map of {prefix_sum: count}. For each position, if (prefix - k) exists in the map, those many subarrays ending here sum to k. Initialize map with {0: 1} to handle subarrays starting from index 0.", order: 2 },
      { title: "Prefix Product and Difference Arrays", content: "Prefix products: similar to prefix sums but with multiplication. product_except_self uses left and right prefix products.\n\nDifference arrays: the inverse of prefix sums. Used for range update operations.\n- To add val to range [l, r]: diff[l] += val, diff[r+1] -= val\n- Reconstruct with prefix sum of diff array\n\nThis converts O(n) range updates into O(1) each.", timeComplexity: "O(1) per update, O(n) to reconstruct", spaceComplexity: "O(n)", whenToUse: "Multiple range increment operations (e.g., booking systems, range adds). Prefix products for product-related queries.", codeExample: "def range_add(diff, l, r, val):\n    diff[l] += val\n    if r + 1 < len(diff):\n        diff[r + 1] -= val\n\ndef reconstruct(diff):\n    result = [0] * len(diff)\n    result[0] = diff[0]\n    for i in range(1, len(diff)):\n        result[i] = result[i-1] + diff[i]\n    return result", flashcardFront: "What is a difference array and when do you use it?", flashcardBack: "A difference array is the inverse of prefix sum. To add val to range [l, r], set diff[l] += val and diff[r+1] -= val. Reconstruct the final array by taking the prefix sum of the diff array. This makes each range update O(1) instead of O(n). Use it for batch range increment operations.", order: 3 },
    ]},
    problems: { create: [
      { title: "Subarray Sum Equals K", slug: "subarray-sum-equals-k", difficulty: "Medium", description: "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.", examples: JSON.stringify([{input:"nums = [1,1,1], k = 2",output:"2"},{input:"nums = [1,2,3], k = 3",output:"2"}]), hints: JSON.stringify(["Prefix sum at index i = sum of nums[0..i].","Subarray sum from i to j = prefix[j] - prefix[i-1].","If prefix[j] - k = prefix[i], there's a subarray summing to k. Use a hash map to count prefix sums."]), solution: "def subarray_sum(nums, k):\n    count = 0\n    prefix = 0\n    seen = {0: 1}\n    for num in nums:\n        prefix += num\n        if prefix - k in seen:\n            count += seen[prefix - k]\n        seen[prefix] = seen.get(prefix, 0) + 1\n    return count", explanation: "Prefix Sum + Hash Map: Track prefix sums in a map. For each position, check if (prefix - k) exists in the map -- that means there's a subarray ending here with sum k. O(n) time, O(n) space.", pattern: "Prefix Sum + Hash Map", order: 1 },
      { title: "Product of Array Except Self", slug: "product-except-self", difficulty: "Medium", description: "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all elements of nums except nums[i].\n\nYou must solve it without division and in O(n) time.", examples: JSON.stringify([{input:"nums = [1,2,3,4]",output:"[24,12,8,6]"},{input:"nums = [-1,1,0,-3,3]",output:"[0,0,9,0,0]"}]), hints: JSON.stringify(["For each position, you need the product of everything to its left AND everything to its right.","Build a prefix product (left to right) and a suffix product (right to left).","answer[i] = left_product[i] * right_product[i]."]), solution: "def product_except_self(nums):\n    n = len(nums)\n    answer = [1] * n\n    # Left products\n    left = 1\n    for i in range(n):\n        answer[i] = left\n        left *= nums[i]\n    # Right products\n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    return answer", explanation: "Prefix/Suffix products: First pass builds left products, second pass multiplies by right products. Each position gets the product of all elements except itself. O(n) time, O(1) extra space.", pattern: "Prefix Product", order: 2 },
      { title: "Running Sum of 1d Array", slug: "running-sum-1d-array", difficulty: "Easy", description: "Given an array nums, return the running sum of nums. The running sum is defined as runningSum[i] = sum(nums[0]...nums[i]).", examples: JSON.stringify([{input:"nums = [1,2,3,4]",output:"[1,3,6,10]",explanation:"Running sum: [1, 1+2, 1+2+3, 1+2+3+4]."},{input:"nums = [3,1,2,10,1]",output:"[3,4,6,16,17]"}]), hints: JSON.stringify(["This is literally the definition of prefix sum.","Each element becomes the sum of itself and all previous elements.","You can do this in-place: nums[i] += nums[i-1]."]), solution: "def running_sum(nums):\n    for i in range(1, len(nums)):\n        nums[i] += nums[i - 1]\n    return nums", explanation: "Prefix sum in-place: Starting from index 1, add the previous element to the current. Each element becomes the cumulative sum up to that point. O(n) time, O(1) space.", pattern: "Prefix Sum", order: 3 },
      { title: "Find Pivot Index", slug: "find-pivot-index", difficulty: "Easy", description: "Given an array of integers nums, calculate the pivot index of this array.\n\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the right of the index.\n\nReturn the leftmost pivot index. If no such index exists, return -1.", examples: JSON.stringify([{input:"nums = [1,7,3,6,5,6]",output:"3",explanation:"Left sum = 1+7+3 = 11, right sum = 5+6 = 11."},{input:"nums = [1,2,3]",output:"-1"},{input:"nums = [2,1,-1]",output:"0"}]), hints: JSON.stringify(["Total sum minus left sum minus current element = right sum.","If left_sum == right_sum, the current index is the pivot.","Iterate left to right, maintaining a running left sum."]), solution: "def pivot_index(nums):\n    total = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total - left_sum - num:\n            return i\n        left_sum += num\n    return -1", explanation: "Prefix sum with total: Compute total sum first. Iterate through the array maintaining left_sum. At each index, right_sum = total - left_sum - nums[i]. If left_sum == right_sum, return index. O(n) time, O(1) space.", pattern: "Prefix Sum", order: 4 },
      { title: "Range Sum Query - Immutable", slug: "range-sum-query-immutable", difficulty: "Easy", description: "Given an integer array nums, handle multiple queries of the following type: calculate the sum of the elements of nums between indices left and right inclusive.\n\nImplement the NumArray class with a constructor that takes nums and a sumRange(left, right) method.", examples: JSON.stringify([{input:'NumArray([−2, 0, 3, −5, 2, −1]); sumRange(0,2); sumRange(2,5); sumRange(0,5)',output:"1, -1, -3",explanation:"sumRange(0,2) = -2+0+3 = 1"},{input:'NumArray([1, 2, 3]); sumRange(0,0); sumRange(1,2)',output:"1, 5"}]), hints: JSON.stringify(["Precompute prefix sums in the constructor.","sumRange(left, right) = prefix[right+1] - prefix[left].","This makes each query O(1) after O(n) preprocessing."]), solution: "class NumArray:\n    def __init__(self, nums):\n        self.prefix = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix[i + 1] = self.prefix[i] + nums[i]\n    \n    def sum_range(self, left, right):\n        return self.prefix[right + 1] - self.prefix[left]", explanation: "Classic prefix sum: Build prefix array in constructor where prefix[i] = sum of nums[0..i-1]. Range sum query is simply prefix[right+1] - prefix[left]. O(n) build, O(1) per query, O(n) space.", pattern: "Prefix Sum", order: 5 },
      { title: "Contiguous Array", slug: "contiguous-array", difficulty: "Medium", description: "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.", examples: JSON.stringify([{input:"nums = [0,1]",output:"2",explanation:"[0, 1] has equal 0s and 1s."},{input:"nums = [0,1,0]",output:"2"}]), hints: JSON.stringify(["Replace 0s with -1s. Now you need the longest subarray with sum 0.","Use prefix sums: when the same prefix sum appears at two indices, the subarray between them sums to 0.","Store the first occurrence of each prefix sum in a hash map."]), solution: "def find_max_length(nums):\n    count = 0\n    max_len = 0\n    first_seen = {0: -1}\n    \n    for i, num in enumerate(nums):\n        count += 1 if num == 1 else -1\n        if count in first_seen:\n            max_len = max(max_len, i - first_seen[count])\n        else:\n            first_seen[count] = i\n    \n    return max_len", explanation: "Prefix sum + hash map: Treat 0 as -1. A subarray with equal 0s and 1s has sum 0, meaning the prefix sum at the start equals the prefix sum at the end. Store first occurrence of each prefix sum. Max length = current index - first occurrence. O(n) time, O(n) space.", pattern: "Prefix Sum + Hash Map", order: 6 },
      { title: "Range Sum Query 2D - Immutable", slug: "range-sum-query-2d", difficulty: "Hard", description: "Given a 2D matrix matrix, handle multiple queries of the following type: calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\n\nImplement the NumMatrix class with efficient sumRegion queries.", examples: JSON.stringify([{input:"matrix = [[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]], sumRegion(2,1,4,3)",output:"8",explanation:"Sum of the rectangle from (2,1) to (4,3) = 2+0+1+1+0+1+0+3+0 = 8."},{input:"sumRegion(1,1,2,2)",output:"11"}]), hints: JSON.stringify(["Extend 1D prefix sum to 2D: prefix[i][j] = sum of all elements in the rectangle from (0,0) to (i-1,j-1).","Use inclusion-exclusion to compute prefix[i][j] from smaller prefixes.","Region sum uses inclusion-exclusion: add big rectangle, subtract two overlapping strips, add back the double-subtracted corner."]), solution: "class NumMatrix:\n    def __init__(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        self.prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m):\n            for j in range(n):\n                self.prefix[i+1][j+1] = (\n                    matrix[i][j]\n                    + self.prefix[i][j+1]\n                    + self.prefix[i+1][j]\n                    - self.prefix[i][j]\n                )\n    \n    def sum_region(self, r1, c1, r2, c2):\n        return (\n            self.prefix[r2+1][c2+1]\n            - self.prefix[r1][c2+1]\n            - self.prefix[r2+1][c1]\n            + self.prefix[r1][c1]\n        )", explanation: "2D prefix sum with inclusion-exclusion: Build a 2D prefix array where prefix[i][j] = sum of rectangle from (0,0) to (i-1,j-1). Query uses inclusion-exclusion: total - top strip - left strip + corner. O(m*n) build, O(1) per query.", pattern: "2D Prefix Sum", order: 7 },
      { title: "Minimum Size Subarray Sum", slug: "min-size-subarray-sum-prefix", difficulty: "Hard", description: "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0.\n\nCan you solve it in O(n) time?", examples: JSON.stringify([{input:"target = 7, nums = [2,3,1,2,4,3]",output:"2",explanation:"The subarray [4,3] has sum 7 and minimal length 2."},{input:"target = 4, nums = [1,4,4]",output:"1"},{input:"target = 11, nums = [1,1,1,1,1,1,1,1]",output:"0"}]), hints: JSON.stringify(["Use a sliding window / two pointers approach since all values are positive.","Expand the window by moving right pointer until sum >= target.","Then shrink from left to find the minimum valid window."]), solution: "def min_subarray_len(target, nums):\n    left = 0\n    curr_sum = 0\n    min_len = float('inf')\n    \n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        while curr_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n    \n    return min_len if min_len != float('inf') else 0", explanation: "Sliding window with prefix sum logic: Since all values are positive, use two pointers. Expand right to increase sum, shrink left when sum >= target. The running sum acts as an implicit prefix sum difference. O(n) time, O(1) space.", pattern: "Sliding Window / Prefix Sum", order: 8 },
    ]},
  };
}
