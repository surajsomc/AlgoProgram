export function getGreedyData() {
  return {
    name: "Greedy Algorithms",
    slug: "greedy",
    description: "Make the locally optimal choice at each step. Works when local optimality leads to global optimality. Simpler than DP when applicable.",
    icon: "ðŸƒ", order: 13,
    concepts: { create: [
      { title: "Greedy Strategy", content: "At each step, make the choice that looks best right now without considering future consequences.\n\nGreedy works when: the problem has 'greedy choice property' (local optimal leads to global optimal) and 'optimal substructure'.\n\nHow to verify: can you prove that a greedy choice is always part of an optimal solution? Or does a counterexample exist?", timeComplexity: "Usually O(n) or O(n log n)", spaceComplexity: "Usually O(1)", whenToUse: "Activity selection, jump game, gas station, task scheduling, when sorting + greedy choice gives optimal result.", codeExample: "def can_jump(nums):\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return True", flashcardFront: "What is the greedy choice property and how do you know a problem can be solved greedily?", flashcardBack: "The greedy choice property means making the locally optimal choice at each step leads to a globally optimal solution. Verify by proving a greedy choice is always part of some optimal solution, or look for counterexamples. Greedy problems also need optimal substructure. Common patterns: sorting + greedy selection, tracking running max/min.", order: 1 },
      { title: "Sorting-Based Greedy", content: "Many greedy problems require sorting the input first by some criterion, then making greedy choices in sorted order.\n\nExamples:\n- Activity selection: sort by end time, greedily pick non-overlapping activities.\n- Assign cookies: sort both children greed and cookie sizes, match smallest sufficient cookie.\n- Task scheduling with deadlines: sort by deadline or profit.\n\nThe key insight is choosing the right sorting criterion.", timeComplexity: "O(n log n) for sorting", spaceComplexity: "O(1) to O(n)", whenToUse: "When you need to process items in a specific order to make optimal local decisions. Usually involves scheduling, assignment, or selection problems.", codeExample: "def assign_cookies(greed, cookies):\n    greed.sort()\n    cookies.sort()\n    child = cookie = 0\n    while child < len(greed) and cookie < len(cookies):\n        if cookies[cookie] >= greed[child]:\n            child += 1\n        cookie += 1\n    return child", flashcardFront: "When should you use a sorting-based greedy approach and what is the key decision?", flashcardBack: "Use sorting-based greedy for scheduling, assignment, and selection problems. The key decision is choosing the right sorting criterion: sort by end time for activity selection, by deadline for scheduling, by ratio for knapsack. After sorting, greedily pick the best available option at each step. Time is O(n log n) dominated by sorting.", order: 2 },
    ]},
    problems: { create: [
      { title: "Jump Game", slug: "jump-game", difficulty: "Medium", description: "You are given an integer array nums. You are initially positioned at the first index. Each element represents your maximum jump length from that position.\n\nReturn true if you can reach the last index.", examples: JSON.stringify([{input:"nums = [2,3,1,1,4]",output:"true",explanation:"Jump 1 to index 1, then 3 to last index."},{input:"nums = [3,2,1,0,4]",output:"false"}]), hints: JSON.stringify(["Track the farthest index you can reach.","At each position, update the max reach.","If your current index exceeds max reach, you're stuck."]), solution: "def can_jump(nums):\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return True", explanation: "Greedy: Track the maximum reachable index. At each step, if current index is beyond max reach, return false. Otherwise, update max reach. O(n) time, O(1) space.", pattern: "Greedy", order: 1 },
      { title: "Jump Game II", slug: "jump-game-ii", difficulty: "Medium", description: "Given an array of non-negative integers nums, you are initially at the first index. Each element represents your maximum jump length.\n\nYour goal is to reach the last index in the minimum number of jumps. You can always reach the last index.", examples: JSON.stringify([{input:"nums = [2,3,1,1,4]",output:"2",explanation:"Jump 1 step to index 1, then 3 steps to the last index."},{input:"nums = [2,3,0,1,4]",output:"2"}]), hints: JSON.stringify(["Think of it as BFS: each jump is a 'level'.","Track the farthest you can reach in the current jump.","When you reach the end of the current jump's range, increment jumps."]), solution: "def jump(nums):\n    jumps = 0\n    curr_end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == curr_end:\n            jumps += 1\n            curr_end = farthest\n    return jumps", explanation: "Greedy / BFS-style: Track the farthest reachable index within the current jump. When you reach the boundary of the current jump, take the next jump to the farthest point. O(n) time.", pattern: "Greedy", order: 2 },
      { title: "Gas Station", slug: "gas-station", difficulty: "Medium", description: "There are n gas stations along a circular route. You have gas[i] fuel at station i and it costs cost[i] to travel to the next station.\n\nReturn the starting gas station's index if you can travel around the circuit once clockwise, otherwise return -1. If a solution exists, it is unique.", examples: JSON.stringify([{input:"gas = [1,2,3,4,5], cost = [3,4,5,1,2]",output:"3",explanation:"Start at station 3 (index 3), travel the full circuit."},{input:"gas = [2,3,4], cost = [3,4,3]",output:"-1"}]), hints: JSON.stringify(["If total gas >= total cost, a solution must exist.","If you run out of gas at station i, starting from any station between start and i won't work.","Reset the start to i+1 whenever tank goes negative."]), solution: "def can_complete_circuit(gas, cost):\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1", explanation: "Greedy: If total gas >= total cost, a solution exists. Track running tank; whenever it goes negative, the start must be after this point. Reset start and tank. O(n) time, O(1) space.", pattern: "Greedy", order: 3 },
      { title: "Assign Cookies", slug: "assign-cookies", difficulty: "Easy", description: "You are an awesome parent and want to give your children some cookies. Each child i has a greed factor g[i], which is the minimum size of a cookie the child will be content with. Each cookie j has a size s[j].\n\nYou can only give each child at most one cookie. Maximize the number of content children.", examples: JSON.stringify([{input:"g = [1,2,3], s = [1,1]",output:"1",explanation:"Only one child can be content (the one with greed 1)."},{input:"g = [1,2], s = [1,2,3]",output:"2"}]), hints: JSON.stringify(["Sort both arrays.","Try to satisfy the least greedy child with the smallest sufficient cookie.","Use two pointers, one for children and one for cookies."]), solution: "def find_content_children(g, s):\n    g.sort()\n    s.sort()\n    child = cookie = 0\n    while child < len(g) and cookie < len(s):\n        if s[cookie] >= g[child]:\n            child += 1\n        cookie += 1\n    return child", explanation: "Sorting + Greedy: Sort children by greed and cookies by size. Match the smallest sufficient cookie to the least greedy unsatisfied child. If a cookie is too small, skip it. O(n log n) time.", pattern: "Greedy", order: 4 },
      { title: "Maximum Units on a Truck", slug: "maximum-units-truck", difficulty: "Easy", description: "You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes where boxTypes[i] = [numberOfBoxes_i, numberOfUnitsPerBox_i].\n\nYou are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck. Return the maximum total number of units that can be put on the truck.", examples: JSON.stringify([{input:"boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4",output:"8",explanation:"Take 1 box of 3 units, 2 boxes of 2 units, 1 box of 1 unit = 3+4+1=8"},{input:"boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10",output:"91"}]), hints: JSON.stringify(["Prioritize boxes with the most units per box.","Sort by units per box in descending order.","Greedily take as many of the highest-unit boxes as possible."]), solution: "def maximum_units(box_types, truck_size):\n    box_types.sort(key=lambda x: -x[1])\n    units = 0\n    for count, unit in box_types:\n        take = min(count, truck_size)\n        units += take * unit\n        truck_size -= take\n        if truck_size == 0:\n            break\n    return units", explanation: "Sorting + Greedy: Sort by units per box descending. Greedily take as many boxes as possible from the highest-value type first. This is the fractional knapsack approach. O(n log n) time.", pattern: "Greedy", order: 5 },
      { title: "Lemonade Change", slug: "lemonade-change", difficulty: "Easy", description: "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you, and order one at a time. Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill.\n\nYou must provide the correct change to each customer. You do not have any change to start with.\n\nReturn true if you can provide every customer with the correct change, or false otherwise.", examples: JSON.stringify([{input:"bills = [5,5,5,10,20]",output:"true",explanation:"Collect three $5. Give one $5 change for $10. Give one $10 + one $5 for $20."},{input:"bills = [5,5,10,10,20]",output:"false",explanation:"After the two $10 bills, we only have two $10 and no $5 for the $20 bill."}]), hints: JSON.stringify(["Track the count of $5 and $10 bills you have.","For $10: give back one $5. For $20: prefer giving one $10 + one $5, else three $5.","Greedily use larger bills first when making change for $20."]), solution: "def lemonade_change(bills):\n    five = ten = 0\n    for bill in bills:\n        if bill == 5:\n            five += 1\n        elif bill == 10:\n            if five == 0:\n                return False\n            five -= 1\n            ten += 1\n        else:  # bill == 20\n            if ten > 0 and five > 0:\n                ten -= 1\n                five -= 1\n            elif five >= 3:\n                five -= 3\n            else:\n                return False\n    return True", explanation: "Greedy: Track $5 and $10 bills. For $20 change, prefer using $10+$5 over $5+$5+$5 since $5 bills are more versatile. This greedy choice preserves the most useful bills. O(n) time, O(1) space.", pattern: "Greedy", order: 6 },
      { title: "Hand of Straights", slug: "hand-of-straights", difficulty: "Medium", description: "Alice has some number of cards and she wants to rearrange them into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.\n\nGiven an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.", examples: JSON.stringify([{input:"hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",output:"true",explanation:"Rearranged into [1,2,3], [2,3,4], [6,7,8]."},{input:"hand = [1,2,3,4,5], groupSize = 4",output:"false"}]), hints: JSON.stringify(["If the total number of cards isn't divisible by groupSize, return false immediately.","Sort the hand and use a frequency counter.","Greedily form groups starting from the smallest available card."]), solution: "from collections import Counter\ndef is_n_straight_hand(hand, group_size):\n    if len(hand) % group_size != 0:\n        return False\n    count = Counter(hand)\n    for card in sorted(count):\n        if count[card] > 0:\n            freq = count[card]\n            for i in range(card, card + group_size):\n                if count[i] < freq:\n                    return False\n                count[i] -= freq\n    return True", explanation: "Sorting + Greedy: Sort cards, count frequencies. For each smallest available card, form groups of consecutive cards starting from it. If any card in the sequence has insufficient count, return false. O(n log n) time.", pattern: "Greedy", order: 7 },
      { title: "Maximum Subarray", slug: "max-subarray-greedy", difficulty: "Medium", description: "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.", examples: JSON.stringify([{input:"nums = [-2,1,-3,4,-1,2,1,-5,4]",output:"6",explanation:"The subarray [4,-1,2,1] has the largest sum 6."},{input:"nums = [1]",output:"1"},{input:"nums = [5,4,-1,7,8]",output:"23"}]), hints: JSON.stringify(["At each element, decide: extend the current subarray or start fresh.","If the running sum becomes negative, reset it -- a negative prefix never helps.","This greedy approach is also known as Kadane's algorithm."]), solution: "def max_sub_array(nums):\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", explanation: "Greedy (Kadane's): At each element, greedily decide to extend or restart the subarray. If curr_sum + num < num, discard the prefix and start anew. Track the global maximum. O(n) time, O(1) space.", pattern: "Greedy", order: 8 },
      { title: "Minimum Number of Arrows to Burst Balloons", slug: "min-arrows-burst-balloons", difficulty: "Hard", description: "There are some spherical balloons taped on a flat wall. Each balloon is represented as an interval [xstart, xend] on the x-axis.\n\nAn arrow shot vertically at position x bursts all balloons where xstart <= x <= xend. Find the minimum number of arrows to burst all balloons.", examples: JSON.stringify([{input:"points = [[10,16],[2,8],[1,6],[7,12]]",output:"2",explanation:"Shoot at x=6 (burst [2,8] and [1,6]) and x=11 (burst [10,16] and [7,12])."},{input:"points = [[1,2],[3,4],[5,6],[7,8]]",output:"4"}]), hints: JSON.stringify(["Sort balloons by their end point.","Greedily shoot an arrow at the end of the first balloon that hasn't been burst.","Skip all subsequent balloons whose start is before or at the arrow position."]), solution: "def find_min_arrow_shots(points):\n    points.sort(key=lambda x: x[1])\n    arrows = 1\n    arrow_pos = points[0][1]\n    for start, end in points[1:]:\n        if start > arrow_pos:\n            arrows += 1\n            arrow_pos = end\n    return arrows", explanation: "Sort by end + Greedy: Sort by end position. Shoot at the end of the first unbursted balloon. All overlapping balloons are burst. Move to the next unbursted balloon. This is equivalent to the interval scheduling/activity selection problem. O(n log n) time.", pattern: "Greedy", order: 9 },
      { title: "Task Scheduler", slug: "task-scheduler-greedy", difficulty: "Hard", description: "Given a characters array tasks representing the tasks a CPU needs to do, where each letter represents a different type of task, and a non-negative integer n that represents the cooldown interval between two same tasks.\n\nReturn the least number of intervals the CPU will take to finish all the given tasks.", examples: JSON.stringify([{input:'tasks = ["A","A","A","B","B","B"], n = 2',output:"8",explanation:"A -> B -> idle -> A -> B -> idle -> A -> B"},{input:'tasks = ["A","A","A","B","B","B"], n = 0',output:"6"}]), hints: JSON.stringify(["The most frequent task determines the minimum time.","Count the frequency of each task. The most frequent one creates the 'frame'.","Total time = (max_freq - 1) * (n + 1) + count_of_tasks_with_max_freq, or len(tasks) if larger."]), solution: "from collections import Counter\ndef least_interval(tasks, n):\n    freq = Counter(tasks)\n    max_freq = max(freq.values())\n    max_count = sum(1 for v in freq.values() if v == max_freq)\n    return max(len(tasks), (max_freq - 1) * (n + 1) + max_count)", explanation: "Greedy / Math: The most frequent task determines the frame. There are (max_freq - 1) gaps of size (n + 1), plus the tasks with max frequency at the end. If total tasks exceed this, no idle time is needed. O(n) time.", pattern: "Greedy", order: 10 },
    ]},
  };
}
