export function getTreesData() {
  return {
    name: "Trees",
    slug: "trees",
    description: "Binary trees, BSTs, and tree traversals. Master DFS (preorder, inorder, postorder) and BFS (level order).",
    icon: "ðŸŒ³", order: 7,
    concepts: { create: [
      { title: "Tree DFS (Recursive)", content: "Depth-first traversal visits nodes by going as deep as possible before backtracking.\n\nThree orders:\n- Preorder: process node, then left, then right\n- Inorder: left, process node, right (gives sorted order for BSTs)\n- Postorder: left, right, process node (useful for computing heights)\n\nMost tree problems use recursive DFS.", timeComplexity: "O(n)", spaceComplexity: "O(h) where h = height", whenToUse: "Most tree problems: depth, height, path sum, validate BST, subtree problems.", codeExample: "def max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(\n        max_depth(root.left),\n        max_depth(root.right)\n    )", flashcardFront: "What are the three DFS traversal orders for a binary tree, and when is each useful?", flashcardBack: "Preorder (node, left, right): Used for serialization, copying trees, and prefix expressions. Inorder (left, node, right): Gives sorted order for BSTs; used for BST validation and finding kth smallest. Postorder (left, right, node): Used for computing heights, deleting trees, and evaluating expression trees. All are O(n) time, O(h) space where h is the tree height.", order: 1 },
      { title: "Tree BFS (Level Order)", content: "Breadth-first traversal processes nodes level by level using a queue.\n\nPattern: add root to queue. While queue is not empty, process all nodes at current level, add their children for the next level.", timeComplexity: "O(n)", spaceComplexity: "O(w) where w = max width", whenToUse: "Level order traversal, right side view, zigzag order, minimum depth, connecting nodes at the same level.", codeExample: "from collections import deque\ndef level_order(root):\n    if not root: return []\n    result, queue = [], deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        result.append(level)\n    return result", flashcardFront: "How does BFS (level order) traversal work on a binary tree?", flashcardBack: "Use a queue initialized with the root. While the queue is not empty, record its current size (number of nodes at this level), then dequeue that many nodes, processing each and enqueuing their children. This processes the tree level by level. Time: O(n), Space: O(w) where w is the maximum width of the tree.", order: 2 },
      { title: "BST Properties", content: "A Binary Search Tree maintains the invariant: for every node, all values in the left subtree are less than the node, and all values in the right subtree are greater.\n\nInorder traversal of a BST gives a sorted sequence. Search, insert, and delete are O(h) where h is the height. A balanced BST has h = O(log n).", timeComplexity: "O(h) per operation", spaceComplexity: "O(h) for recursion", whenToUse: "When you need ordered data with fast search/insert/delete. BST validation, finding kth smallest, range queries, closest values.", codeExample: "def search_bst(root, target):\n    if not root:\n        return None\n    if target < root.val:\n        return search_bst(root.left, target)\n    elif target > root.val:\n        return search_bst(root.right, target)\n    else:\n        return root", flashcardFront: "What is the key property of a Binary Search Tree, and what is the time complexity of operations?", flashcardBack: "BST property: For every node, all values in its left subtree are strictly less, and all values in its right subtree are strictly greater. This enables O(h) search, insert, and delete where h is the tree height. For a balanced BST, h = O(log n). Inorder traversal produces a sorted sequence, which is useful for finding kth smallest or validating the BST.", order: 3 },
    ]},
    problems: { create: [
      // === Existing 3 problems ===
      { title: "Maximum Depth of Binary Tree", slug: "max-depth-binary-tree", difficulty: "Easy", description: "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.", examples: JSON.stringify([{input:"root = [3,9,20,null,null,15,7]",output:"3"},{input:"root = [1,null,2]",output:"2"}]), hints: JSON.stringify(["The depth of a tree = 1 + max depth of its subtrees.","Base case: an empty tree has depth 0.","This is a natural recursive problem â€” DFS."]), solution: "def max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))", explanation: "Tree DFS (Recursive): The depth of a tree is 1 + max(left depth, right depth). Base case: null node returns 0. Classic postorder DFS. O(n) time, O(h) space.", pattern: "DFS (Recursive)", order: 1 },
      { title: "Validate Binary Search Tree", slug: "validate-bst", difficulty: "Medium", description: "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST:\n- The left subtree only contains nodes less than the node.\n- The right subtree only contains nodes greater than the node.\n- Both subtrees must also be BSTs.", examples: JSON.stringify([{input:"root = [2,1,3]",output:"true"},{input:"root = [5,1,4,null,null,3,6]",output:"false",explanation:"The root's right child is 4, which is less than 5."}]), hints: JSON.stringify(["Each node must be within a valid range.","Going left narrows the upper bound, going right narrows the lower bound.","Pass min and max bounds through the recursion."]), solution: "def is_valid_bst(root, lo=float('-inf'), hi=float('inf')):\n    if not root:\n        return True\n    if root.val <= lo or root.val >= hi:\n        return False\n    return (is_valid_bst(root.left, lo, root.val) and\n            is_valid_bst(root.right, root.val, hi))", explanation: "DFS with bounds: Each node must be within (min, max) range. Going left, the current node becomes the new max. Going right, it becomes the new min. O(n) time.", pattern: "DFS (Recursive)", order: 2 },
      { title: "Binary Tree Level Order Traversal", slug: "level-order-traversal", difficulty: "Medium", description: "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).", examples: JSON.stringify([{input:"root = [3,9,20,null,null,15,7]",output:"[[3],[9,20],[15,7]]"},{input:"root = [1]",output:"[[1]]"}]), hints: JSON.stringify(["Process nodes level by level â€” which traversal does this?","Use a queue (FIFO) to process nodes in order.","At each level, process all nodes currently in the queue and add their children."]), solution: "from collections import deque\ndef level_order(root):\n    if not root: return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        result.append(level)\n    return result", explanation: "BFS (Level Order): Use a queue to process all nodes at each level. The queue size at the start of each iteration tells you how many nodes are at that level. O(n) time.", pattern: "BFS (Level Order)", order: 3 },
      // === New problems: 3E + 4M + 2H to reach 4E/6M/2H total ===
      { title: "Invert Binary Tree", slug: "invert-binary-tree", difficulty: "Easy", description: "Given the root of a binary tree, invert the tree (mirror it) and return its root.\n\nInverting a binary tree means swapping every left child with its corresponding right child throughout the entire tree.", examples: JSON.stringify([{input:"root = [4,2,7,1,3,6,9]",output:"[4,7,2,9,6,3,1]",explanation:"The tree is mirrored: left and right children are swapped at every node"},{input:"root = [2,1,3]",output:"[2,3,1]"}]), hints: JSON.stringify(["For each node, swap its left and right children.","Then recursively invert the left and right subtrees.","Base case: a null node returns null."]), solution: "def invert_tree(root):\n    if not root:\n        return None\n    root.left, root.right = root.right, root.left\n    invert_tree(root.left)\n    invert_tree(root.right)\n    return root", explanation: "DFS (Recursive): At each node, swap the left and right children, then recurse on both subtrees. Every node is visited once. O(n) time, O(h) space for the recursion stack.", pattern: "DFS (Recursive)", order: 4 },
      { title: "Same Tree", slug: "same-tree", difficulty: "Easy", description: "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical and the nodes have the same value.", examples: JSON.stringify([{input:"p = [1,2,3], q = [1,2,3]",output:"true"},{input:"p = [1,2], q = [1,null,2]",output:"false",explanation:"Structurally different trees"}]), hints: JSON.stringify(["If both nodes are null, they match. If only one is null, they don't.","Compare current values, then recurse on left and right subtrees.","Both structure and values must match at every position."]), solution: "def is_same_tree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return (p.val == q.val and\n            is_same_tree(p.left, q.left) and\n            is_same_tree(p.right, q.right))", explanation: "DFS (Recursive): Compare nodes in parallel. Both null means match, one null means mismatch. Otherwise compare values and recurse on both subtrees. O(n) time where n is the smaller tree size.", pattern: "DFS (Recursive)", order: 5 },
      { title: "Subtree of Another Tree", slug: "subtree-of-another-tree", difficulty: "Easy", description: "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values as subRoot.\n\nA subtree of a tree consists of a node in the tree and all of its descendants.", examples: JSON.stringify([{input:"root = [3,4,5,1,2], subRoot = [4,1,2]",output:"true",explanation:"The subtree rooted at node 4 matches subRoot"},{input:"root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",output:"false"}]), hints: JSON.stringify(["At each node in the main tree, check if the subtree starting there matches subRoot.","Reuse the 'same tree' logic to compare two trees.","Visit every node in the main tree and try matching."]), solution: "def is_subtree(root, sub_root):\n    if not root:\n        return False\n    if is_same(root, sub_root):\n        return True\n    return is_subtree(root.left, sub_root) or is_subtree(root.right, sub_root)\n\ndef is_same(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    return (p.val == q.val and\n            is_same(p.left, q.left) and\n            is_same(p.right, q.right))", explanation: "DFS + Same Tree check: For each node in the main tree, check if the tree rooted there is identical to subRoot. Uses the same-tree comparison as a helper. O(m * n) time in the worst case.", pattern: "DFS (Recursive)", order: 6 },
      { title: "Lowest Common Ancestor of a BST", slug: "lowest-common-ancestor-bst", difficulty: "Medium", description: "Given a binary search tree (BST) and two nodes p and q, find their lowest common ancestor (LCA).\n\nThe lowest common ancestor is the deepest node that has both p and q as descendants (a node can be a descendant of itself).", examples: JSON.stringify([{input:"root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",output:"6",explanation:"The LCA of nodes 2 and 8 is 6"},{input:"root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",output:"2",explanation:"Node 2 is an ancestor of 4 and is itself one of the targets"}]), hints: JSON.stringify(["Use the BST property: values in left subtree < root < values in right subtree.","If both p and q are smaller than root, LCA is in the left subtree.","If both are larger, LCA is in the right subtree. Otherwise, root is the LCA."]), solution: "def lowest_common_ancestor(root, p, q):\n    while root:\n        if p.val < root.val and q.val < root.val:\n            root = root.left\n        elif p.val > root.val and q.val > root.val:\n            root = root.right\n        else:\n            return root", explanation: "BST Property: If both values are less than root, go left. If both are greater, go right. Otherwise the current node is the split point and thus the LCA. O(h) time, O(1) space with iterative approach.", pattern: "BST Property", order: 7 },
      { title: "Binary Tree Right Side View", slug: "binary-tree-right-side-view", difficulty: "Medium", description: "Given the root of a binary tree, imagine yourself standing on the right side of it. Return the values of the nodes you can see ordered from top to bottom.\n\nYou can see a node if it is the rightmost node at its level.", examples: JSON.stringify([{input:"root = [1,2,3,null,5,null,4]",output:"[1,3,4]",explanation:"From the right side, you see nodes 1, 3, and 4"},{input:"root = [1,null,3]",output:"[1,3]"}]), hints: JSON.stringify(["The rightmost node at each level is visible.","Use BFS (level order traversal) and take the last node at each level.","Alternatively, use DFS visiting right child first, and take the first node at each new depth."]), solution: "from collections import deque\ndef right_side_view(root):\n    if not root:\n        return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level_size = len(queue)\n        for i in range(level_size):\n            node = queue.popleft()\n            if i == level_size - 1:\n                result.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n    return result", explanation: "BFS (Level Order): Traverse level by level using a queue. At each level, the last node dequeued is the rightmost and therefore visible from the right side. O(n) time, O(w) space.", pattern: "BFS (Level Order)", order: 8 },
      { title: "Construct Binary Tree from Preorder and Inorder", slug: "construct-tree-preorder-inorder", difficulty: "Medium", description: "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\n\nYou may assume that duplicates do not exist in the tree.", examples: JSON.stringify([{input:"preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",output:"[3,9,20,null,null,15,7]",explanation:"Root is 3 (first in preorder). In inorder, 9 is left of 3 (left subtree), 15,20,7 are right."},{input:"preorder = [-1], inorder = [-1]",output:"[-1]"}]), hints: JSON.stringify(["The first element in preorder is always the root.","Find the root in inorder to determine left and right subtree boundaries.","Recursively build left subtree then right subtree using the appropriate slices."]), solution: "def build_tree(preorder, inorder):\n    if not preorder:\n        return None\n    root_val = preorder[0]\n    root = TreeNode(root_val)\n    mid = inorder.index(root_val)\n    root.left = build_tree(preorder[1:mid+1], inorder[:mid])\n    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])\n    return root", explanation: "Recursive construction: The first element in preorder is the root. Find it in inorder to split into left and right subtrees. The number of elements in the left inorder slice tells you how many elements in preorder belong to the left subtree. Recurse on both halves. O(n^2) naive, O(n) with hash map for index lookup.", pattern: "DFS (Recursive)", order: 9 },
      { title: "Kth Smallest Element in a BST", slug: "kth-smallest-element-bst", difficulty: "Medium", description: "Given the root of a binary search tree and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.", examples: JSON.stringify([{input:"root = [3,1,4,null,2], k = 1",output:"1",explanation:"The smallest element is 1"},{input:"root = [5,3,6,2,4,null,null,1], k = 3",output:"3",explanation:"The sorted values are [1,2,3,4,5,6], so the 3rd smallest is 3"}]), hints: JSON.stringify(["Inorder traversal of a BST gives elements in sorted order.","Perform an inorder traversal and count nodes visited.","Stop when you've visited k nodes."]), solution: "def kth_smallest(root, k):\n    stack = []\n    curr = root\n    count = 0\n    while stack or curr:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        count += 1\n        if count == k:\n            return curr.val\n        curr = curr.right", explanation: "Iterative inorder traversal: Use a stack to perform inorder traversal. Each pop gives the next smallest element. Stop at the kth pop. O(H + k) time where H is the tree height, O(H) space.", pattern: "BST Inorder", order: 10 },
      { title: "Binary Tree Maximum Path Sum", slug: "binary-tree-max-path-sum", difficulty: "Hard", description: "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. The path does not need to pass through the root.\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.", examples: JSON.stringify([{input:"root = [1,2,3]",output:"6",explanation:"The optimal path is 2 -> 1 -> 3 with sum 2 + 1 + 3 = 6"},{input:"root = [-10,9,20,null,null,15,7]",output:"42",explanation:"The optimal path is 15 -> 20 -> 7 with sum 42"}]), hints: JSON.stringify(["At each node, the maximum path through it could go left-node-right.","But when returning to the parent, the path can only go through one child (it can't fork).","Track a global maximum for the 'forking' path, but return the single-branch max to the parent."]), solution: "def max_path_sum(root):\n    result = [float('-inf')]\n    \n    def dfs(node):\n        if not node:\n            return 0\n        left = max(dfs(node.left), 0)\n        right = max(dfs(node.right), 0)\n        result[0] = max(result[0], left + node.val + right)\n        return node.val + max(left, right)\n    \n    dfs(root)\n    return result[0]", explanation: "DFS with global max: At each node, compute the max gain from left and right children (clamped to 0 to ignore negative paths). Update global max with left + node + right (the 'arch' path). Return node + max(left, right) to the parent (can only extend one way). O(n) time.", pattern: "DFS (Recursive)", order: 11 },
      { title: "Serialize and Deserialize Binary Tree", slug: "serialize-deserialize-binary-tree", difficulty: "Hard", description: "Design an algorithm to serialize a binary tree into a string and deserialize that string back into the original tree structure.\n\nSerialization is converting a data structure into a sequence of bits/characters so it can be stored or transmitted. Deserialization reconstructs the tree from the serialized string.", examples: JSON.stringify([{input:"root = [1,2,3,null,null,4,5]",output:"[1,2,3,null,null,4,5]",explanation:"The tree is serialized and then reconstructed to the same structure"},{input:"root = []",output:"[]"}]), hints: JSON.stringify(["Use preorder traversal for serialization, marking null nodes with a sentinel value.","For deserialization, process the serialized string in the same preorder sequence.","Use an iterator or queue to track your position in the serialized data during reconstruction."]), solution: "class Codec:\n    def serialize(self, root):\n        result = []\n        def dfs(node):\n            if not node:\n                result.append('N')\n                return\n            result.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return ','.join(result)\n    \n    def deserialize(self, data):\n        vals = iter(data.split(','))\n        def dfs():\n            val = next(vals)\n            if val == 'N':\n                return None\n            node = TreeNode(int(val))\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()", explanation: "Preorder DFS with null markers: Serialize by doing a preorder traversal, recording each node's value and 'N' for nulls. Deserialize by reading values in the same preorder sequence, using an iterator. The null markers tell us when a subtree ends. O(n) time for both operations.", pattern: "DFS (Recursive)", order: 12 },
    ]},
  };
}
