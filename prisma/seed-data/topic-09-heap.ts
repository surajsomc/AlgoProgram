export function getHeapData() {
  return {
    name: "Heap / Priority Queue",
    slug: "heap-priority-queue",
    description: "Efficiently find the min/max element. Use for top-K problems, median finding, and merge-K-sorted operations.",
    icon: "⛰️", order: 9,
    concepts: { create: [
      { title: "Min/Max Heap", content: "A heap is a complete binary tree where each parent is smaller (min-heap) or larger (max-heap) than its children.\n\nKey operations: push O(log n), pop O(log n), peek O(1).\n\nPython: heapq module (min-heap). For max-heap, negate values.", timeComplexity: "O(n log k) for top-K", spaceComplexity: "O(k)", whenToUse: "Top-K elements, K-th largest/smallest, merge K sorted lists, running median, scheduling with priorities.", codeExample: "import heapq\ndef top_k_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap", flashcardFront: "What is a heap and what are the time complexities of its core operations?", flashcardBack: "A heap is a complete binary tree satisfying the heap property: in a min-heap, every parent is smaller than its children (root is the minimum); in a max-heap, every parent is larger (root is the maximum). Core operations: push (insert) is O(log n), pop (extract min/max) is O(log n), peek (view min/max) is O(1). Building a heap from n elements is O(n). In Python, use the heapq module which provides a min-heap. For a max-heap, negate values before pushing.", order: 1 },
      { title: "Two Heaps Pattern", content: "Use two heaps to maintain a dynamic partition of data. A max-heap stores the smaller half, and a min-heap stores the larger half.\n\nThis enables O(1) access to the median (or partition point) and O(log n) insertion.\n\nKeep the heaps balanced: sizes differ by at most 1.", timeComplexity: "O(log n) per insert", spaceComplexity: "O(n)", whenToUse: "Finding the running median of a data stream, maintaining a balanced partition, sliding window median.", codeExample: "import heapq\nclass MedianFinder:\n    def __init__(self):\n        self.lo = []  # max-heap (negated)\n        self.hi = []  # min-heap\n    def addNum(self, num):\n        heapq.heappush(self.lo, -num)\n        heapq.heappush(self.hi, -heapq.heappop(self.lo))\n        if len(self.hi) > len(self.lo):\n            heapq.heappush(self.lo, -heapq.heappop(self.hi))", flashcardFront: "How does the two-heaps pattern work for finding the running median?", flashcardBack: "Maintain a max-heap for the smaller half and a min-heap for the larger half. On each insert: push to the max-heap, then move the max-heap's top to the min-heap (to maintain ordering). Rebalance if the min-heap becomes larger. The median is the top of the max-heap (odd count) or the average of both tops (even count). Insert is O(log n), findMedian is O(1).", order: 2 },
    ]},
    problems: { create: [
      // === Existing 3 problems ===
      { title: "Kth Largest Element in an Array", slug: "kth-largest-element", difficulty: "Medium", description: "Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.", examples: JSON.stringify([{input:"nums = [3,2,1,5,6,4], k = 2",output:"5"},{input:"nums = [3,2,3,1,2,4,5,5,6], k = 4",output:"4"}]), hints: JSON.stringify(["You could sort in O(n log n), but can you do better?","A min-heap of size k always has the k-th largest at the top.","Push elements and pop when heap size exceeds k."]), solution: "import heapq\ndef find_kth_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]", explanation: "Min-Heap of size K: Maintain a min-heap of size k. After processing all elements, the top of the heap is the k-th largest. O(n log k) time, O(k) space.", pattern: "Heap / Top-K", order: 1 },
      { title: "Merge K Sorted Lists", slug: "merge-k-sorted-lists", difficulty: "Hard", description: "You are given an array of k linked lists, each sorted in ascending order. Merge all the linked lists into one sorted linked list and return it.", examples: JSON.stringify([{input:"lists = [[1,4,5],[1,3,4],[2,6]]",output:"[1,1,2,3,4,4,5,6]"},{input:"lists = []",output:"[]"}]), hints: JSON.stringify(["You need to always pick the smallest element among k candidates.","A min-heap can give you the smallest in O(log k).","Push the head of each list into a heap, pop the smallest, push its next."]), solution: "import heapq\ndef merge_k_lists(lists):\n    heap = []\n    for i, l in enumerate(lists):\n        if l:\n            heapq.heappush(heap, (l.val, i, l))\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        val, i, node = heapq.heappop(heap)\n        curr.next = node\n        curr = curr.next\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    return dummy.next", explanation: "Heap merge: Use a min-heap to always pick the smallest head among k lists. Pop the min, advance that list, push the new head. O(n log k) where n = total nodes.", pattern: "Heap / Top-K", order: 2 },
      { title: "Find Median from Data Stream", slug: "find-median-data-stream", difficulty: "Hard", description: "Design a data structure that supports:\n- addNum(num): adds an integer from the data stream\n- findMedian(): returns the median of all elements so far\n\nThe median is the middle value in an ordered list.", examples: JSON.stringify([{input:"addNum(1), addNum(2), findMedian(), addNum(3), findMedian()",output:"1.5, 2.0"}]), hints: JSON.stringify(["You need to efficiently access the middle element(s).","What if you split the data into two halves?","Use a max-heap for the lower half and a min-heap for the upper half."]), solution: "import heapq\nclass MedianFinder:\n    def __init__(self):\n        self.lo = []  # max-heap (negated)\n        self.hi = []  # min-heap\n    \n    def addNum(self, num):\n        heapq.heappush(self.lo, -num)\n        heapq.heappush(self.hi, -heapq.heappop(self.lo))\n        if len(self.hi) > len(self.lo):\n            heapq.heappush(self.lo, -heapq.heappop(self.hi))\n    \n    def findMedian(self):\n        if len(self.lo) > len(self.hi):\n            return -self.lo[0]\n        return (-self.lo[0] + self.hi[0]) / 2", explanation: "Two Heaps: A max-heap stores the lower half, a min-heap stores the upper half. Keep them balanced. The median is the top of the max-heap (odd count) or average of both tops (even count). O(log n) add, O(1) find.", pattern: "Heap / Top-K", order: 3 },
      // === New problems: 2E + 3M to reach 2E/4M/2H total ===
      { title: "Last Stone Weight", slug: "last-stone-weight", difficulty: "Easy", description: "You are given an array of integers stones where stones[i] is the weight of the ith stone.\n\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. If x == y, both stones are destroyed. If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n\nAt the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0.", examples: JSON.stringify([{input:"stones = [2,7,4,1,8,1]",output:"1",explanation:"Smash 8 and 7 -> 1, smash 4 and 2 -> 2, smash 2 and 1 -> 1, smash 1 and 1 -> 0. Last stone = 1"},{input:"stones = [1]",output:"1"}]), hints: JSON.stringify(["You always need the two heaviest stones. What data structure gives you the maximum efficiently?","Use a max-heap to always access the two largest stones.","In Python, use a min-heap with negated values to simulate a max-heap."]), solution: "import heapq\ndef last_stone_weight(stones):\n    heap = [-s for s in stones]\n    heapq.heapify(heap)\n    while len(heap) > 1:\n        first = -heapq.heappop(heap)\n        second = -heapq.heappop(heap)\n        if first != second:\n            heapq.heappush(heap, -(first - second))\n    return -heap[0] if heap else 0", explanation: "Max-Heap simulation: Negate all values and use Python's min-heap as a max-heap. Repeatedly pop the two largest, compute the difference, and push back if non-zero. O(n log n) time.", pattern: "Heap / Top-K", order: 4 },
      { title: "Kth Largest Element in a Stream", slug: "kth-largest-element-stream", difficulty: "Easy", description: "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nImplement KthLargest class:\n- KthLargest(int k, int[] nums): Initializes the object with the integer k and the stream of integers nums.\n- int add(int val): Appends the integer val to the stream and returns the element representing the kth largest element in the stream.", examples: JSON.stringify([{input:"KthLargest(3, [4,5,8,2]), add(3), add(5), add(10), add(9), add(4)",output:"4, 5, 5, 8, 8",explanation:"With k=3, after adding each element, the 3rd largest is returned"},{input:"KthLargest(1, []), add(3), add(5)",output:"3, 5"}]), hints: JSON.stringify(["Maintain a min-heap of size k.","The top of the heap is always the kth largest element.","When adding, push and pop if the heap exceeds size k."]), solution: "import heapq\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.heap = []\n        for num in nums:\n            self.add(num)\n    \n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]", explanation: "Min-Heap of size K: Keep a min-heap of exactly k elements. The root is always the kth largest. When adding, push the new value. If the heap exceeds size k, pop the smallest. O(log k) per add, O(n log k) initialization.", pattern: "Heap / Top-K", order: 5 },
      { title: "K Closest Points to Origin", slug: "k-closest-points-origin", difficulty: "Medium", description: "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\n\nThe distance between two points on the X-Y plane is the Euclidean distance. You may return the answer in any order.", examples: JSON.stringify([{input:"points = [[1,3],[-2,2]], k = 1",output:"[[-2,2]]",explanation:"Distance of (1,3) = sqrt(10), distance of (-2,2) = sqrt(8). (-2,2) is closer."},{input:"points = [[3,3],[5,-1],[-2,4]], k = 2",output:"[[3,3],[-2,4]]"}]), hints: JSON.stringify(["You need the k smallest distances. What data structure helps with top-K problems?","Use a max-heap of size k: if a new point is closer than the farthest in the heap, replace it.","In Python, use a min-heap with negated distances to simulate a max-heap."]), solution: "import heapq\ndef k_closest(points, k):\n    heap = []\n    for x, y in points:\n        dist = -(x*x + y*y)\n        if len(heap) < k:\n            heapq.heappush(heap, (dist, x, y))\n        elif dist > heap[0][0]:\n            heapq.heapreplace(heap, (dist, x, y))\n    return [[x, y] for (_, x, y) in heap]", explanation: "Max-Heap of size K (negated distances): Maintain a max-heap of size k using negated squared distances. For each point, if the heap has fewer than k elements, push. Otherwise, if the current point is closer than the farthest point in the heap, replace. O(n log k) time.", pattern: "Heap / Top-K", order: 6 },
      { title: "Task Scheduler", slug: "task-scheduler", difficulty: "Medium", description: "You are given an array of CPU tasks, each represented by a character, and a cooling interval n. Each cycle allows completion of one task. Tasks of the same type must be separated by at least n intervals.\n\nReturn the minimum number of intervals the CPU will take to finish all the given tasks.", examples: JSON.stringify([{input:'tasks = ["A","A","A","B","B","B"], n = 2',output:"8",explanation:"A -> B -> idle -> A -> B -> idle -> A -> B. Total 8 intervals."},{input:'tasks = ["A","A","A","B","B","B"], n = 0',output:"6",explanation:"No cooling needed, tasks take 6 intervals."}]), hints: JSON.stringify(["The most frequent task determines the structure of the schedule.","Use a max-heap to always schedule the most frequent remaining task.","After executing a task, it enters cooldown. Use a queue to track when tasks become available again."]), solution: "import heapq\nfrom collections import Counter, deque\ndef least_interval(tasks, n):\n    counts = Counter(tasks)\n    heap = [-c for c in counts.values()]\n    heapq.heapify(heap)\n    queue = deque()  # (remaining_count, available_time)\n    time = 0\n    while heap or queue:\n        time += 1\n        if heap:\n            count = 1 + heapq.heappop(heap)  # +1 because negated\n            if count != 0:\n                queue.append((count, time + n))\n        if queue and queue[0][1] == time:\n            heapq.heappush(heap, queue.popleft()[0])\n    return time", explanation: "Max-Heap + Cooldown Queue: Use a max-heap to greedily pick the most frequent task. After execution, place it in a cooldown queue with its available time. When a task's cooldown expires, push it back into the heap. Idle if both heap and available tasks are empty. O(n * m) where m is the number of unique tasks.", pattern: "Heap / Greedy", order: 7 },
      { title: "Reorganize String", slug: "reorganize-string", difficulty: "Medium", description: "Given a string s, rearrange the characters of s so that any two adjacent characters are not the same.\n\nReturn any valid rearrangement. If it is not possible, return an empty string.", examples: JSON.stringify([{input:'s = "aab"',output:'"aba"',explanation:"'a' and 'b' are never adjacent in 'aba'"},{input:'s = "aaab"',output:'""',explanation:"No valid arrangement exists since 'a' appears 3 times and the string length is 4"}]), hints: JSON.stringify(["Impossible if any character appears more than (n+1)/2 times.","Greedily place the most frequent character first using a max-heap.","After placing a character, push it back with decremented count (but not immediately available)."]), solution: "import heapq\nfrom collections import Counter\ndef reorganize_string(s):\n    counts = Counter(s)\n    heap = [(-c, ch) for ch, c in counts.items()]\n    heapq.heapify(heap)\n    result = []\n    prev_count, prev_char = 0, ''\n    while heap:\n        count, char = heapq.heappop(heap)\n        if prev_count < 0:\n            heapq.heappush(heap, (prev_count, prev_char))\n        result.append(char)\n        prev_count = count + 1  # +1 because negated\n        prev_char = char\n    return ''.join(result) if len(result) == len(s) else ''", explanation: "Max-Heap with delayed re-insertion: Always pick the most frequent character (max-heap). After placing it, hold it aside and push the previously held character back. This ensures no two adjacent characters are the same. If the result is shorter than the input, rearrangement was impossible. O(n log k) time where k is unique characters.", pattern: "Heap / Greedy", order: 8 },
    ]},
  };
}
