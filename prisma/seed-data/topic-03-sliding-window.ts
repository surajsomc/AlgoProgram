export function getSlidingWindowData() {
  return {
    name: "Sliding Window",
    slug: "sliding-window",
    description: "Maintain a window over a contiguous subarray/substring. Expand and shrink the window to find optimal subarrays.",
    icon: "\uD83E\uDE9F", order: 3,
    concepts: { create: [
      {
        title: "Fixed-Size Window",
        content: "Window of size k slides across the array. Add the new element entering the window, remove the element leaving.\n\nUseful for: max sum of subarray of size k, averages of subarrays.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(1)",
        whenToUse: "When the problem specifies a fixed window size k.",
        codeExample: "def max_sum_subarray(nums, k):\n    window_sum = sum(nums[:k])\n    best = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i-k]\n        best = max(best, window_sum)\n    return best",
        flashcardFront: "How does a fixed-size sliding window work, and what is its time complexity?",
        flashcardBack: "A fixed-size window of size k slides one element at a time. At each step, add the new element entering the window and remove the element leaving. This avoids recomputing the entire window from scratch. Time: O(n) since each element is added and removed exactly once. Space: O(1) if only tracking a sum/max.",
        order: 1,
      },
      {
        title: "Variable-Size Window",
        content: "Expand the right pointer to include elements. When a constraint is violated, shrink from the left.\n\nPattern: right pointer always moves forward. Left pointer moves forward only when needed to restore validity.\n\nUseful for: longest substring without repeating chars, minimum window substring.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(k) where k = character set",
        whenToUse: "Finding longest/shortest subarray or substring that satisfies a condition.",
        codeExample: "def longest_unique_substring(s):\n    seen = set()\n    l = best = 0\n    for r in range(len(s)):\n        while s[r] in seen:\n            seen.remove(s[l])\n            l += 1\n        seen.add(s[r])\n        best = max(best, r - l + 1)\n    return best",
        flashcardFront: "In a variable-size sliding window, when do you expand vs shrink the window?",
        flashcardBack: "Expand (move right pointer) to include more elements and explore larger windows. Shrink (move left pointer) when the window violates a constraint (e.g., contains a duplicate, sum exceeds target). The right pointer always moves forward; the left pointer only advances to restore validity. Both pointers move at most n times total, giving O(n) time.",
        order: 2,
      },
    ]},
    problems: { create: [
      // ===== EXISTING 3 PROBLEMS =====
      {
        title: "Best Time to Buy and Sell Stock",
        slug: "best-time-buy-sell-stock",
        difficulty: "Easy",
        description: "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy and a single day to sell in the future. Return the maximum profit. If no profit is possible, return 0.",
        examples: JSON.stringify([
          { input: "prices = [7,1,5,3,6,4]", output: "5", explanation: "Buy on day 2 (price=1), sell on day 5 (price=6), profit=5." },
          { input: "prices = [7,6,4,3,1]", output: "0" },
        ]),
        hints: JSON.stringify([
          "Track the minimum price seen so far.",
          "At each day, the profit is current price - minimum price so far.",
          "This is like a sliding window where left is the buy day and right is the sell day.",
        ]),
        solution: "def max_profit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit",
        explanation: "Sliding Window / Greedy: Track minimum price as you scan. At each price, check profit against the minimum seen so far. The window conceptually stretches from the min-price day to the current day. O(n) time, O(1) space.",
        pattern: "Sliding Window",
        order: 1,
      },
      {
        title: "Longest Substring Without Repeating Characters",
        slug: "longest-substring-no-repeat",
        difficulty: "Medium",
        description: "Given a string s, find the length of the longest substring without repeating characters.",
        examples: JSON.stringify([
          { input: 's = "abcabcbb"', output: "3", explanation: 'The answer is "abc" with length 3.' },
          { input: 's = "bbbbb"', output: "1" },
          { input: 's = "pwwkew"', output: "3" },
        ]),
        hints: JSON.stringify([
          "Use a set to track characters in the current window.",
          "Expand the window by moving the right pointer.",
          "When you find a duplicate, shrink from the left until the duplicate is removed.",
        ]),
        solution: "def length_of_longest_substring(s):\n    char_set = set()\n    l = 0\n    result = 0\n    for r in range(len(s)):\n        while s[r] in char_set:\n            char_set.remove(s[l])\n            l += 1\n        char_set.add(s[r])\n        result = max(result, r - l + 1)\n    return result",
        explanation: "Variable-size Sliding Window: Expand right pointer, adding chars to set. When a duplicate is found, shrink from left until the window is valid again. Track the maximum window size. O(n) time.",
        pattern: "Sliding Window",
        order: 2,
      },
      {
        title: "Minimum Window Substring",
        slug: "minimum-window-substring",
        difficulty: "Hard",
        description: "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If no such substring exists, return empty string.",
        examples: JSON.stringify([
          { input: 's = "ADOBECODEBANC", t = "ABC"', output: '"BANC"' },
          { input: 's = "a", t = "a"', output: '"a"' },
        ]),
        hints: JSON.stringify([
          "Use a frequency map for characters in t.",
          "Expand the window until all characters are covered.",
          "Then shrink from the left to find the minimum valid window.",
        ]),
        solution: "from collections import Counter\ndef min_window(s, t):\n    need = Counter(t)\n    missing = len(t)\n    l = start = end = 0\n    for r, char in enumerate(s, 1):\n        if need[char] > 0:\n            missing -= 1\n        need[char] -= 1\n        if missing == 0:\n            while need[s[l]] < 0:\n                need[s[l]] += 1\n                l += 1\n            if not end or r - l <= end - start:\n                start, end = l, r\n            need[s[l]] += 1\n            missing += 1\n            l += 1\n    return s[start:end]",
        explanation: "Variable Sliding Window with frequency map: Track how many chars from t are still needed. Expand right to cover all chars, then shrink left to minimize. O(n) time.",
        pattern: "Sliding Window",
        order: 3,
      },

      // ===== NEW PROBLEMS =====
      {
        title: "Maximum Average Subarray I",
        slug: "maximum-average-subarray-i",
        difficulty: "Easy",
        description: "You are given an integer array nums consisting of n elements, and an integer k.\n\nFind a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10^-5 will be accepted.",
        examples: JSON.stringify([
          { input: "nums = [1,12,-5,-6,50,3], k = 4", output: "12.75", explanation: "Maximum average is (12 + (-5) + (-6) + 50) / 4 = 12.75" },
          { input: "nums = [5], k = 1", output: "5.0" },
        ]),
        hints: JSON.stringify([
          "This is a fixed-size sliding window problem.",
          "Compute the sum of the first k elements, then slide the window by adding the next element and removing the leftmost.",
          "Track the maximum sum and divide by k at the end.",
        ]),
        solution: "def find_max_average(nums, k):\n    window_sum = sum(nums[:k])\n    max_sum = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i - k]\n        max_sum = max(max_sum, window_sum)\n    return max_sum / k",
        explanation: "Fixed-Size Sliding Window: Compute sum of first k elements. Slide the window one element at a time, adding the new element and subtracting the departing one. Track max sum. O(n) time, O(1) space.",
        pattern: "Sliding Window (Fixed)",
        order: 4,
      },
      {
        title: "Contains Duplicate II",
        slug: "contains-duplicate-ii",
        difficulty: "Easy",
        description: "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.",
        examples: JSON.stringify([
          { input: "nums = [1,2,3,1], k = 3", output: "true" },
          { input: "nums = [1,0,1,1], k = 1", output: "true" },
          { input: "nums = [1,2,3,1,2,3], k = 2", output: "false" },
        ]),
        hints: JSON.stringify([
          "You need to find duplicates within a window of size k.",
          "Use a hash set to track elements in the current window.",
          "When the window exceeds size k, remove the oldest element from the set.",
        ]),
        solution: "def contains_nearby_duplicate(nums, k):\n    window = set()\n    for i, num in enumerate(nums):\n        if num in window:\n            return True\n        window.add(num)\n        if len(window) > k:\n            window.remove(nums[i - k])\n    return False",
        explanation: "Sliding Window + Hash Set: Maintain a set of elements within the window of size k. If a new element is already in the set, duplicates exist within range k. Remove the oldest element when window exceeds k. O(n) time, O(k) space.",
        pattern: "Sliding Window (Fixed)",
        order: 5,
      },
      {
        title: "Longest Repeating Character Replacement",
        slug: "longest-repeating-char-replacement",
        difficulty: "Medium",
        description: "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most k times.\n\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
        examples: JSON.stringify([
          { input: 's = "ABAB", k = 2', output: "4", explanation: "Replace the two A's with B's or vice versa." },
          { input: 's = "AABABBA", k = 1', output: "4" },
        ]),
        hints: JSON.stringify([
          "Use a sliding window and track the frequency of each character in the window.",
          "The number of characters to replace = window_size - count_of_most_frequent_char.",
          "If replacements needed > k, shrink the window from the left.",
        ]),
        solution: "def character_replacement(s, k):\n    count = {}\n    l = 0\n    max_freq = 0\n    result = 0\n    for r in range(len(s)):\n        count[s[r]] = count.get(s[r], 0) + 1\n        max_freq = max(max_freq, count[s[r]])\n        while (r - l + 1) - max_freq > k:\n            count[s[l]] -= 1\n            l += 1\n        result = max(result, r - l + 1)\n    return result",
        explanation: "Variable Sliding Window: Track character frequencies in the window. The key insight is that we need to replace (window_size - max_frequency) characters. If this exceeds k, shrink the window. We never need to decrease max_freq because we only care about maximizing. O(n) time, O(1) space.",
        pattern: "Sliding Window",
        order: 6,
      },
      {
        title: "Permutation in String",
        slug: "permutation-in-string",
        difficulty: "Medium",
        description: "Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\n\nIn other words, return true if one of s1's permutations is the substring of s2.",
        examples: JSON.stringify([
          { input: 's1 = "ab", s2 = "eidbaooo"', output: "true", explanation: 's2 contains one permutation of s1 ("ba").' },
          { input: 's1 = "ab", s2 = "eidboaoo"', output: "false" },
        ]),
        hints: JSON.stringify([
          "A permutation of s1 in s2 means a substring of s2 has the same character frequencies as s1.",
          "Use a fixed-size window of length len(s1) on s2.",
          "Track character frequency differences; when all are zero, you found a permutation.",
        ]),
        solution: "def check_inclusion(s1, s2):\n    if len(s1) > len(s2):\n        return False\n    count = {}\n    for c in s1:\n        count[c] = count.get(c, 0) + 1\n    for c in s2[:len(s1)]:\n        count[c] = count.get(c, 0) - 1\n    if all(v == 0 for v in count.values()):\n        return True\n    for i in range(len(s1), len(s2)):\n        count[s2[i]] = count.get(s2[i], 0) - 1\n        count[s2[i - len(s1)]] = count.get(s2[i - len(s1)], 0) + 1\n        if all(v == 0 for v in count.values()):\n            return True\n    return False",
        explanation: "Fixed Sliding Window: Maintain a window of size len(s1) on s2. Track the difference in character frequencies between s1 and the current window. When all differences are zero, the window is a permutation of s1. O(n) time where n = len(s2).",
        pattern: "Sliding Window (Fixed)",
        order: 7,
      },
      {
        title: "Minimum Size Subarray Sum",
        slug: "minimum-size-subarray-sum",
        difficulty: "Medium",
        description: "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.",
        examples: JSON.stringify([
          { input: "target = 7, nums = [2,3,1,2,4,3]", output: "2", explanation: "The subarray [4,3] has the minimal length under the problem constraint." },
          { input: "target = 4, nums = [1,4,4]", output: "1" },
          { input: "target = 11, nums = [1,1,1,1,1,1,1,1]", output: "0" },
        ]),
        hints: JSON.stringify([
          "Use a variable-size sliding window.",
          "Expand the window until the sum is >= target.",
          "Then shrink from the left to find the minimum length that still satisfies the condition.",
        ]),
        solution: "def min_sub_array_len(target, nums):\n    l = 0\n    current_sum = 0\n    min_len = float('inf')\n    for r in range(len(nums)):\n        current_sum += nums[r]\n        while current_sum >= target:\n            min_len = min(min_len, r - l + 1)\n            current_sum -= nums[l]\n            l += 1\n    return min_len if min_len != float('inf') else 0",
        explanation: "Variable Sliding Window: Expand right to increase sum. When sum >= target, try shrinking from left while maintaining the condition. Track the minimum window length. O(n) time, O(1) space.",
        pattern: "Sliding Window (Variable)",
        order: 8,
      },
      {
        title: "Frequency of the Most Frequent Element",
        slug: "frequency-most-frequent-element",
        difficulty: "Medium",
        description: "The frequency of an element is the number of times it occurs in an array.\n\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\n\nReturn the maximum possible frequency of an element after performing at most k operations.",
        examples: JSON.stringify([
          { input: "nums = [1,2,4], k = 5", output: "3", explanation: "Increment 1 twice and 2 once to make all elements 4. Frequency of 4 is 3." },
          { input: "nums = [1,4,8,13], k = 5", output: "2" },
        ]),
        hints: JSON.stringify([
          "Sort the array first. You want to make elements equal to the rightmost element in a window.",
          "The cost to make all elements in window [l, r] equal to nums[r] is: nums[r] * window_size - sum(window).",
          "Use a sliding window: if the cost exceeds k, shrink from the left.",
        ]),
        solution: "def max_frequency(nums, k):\n    nums.sort()\n    l = 0\n    total = 0\n    result = 0\n    for r in range(len(nums)):\n        total += nums[r]\n        while nums[r] * (r - l + 1) - total > k:\n            total -= nums[l]\n            l += 1\n        result = max(result, r - l + 1)\n    return result",
        explanation: "Sort + Variable Sliding Window: Sort the array so we can make elements equal to the rightmost in the window. The cost is nums[r] * window_size - window_sum. Shrink when cost > k. O(n log n) time for sorting, O(1) space.",
        pattern: "Sliding Window (Variable)",
        order: 9,
      },
      {
        title: "Sliding Window Maximum",
        slug: "sliding-window-maximum",
        difficulty: "Hard",
        description: "You are given an array of integers nums, and there is a sliding window of size k which moves from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window (the maximum value in each window position).",
        examples: JSON.stringify([
          { input: "nums = [1,3,-1,-3,5,3,6,7], k = 3", output: "[3,3,5,5,6,7]", explanation: "Window [1,3,-1]=3, [3,-1,-3]=3, [-1,-3,5]=5, [-3,5,3]=5, [5,3,6]=6, [3,6,7]=7" },
          { input: "nums = [1], k = 1", output: "[1]" },
        ]),
        hints: JSON.stringify([
          "A brute-force approach checks all k elements per window. Can you do better?",
          "Use a monotonic decreasing deque to track candidates for the maximum.",
          "The front of the deque is always the maximum in the current window. Remove elements that are out of bounds.",
        ]),
        solution: "from collections import deque\ndef max_sliding_window(nums, k):\n    dq = deque()  # stores indices\n    result = []\n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    return result",
        explanation: "Monotonic Deque: Maintain a deque of indices in decreasing order of values. For each new element, remove smaller elements from the back (they can never be the max). Remove elements from the front that are outside the window. The front is always the max. O(n) time, O(k) space.",
        pattern: "Sliding Window / Monotonic Deque",
        order: 10,
      },
    ]},
  };
}
