export function getArraysAndHashingData() {
  return {
    name: "Arrays & Hashing",
    slug: "arrays-and-hashing",
    description: "Use hash maps for O(1) lookups, frequency counting, and grouping. Converts brute-force O(n^2) to O(n).",
    icon: "\uD83D\uDD22", order: 1,
    concepts: { create: [
      {
        title: "Hash Map Lookup",
        content: "Store key-value pairs for O(1) average lookups. Instead of scanning the array to find a match, store seen values and check the map.\n\nCore pattern: iterate once, check map, update map.\n\nCommon uses: counting frequencies, finding complements (Two Sum), grouping anagrams, detecting duplicates.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(n)",
        whenToUse: "When you need O(1) existence checks, frequency counts, or pair-finding.",
        codeExample: "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        comp = target - num\n        if comp in seen:\n            return [seen[comp], i]\n        seen[num] = i",
        flashcardFront: "What is the time complexity of a hash map lookup?",
        flashcardBack: "O(1) average, O(n) worst case. Hash maps use a hash function to compute an index into an array of buckets. Collisions degrade performance, but with a good hash function and load factor, lookups are constant time on average.",
        order: 1,
      },
      {
        title: "Frequency Counting",
        content: "Count occurrences of elements using a hash map or Counter. Useful for finding duplicates, top-K elements, and validating anagrams.\n\nPattern: build a frequency map, then query it.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(n)",
        whenToUse: "When you need to count occurrences, find most/least common elements, or check if two collections have same element frequencies.",
        codeExample: "from collections import Counter\ndef is_anagram(s, t):\n    return Counter(s) == Counter(t)",
        flashcardFront: "How do you check if two strings are anagrams using hashing?",
        flashcardBack: "Build a frequency map (Counter) for each string and compare them. Two strings are anagrams if and only if they have identical character frequencies. Time: O(n), Space: O(1) since the character set is fixed (e.g., 26 lowercase letters).",
        order: 2,
      },
    ]},
    problems: { create: [
      // ===== EXISTING 4 PROBLEMS =====
      {
        title: "Two Sum",
        slug: "two-sum",
        difficulty: "Easy",
        description: "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.",
        examples: JSON.stringify([
          { input: "nums = [2,7,11,15], target = 9", output: "[0,1]", explanation: "nums[0] + nums[1] = 2 + 7 = 9" },
          { input: "nums = [3,2,4], target = 6", output: "[1,2]" },
        ]),
        hints: JSON.stringify([
          "Think about what value you need to find for each number.",
          "For each number, the complement is target - num. How can you check if you've seen the complement before?",
          "Use a hash map to store numbers you've seen with their indices.",
        ]),
        solution: "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",
        explanation: "Hash Map Lookup: For each number, compute complement = target - num. Check if complement exists in hash map. If yes, return both indices. If no, store current number and index. One pass, O(n) time, O(n) space.",
        pattern: "Hash Map / Hash Set",
        order: 1,
      },
      {
        title: "Contains Duplicate",
        slug: "contains-duplicate",
        difficulty: "Easy",
        description: "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.",
        examples: JSON.stringify([
          { input: "nums = [1,2,3,1]", output: "true" },
          { input: "nums = [1,2,3,4]", output: "false" },
        ]),
        hints: JSON.stringify([
          "What data structure gives O(1) lookup?",
          "Add elements to a set as you iterate. If you try to add one that's already there...",
          "A set automatically handles uniqueness.",
        ]),
        solution: "def contains_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False",
        explanation: "Hash Set: Iterate through the array, adding each element to a set. If an element is already in the set, we found a duplicate. O(n) time, O(n) space.",
        pattern: "Hash Map / Hash Set",
        order: 2,
      },
      {
        title: "Group Anagrams",
        slug: "group-anagrams",
        difficulty: "Medium",
        description: "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.",
        examples: JSON.stringify([
          { input: 'strs = ["eat","tea","tan","ate","nat","bat"]', output: '[["bat"],["nat","tan"],["ate","eat","tea"]]' },
          { input: 'strs = [""]', output: '[[""]]' },
        ]),
        hints: JSON.stringify([
          "Two words are anagrams if they have the same characters in the same frequencies.",
          "What if you sorted each word? Anagrams would have the same sorted form.",
          "Use sorted word as a hash map key, group words with the same key.",
        ]),
        solution: "from collections import defaultdict\ndef group_anagrams(strs):\n    groups = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())",
        explanation: "Hash Map with sorted key: Sort each string to create a canonical form. Use that as a hash map key. All anagrams map to the same key. O(n * k log k) where k is max string length.",
        pattern: "Hash Map / Hash Set",
        order: 3,
      },
      {
        title: "Top K Frequent Elements",
        slug: "top-k-frequent",
        difficulty: "Medium",
        description: "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.",
        examples: JSON.stringify([
          { input: "nums = [1,1,1,2,2,3], k = 2", output: "[1,2]" },
          { input: "nums = [1], k = 1", output: "[1]" },
        ]),
        hints: JSON.stringify([
          "First, count the frequency of each element.",
          "How can you efficiently find the top-k from a frequency map?",
          "Bucket sort: create buckets where index = frequency, then collect from highest bucket down.",
        ]),
        solution: "def top_k_frequent(nums, k):\n    count = {}\n    for n in nums:\n        count[n] = count.get(n, 0) + 1\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result",
        explanation: "Frequency counting + bucket sort: Count frequencies with hash map, then use bucket sort where index = frequency. Iterate from highest frequency bucket to collect top-k. O(n) time.",
        pattern: "Hash Map / Hash Set",
        order: 4,
      },

      // ===== NEW PROBLEMS =====
      {
        title: "Valid Anagram",
        slug: "valid-anagram",
        difficulty: "Easy",
        description: "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        examples: JSON.stringify([
          { input: 's = "anagram", t = "nagaram"', output: "true" },
          { input: 's = "rat", t = "car"', output: "false" },
        ]),
        hints: JSON.stringify([
          "Two strings are anagrams if they contain the same characters with the same frequencies.",
          "Build a frequency count for one string and decrement for the other.",
          "If all counts end at zero, the strings are anagrams.",
        ]),
        solution: "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    count = {}\n    for c in s:\n        count[c] = count.get(c, 0) + 1\n    for c in t:\n        count[c] = count.get(c, 0) - 1\n        if count[c] < 0:\n            return False\n    return True",
        explanation: "Frequency Counting: Build a character frequency map from s. Decrement counts while iterating through t. If any count goes negative or lengths differ, they are not anagrams. O(n) time, O(1) space (fixed character set).",
        pattern: "Hash Map / Hash Set",
        order: 5,
      },
      {
        title: "Two Sum II - Sorted Array",
        slug: "two-sum-ii-sorted",
        difficulty: "Easy",
        description: "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.\n\nReturn the indices of the two numbers (1-indexed) as an integer array [index1, index2].\n\nYou may not use the same element twice. Your solution must use only constant extra space.",
        examples: JSON.stringify([
          { input: "numbers = [2,7,11,15], target = 9", output: "[1,2]", explanation: "numbers[0] + numbers[1] = 2 + 7 = 9" },
          { input: "numbers = [2,3,4], target = 6", output: "[1,3]" },
        ]),
        hints: JSON.stringify([
          "The array is already sorted. How can you exploit that?",
          "Use two pointers: one at the beginning and one at the end.",
          "If the sum is too small, move the left pointer right. If too large, move the right pointer left.",
        ]),
        solution: "def two_sum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        s = numbers[l] + numbers[r]\n        if s == target:\n            return [l + 1, r + 1]\n        elif s < target:\n            l += 1\n        else:\n            r -= 1\n    return []",
        explanation: "Two Pointers on sorted array: Start from both ends. If the sum equals target, return indices. If less, move left pointer right to increase sum. If more, move right pointer left to decrease sum. O(n) time, O(1) space.",
        pattern: "Hash Map / Hash Set",
        order: 6,
      },
      {
        title: "Product of Array Except Self",
        slug: "product-of-array-except-self",
        difficulty: "Medium",
        description: "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.",
        examples: JSON.stringify([
          { input: "nums = [1,2,3,4]", output: "[24,12,8,6]" },
          { input: "nums = [-1,1,0,-3,3]", output: "[0,0,9,0,0]" },
        ]),
        hints: JSON.stringify([
          "For each index i, the answer is (product of all elements to the left) * (product of all elements to the right).",
          "Build a prefix product array going left to right.",
          "Then multiply by a suffix product going right to left. You can do the suffix pass in-place.",
        ]),
        solution: "def product_except_self(nums):\n    n = len(nums)\n    answer = [1] * n\n    prefix = 1\n    for i in range(n):\n        answer[i] = prefix\n        prefix *= nums[i]\n    suffix = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= suffix\n        suffix *= nums[i]\n    return answer",
        explanation: "Prefix and Suffix Products: First pass builds prefix products (product of all elements before i). Second pass multiplies by suffix products (product of all elements after i). No division needed. O(n) time, O(1) extra space (output array doesn't count).",
        pattern: "Prefix Sum / Product",
        order: 7,
      },
      {
        title: "Longest Consecutive Sequence",
        slug: "longest-consecutive-sequence",
        difficulty: "Medium",
        description: "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.",
        examples: JSON.stringify([
          { input: "nums = [100,4,200,1,3,2]", output: "4", explanation: "The longest consecutive sequence is [1, 2, 3, 4]. Its length is 4." },
          { input: "nums = [0,3,7,2,5,8,4,6,0,1]", output: "9" },
        ]),
        hints: JSON.stringify([
          "Put all numbers in a hash set for O(1) lookup.",
          "A number is the start of a sequence if (num - 1) is not in the set.",
          "For each sequence start, count consecutive numbers going up.",
        ]),
        solution: "def longest_consecutive(nums):\n    num_set = set(nums)\n    best = 0\n    for num in num_set:\n        if num - 1 not in num_set:\n            length = 1\n            while num + length in num_set:\n                length += 1\n            best = max(best, length)\n    return best",
        explanation: "Hash Set: Add all numbers to a set. For each number that is the start of a sequence (num-1 not in set), count how long the consecutive run is. Each number is visited at most twice. O(n) time, O(n) space.",
        pattern: "Hash Map / Hash Set",
        order: 8,
      },
      {
        title: "Encode and Decode Strings",
        slug: "encode-and-decode-strings",
        difficulty: "Medium",
        description: "Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.\n\nImplement encode and decode functions. The encoded string should be as compact as possible.",
        examples: JSON.stringify([
          { input: 'strs = ["hello","world"]', output: '["hello","world"]', explanation: "Encode to a single string, then decode back to the original list." },
          { input: 'strs = ["we","say",":","yes"]', output: '["we","say",":","yes"]' },
        ]),
        hints: JSON.stringify([
          "You cannot simply use a delimiter like comma since strings may contain any character.",
          "What if you prefix each string with its length?",
          "Use the format: length + separator + string for each entry (e.g., '5#hello5#world').",
        ]),
        solution: "def encode(strs):\n    result = ''\n    for s in strs:\n        result += str(len(s)) + '#' + s\n    return result\n\ndef decode(s):\n    result = []\n    i = 0\n    while i < len(s):\n        j = i\n        while s[j] != '#':\n            j += 1\n        length = int(s[i:j])\n        result.append(s[j + 1:j + 1 + length])\n        i = j + 1 + length\n    return result",
        explanation: "Length-prefix encoding: Encode each string as 'length#string'. When decoding, read the length, skip the delimiter, and extract exactly that many characters. Handles all characters including delimiters. O(n) time where n is total characters.",
        pattern: "String Encoding",
        order: 9,
      },
      {
        title: "Valid Sudoku",
        slug: "valid-sudoku",
        difficulty: "Medium",
        description: "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\n1. Each row must contain the digits 1-9 without repetition.\n2. Each column must contain the digits 1-9 without repetition.\n3. Each of the nine 3 x 3 sub-boxes must contain the digits 1-9 without repetition.\n\nNote: A Sudoku board (partially filled) could be valid but is not necessarily solvable.",
        examples: JSON.stringify([
          { input: "board = [['5','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],...]", output: "true" },
          { input: "board = [['8','3','.','.','7','.','.','.','.'],['6','.','.','1','9','5','.','.','.'],...]", output: "false", explanation: "Same as first example except the top-left '5' is replaced with '8'. Two 8s appear in the first 3x3 box." },
        ]),
        hints: JSON.stringify([
          "Use hash sets to track seen numbers for each row, column, and 3x3 box.",
          "For the 3x3 boxes, the box index can be computed as (row // 3, col // 3).",
          "If any number appears twice in the same row, column, or box, the board is invalid.",
        ]),
        solution: "def is_valid_sudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == '.':\n                continue\n            box_idx = (r // 3) * 3 + c // 3\n            if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                return False\n            rows[r].add(val)\n            cols[c].add(val)\n            boxes[box_idx].add(val)\n    return True",
        explanation: "Hash Sets for validation: Maintain a set for each row, column, and 3x3 box. For each filled cell, check if the value already exists in the corresponding row, column, or box set. Box index = (row//3)*3 + col//3. O(81) = O(1) time.",
        pattern: "Hash Map / Hash Set",
        order: 10,
      },
      {
        title: "First Missing Positive",
        slug: "first-missing-positive",
        difficulty: "Hard",
        description: "Given an unsorted integer array nums, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.",
        examples: JSON.stringify([
          { input: "nums = [1,2,0]", output: "3", explanation: "1 and 2 are present, so the answer is 3." },
          { input: "nums = [3,4,-1,1]", output: "2" },
          { input: "nums = [7,8,9,11,12]", output: "1" },
        ]),
        hints: JSON.stringify([
          "The answer must be in the range [1, n+1] where n is the array length.",
          "Use the array itself as a hash map by placing each number at its correct index (num-1).",
          "Cyclic sort: swap nums[i] to position nums[i]-1 until every number is at its correct position or out of range.",
        ]),
        solution: "def first_missing_positive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1",
        explanation: "Cyclic Sort / Index as Hash: Place each number at index (num-1). After sorting, the first index where nums[i] != i+1 gives the answer. Each number is swapped at most once, so O(n) time, O(1) space.",
        pattern: "Cyclic Sort",
        order: 11,
      },
      {
        title: "Subarray Sum Equals K",
        slug: "subarray-sum-equals-k-hashing",
        difficulty: "Hard",
        description: "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\n\nA subarray is a contiguous non-empty sequence of elements within an array.",
        examples: JSON.stringify([
          { input: "nums = [1,1,1], k = 2", output: "2", explanation: "The subarrays [1,1] starting at index 0 and index 1 both sum to 2." },
          { input: "nums = [1,2,3], k = 3", output: "2", explanation: "[1,2] and [3] both sum to 3." },
        ]),
        hints: JSON.stringify([
          "A subarray sum from index i to j equals prefix_sum[j+1] - prefix_sum[i].",
          "For each prefix sum, you need to count how many previous prefix sums equal current_prefix - k.",
          "Use a hash map to store counts of all prefix sums seen so far.",
        ]),
        solution: "def subarray_sum(nums, k):\n    count = 0\n    prefix_sum = 0\n    prefix_counts = {0: 1}\n    for num in nums:\n        prefix_sum += num\n        if prefix_sum - k in prefix_counts:\n            count += prefix_counts[prefix_sum - k]\n        prefix_counts[prefix_sum] = prefix_counts.get(prefix_sum, 0) + 1\n    return count",
        explanation: "Prefix Sum + Hash Map: Maintain a running prefix sum and a hash map counting how many times each prefix sum has occurred. For each new prefix sum, the number of subarrays ending here with sum k equals the count of (prefix_sum - k) in the map. O(n) time, O(n) space.",
        pattern: "Prefix Sum / Hash Map",
        order: 12,
      },
    ]},
  };
}
