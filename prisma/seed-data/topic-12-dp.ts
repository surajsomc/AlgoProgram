export function getDynamicProgrammingData() {
  return {
    name: "Dynamic Programming",
    slug: "dynamic-programming",
    description: "Break problems into overlapping subproblems. Build solutions bottom-up using previously computed results. The hardest and most common interview category.",
    icon: "ðŸ“Š", order: 12,
    concepts: { create: [
      { title: "1D Dynamic Programming", content: "Each state depends on one or a few previous states along a single dimension.\n\nPattern: define dp[i] = answer for subproblem ending at i. Find the recurrence: dp[i] = f(dp[i-1], dp[i-2], ...).\n\nExamples: climbing stairs, house robber, longest increasing subsequence.", timeComplexity: "O(n) to O(nÂ²)", spaceComplexity: "O(n) or O(1) with optimization", whenToUse: "When current answer depends on previous answers along a sequence, and you see overlapping subproblems.", codeExample: "def climb_stairs(n):\n    if n <= 2: return n\n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    return prev1", flashcardFront: "What is the 1D DP pattern and when should you use it?", flashcardBack: "Define dp[i] as the answer for the subproblem at index i. Find the recurrence relating dp[i] to previous states (dp[i-1], dp[i-2], etc.). Use when the current answer depends on previous answers along a sequence with overlapping subproblems. Often optimizable to O(1) space by tracking only the needed previous values.", order: 1 },
      { title: "2D Dynamic Programming", content: "States depend on two dimensions, typically a grid or two sequences.\n\nPattern: dp[i][j] = answer considering first i elements of one thing and first j of another.\n\nExamples: edit distance, longest common subsequence, unique paths in grid, knapsack.", timeComplexity: "O(m*n)", spaceComplexity: "O(m*n) or O(n) with optimization", whenToUse: "Comparing two strings/sequences, grid pathfinding with constraints, knapsack-style optimization.", codeExample: "def longest_common_subseq(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]", flashcardFront: "What is the 2D DP pattern and how do you identify problems that need it?", flashcardBack: "Define dp[i][j] considering first i elements of one dimension and first j of another. Use for: comparing two strings/sequences, grid pathfinding, knapsack problems. Time O(m*n), space O(m*n) but often optimizable to O(n) by keeping only the previous row.", order: 2 },
      { title: "DP on Subsequences", content: "Many DP problems involve finding optimal subsequences (elements not necessarily contiguous).\n\nLongest Increasing Subsequence (LIS): dp[i] = length of LIS ending at index i. For each j < i where nums[j] < nums[i], dp[i] = max(dp[i], dp[j]+1).\n\nCan be optimized to O(n log n) using patience sorting with binary search.", timeComplexity: "O(nÂ²) naive, O(n log n) optimized", spaceComplexity: "O(n)", whenToUse: "Finding longest increasing/decreasing subsequence, counting subsequences, or partitioning into subsequences.", codeExample: "def length_of_lis(nums):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", flashcardFront: "How do you solve the Longest Increasing Subsequence problem with DP?", flashcardBack: "dp[i] = length of LIS ending at index i. For each j < i, if nums[j] < nums[i], then dp[i] = max(dp[i], dp[j]+1). Answer is max(dp). O(n^2) time. Can optimize to O(n log n) using a tails array with binary search (patience sorting).", order: 3 },
    ]},
    problems: { create: [
      { title: "Climbing Stairs", slug: "climbing-stairs", difficulty: "Easy", description: "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?", examples: JSON.stringify([{input:"n = 2",output:"2",explanation:"1+1 or 2"},{input:"n = 3",output:"3",explanation:"1+1+1, 1+2, or 2+1"}]), hints: JSON.stringify(["To reach step n, you came from step n-1 or step n-2.","ways(n) = ways(n-1) + ways(n-2). Sound familiar?","This is the Fibonacci sequence! Use DP to avoid recomputation."]), solution: "def climb_stairs(n):\n    if n <= 2:\n        return n\n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    return prev1", explanation: "1D DP (Fibonacci-like): dp[i] = dp[i-1] + dp[i-2]. Ways to reach step i = ways from step i-1 + ways from step i-2. Optimize space to O(1) by keeping only two previous values.", pattern: "1D Dynamic Programming", order: 1 },
      { title: "House Robber", slug: "house-robber", difficulty: "Medium", description: "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money. Adjacent houses have connected security systems -- if two adjacent houses are broken into, the alarm triggers.\n\nGiven an array of non-negative integers representing money at each house, return the maximum amount you can rob without triggering alarms.", examples: JSON.stringify([{input:"nums = [1,2,3,1]",output:"4",explanation:"Rob house 1 ($1) and house 3 ($3) = $4"},{input:"nums = [2,7,9,3,1]",output:"12",explanation:"Rob house 1 ($2) + house 3 ($9) + house 5 ($1) = $12"}]), hints: JSON.stringify(["For each house, you either rob it or skip it.","If you rob house i, you can't rob house i-1. Your total is nums[i] + best up to house i-2.","If you skip house i, your total is the best up to house i-1.","dp[i] = max(dp[i-1], dp[i-2] + nums[i])"]), solution: "def rob(nums):\n    if len(nums) <= 2:\n        return max(nums) if nums else 0\n    prev2, prev1 = nums[0], max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        curr = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = curr\n    return prev1", explanation: "1D DP: At each house, choose max of (skip this house = dp[i-1]) or (rob this house = dp[i-2] + nums[i]). Space-optimized to O(1) using two variables.", pattern: "1D Dynamic Programming", order: 2 },
      { title: "Longest Common Subsequence", slug: "longest-common-subsequence", difficulty: "Medium", description: "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence is derived by deleting some (or no) characters without changing the relative order.", examples: JSON.stringify([{input:'text1 = "abcde", text2 = "ace"',output:"3",explanation:'"ace" is the LCS'},{input:'text1 = "abc", text2 = "def"',output:"0"}]), hints: JSON.stringify(["Compare characters from both strings one at a time.","If chars match, the LCS extends by 1 from both strings shortened.","If they don't match, try skipping a char from either string.","This is classic 2D DP: dp[i][j] = LCS of text1[:i] and text2[:j]."]), solution: "def longest_common_subsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]", explanation: "2D DP: dp[i][j] = LCS of first i chars of text1 and first j chars of text2. If chars match, extend from dp[i-1][j-1]+1. Otherwise, max of skipping either char. O(m*n) time and space.", pattern: "2D Dynamic Programming", order: 3 },
      { title: "Coin Change", slug: "coin-change", difficulty: "Medium", description: "Given an integer array coins representing coin denominations and an integer amount, return the fewest number of coins needed to make up that amount. If not possible, return -1.", examples: JSON.stringify([{input:"coins = [1,5,11], amount = 15",output:"3",explanation:"5 + 5 + 5 = 15"},{input:"coins = [2], amount = 3",output:"-1"}]), hints: JSON.stringify(["dp[i] = fewest coins to make amount i.","For each amount, try subtracting each coin and take the minimum.","dp[i] = min(dp[i - coin] + 1) for all valid coins."]), solution: "def coin_change(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1", explanation: "1D DP: For each amount from 1 to target, try each coin. dp[amount] = min(dp[amount - coin] + 1). Bottom-up approach. O(amount * coins) time.", pattern: "1D Dynamic Programming", order: 4 },
      { title: "Min Cost Climbing Stairs", slug: "min-cost-climbing-stairs", difficulty: "Easy", description: "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index 0 or the step with index 1. Return the minimum cost to reach the top of the floor.", examples: JSON.stringify([{input:"cost = [10,15,20]",output:"15",explanation:"Start at index 1, pay 15, climb two steps to the top."},{input:"cost = [1,100,1,1,1,100,1,1,100,1]",output:"6"}]), hints: JSON.stringify(["To reach step i, you came from step i-1 or step i-2.","dp[i] = cost[i] + min(dp[i-1], dp[i-2]).","The answer is min(dp[n-1], dp[n-2]) since you can reach the top from either of the last two steps."]), solution: "def min_cost_climbing_stairs(cost):\n    n = len(cost)\n    prev2, prev1 = cost[0], cost[1]\n    for i in range(2, n):\n        curr = cost[i] + min(prev1, prev2)\n        prev2 = prev1\n        prev1 = curr\n    return min(prev1, prev2)", explanation: "1D DP: dp[i] = cost[i] + min(dp[i-1], dp[i-2]). The minimum cost to reach step i is the cost at step i plus the cheaper of the two previous steps. Answer is min of the last two steps. O(n) time, O(1) space.", pattern: "1D Dynamic Programming", order: 5 },
      { title: "Maximum Subarray", slug: "maximum-subarray", difficulty: "Easy", description: "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n\nA subarray is a contiguous non-empty sequence of elements within an array.", examples: JSON.stringify([{input:"nums = [-2,1,-3,4,-1,2,1,-5,4]",output:"6",explanation:"The subarray [4,-1,2,1] has the largest sum 6."},{input:"nums = [1]",output:"1"},{input:"nums = [5,4,-1,7,8]",output:"23"}]), hints: JSON.stringify(["At each position, decide: extend the current subarray or start a new one.","If the current sum is negative, it's better to start fresh.","dp[i] = max(nums[i], dp[i-1] + nums[i]) -- Kadane's algorithm."]), solution: "def max_sub_array(nums):\n    max_sum = curr_sum = nums[0]\n    for num in nums[1:]:\n        curr_sum = max(num, curr_sum + num)\n        max_sum = max(max_sum, curr_sum)\n    return max_sum", explanation: "Kadane's Algorithm (1D DP): At each element, either extend the current subarray or start a new one. curr_sum = max(num, curr_sum + num). Track the global maximum. O(n) time, O(1) space.", pattern: "1D Dynamic Programming", order: 6 },
      { title: "Unique Paths", slug: "unique-paths", difficulty: "Easy", description: "There is a robot on an m x n grid. The robot is initially located at the top-left corner. The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner.\n\nHow many possible unique paths are there?", examples: JSON.stringify([{input:"m = 3, n = 7",output:"28"},{input:"m = 3, n = 2",output:"3",explanation:"Right+Down+Down, Down+Down+Right, Down+Right+Down"}]), hints: JSON.stringify(["To reach cell (i,j), you must come from (i-1,j) or (i,j-1).","dp[i][j] = dp[i-1][j] + dp[i][j-1].","The first row and first column are all 1 (only one way to reach them)."]), solution: "def unique_paths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i-1][j] + dp[i][j-1]\n    return dp[m-1][n-1]", explanation: "2D DP: dp[i][j] = number of paths to reach cell (i,j) = paths from above + paths from left. Base case: first row and column are all 1. O(m*n) time and space, optimizable to O(n) with single row.", pattern: "2D Dynamic Programming", order: 7 },
      { title: "Longest Increasing Subsequence", slug: "longest-increasing-subsequence", difficulty: "Medium", description: "Given an integer array nums, return the length of the longest strictly increasing subsequence.", examples: JSON.stringify([{input:"nums = [10,9,2,5,3,7,101,18]",output:"4",explanation:"The LIS is [2,3,7,101], length 4."},{input:"nums = [0,1,0,3,2,3]",output:"4"},{input:"nums = [7,7,7,7,7,7,7]",output:"1"}]), hints: JSON.stringify(["dp[i] = length of longest increasing subsequence ending at index i.","For each i, check all j < i: if nums[j] < nums[i], dp[i] = max(dp[i], dp[j] + 1).","The answer is the maximum value in the dp array."]), solution: "def length_of_lis(nums):\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[j] < nums[i]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", explanation: "1D DP: dp[i] = LIS ending at index i. For each pair (j, i) where j < i and nums[j] < nums[i], update dp[i]. O(n^2) time. Can optimize to O(n log n) with binary search on a tails array.", pattern: "1D Dynamic Programming", order: 8 },
      { title: "Word Break", slug: "word-break", difficulty: "Medium", description: "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.", examples: JSON.stringify([{input:'s = "leetcode", wordDict = ["leet","code"]',output:"true",explanation:'"leetcode" can be segmented as "leet code".'},{input:'s = "applepenapple", wordDict = ["apple","pen"]',output:"true"},{input:'s = "catsandog", wordDict = ["cats","dog","sand","and","cat"]',output:"false"}]), hints: JSON.stringify(["dp[i] = true if s[:i] can be segmented using the dictionary.","For each position i, check all possible last words ending at i.","dp[i] = any(dp[j] and s[j:i] in wordDict) for all valid j."]), solution: "def word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]", explanation: "1D DP: dp[i] means s[:i] can be segmented. For each i, try all split points j: if dp[j] is true and s[j:i] is in the dictionary, then dp[i] is true. O(n^2 * k) time where k is average word length for hashing.", pattern: "1D Dynamic Programming", order: 9 },
      { title: "Edit Distance", slug: "edit-distance", difficulty: "Medium", description: "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations: Insert a character, Delete a character, Replace a character.", examples: JSON.stringify([{input:'word1 = "horse", word2 = "ros"',output:"3",explanation:"horse -> rorse (replace h with r) -> rose (remove r) -> ros (remove e)"},{input:'word1 = "intention", word2 = "execution"',output:"5"}]), hints: JSON.stringify(["dp[i][j] = min operations to convert word1[:i] to word2[:j].","If characters match, dp[i][j] = dp[i-1][j-1] (no operation needed).","Otherwise, try insert (dp[i][j-1]+1), delete (dp[i-1][j]+1), or replace (dp[i-1][j-1]+1)."]), solution: "def min_distance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j],\n                                    dp[i][j-1],\n                                    dp[i-1][j-1])\n    return dp[m][n]", explanation: "2D DP: dp[i][j] = edit distance between word1[:i] and word2[:j]. If chars match, no cost. Otherwise, take 1 + min of insert/delete/replace. O(m*n) time and space.", pattern: "2D Dynamic Programming", order: 10 },
      { title: "Longest Palindromic Substring", slug: "longest-palindromic-substring", difficulty: "Hard", description: "Given a string s, return the longest palindromic substring in s.", examples: JSON.stringify([{input:'s = "babad"',output:'"bab"',explanation:'"aba" is also a valid answer.'},{input:'s = "cbbd"',output:'"bb"'}]), hints: JSON.stringify(["A palindrome mirrors around its center.","There are 2n-1 possible centers (each character and each gap between characters).","Expand from each center outward while characters match."]), solution: "def longest_palindrome(s):\n    start = end = 0\n    def expand(l, r):\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            l -= 1\n            r += 1\n        return l + 1, r - 1\n    for i in range(len(s)):\n        # Odd length\n        l1, r1 = expand(i, i)\n        if r1 - l1 > end - start:\n            start, end = l1, r1\n        # Even length\n        l2, r2 = expand(i, i + 1)\n        if r2 - l2 > end - start:\n            start, end = l2, r2\n    return s[start:end+1]", explanation: "Expand Around Center: For each of the 2n-1 centers, expand outward while characters match. Track the longest found. O(n^2) time, O(1) space. Alternative: 2D DP where dp[i][j] = whether s[i..j] is a palindrome.", pattern: "1D Dynamic Programming", order: 11 },
      { title: "Decode Ways", slug: "decode-ways-dp", difficulty: "Hard", description: "A message containing letters from A-Z can be encoded as numbers using the mapping: 'A' -> \"1\", 'B' -> \"2\", ..., 'Z' -> \"26\".\n\nGiven a string s containing only digits, return the number of ways to decode it. The answer is guaranteed to fit in a 32-bit integer.", examples: JSON.stringify([{input:'s = "12"',output:"2",explanation:'"12" could be decoded as "AB" (1 2) or "L" (12).'},{input:'s = "226"',output:"3",explanation:'"226" could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).'},{input:'s = "06"',output:"0",explanation:'"06" cannot be decoded since "06" is not a valid encoding.'}]), hints: JSON.stringify(["dp[i] = number of ways to decode s[:i].","If s[i-1] != '0', we can decode it as a single digit: dp[i] += dp[i-1].","If s[i-2:i] forms a valid two-digit number (10-26): dp[i] += dp[i-2]."]), solution: "def num_decodings(s):\n    if not s or s[0] == '0':\n        return 0\n    n = len(s)\n    prev2, prev1 = 1, 1\n    for i in range(1, n):\n        curr = 0\n        if s[i] != '0':\n            curr += prev1\n        two_digit = int(s[i-1:i+1])\n        if 10 <= two_digit <= 26:\n            curr += prev2\n        prev2 = prev1\n        prev1 = curr\n    return prev1", explanation: "1D DP: dp[i] counts ways to decode s[:i]. Single digit (1-9) contributes dp[i-1] ways. Two digit (10-26) contributes dp[i-2] ways. Handle '0' carefully -- it can only be part of a two-digit code. O(n) time, O(1) space.", pattern: "1D Dynamic Programming", order: 12 },
    ]},
  };
}
