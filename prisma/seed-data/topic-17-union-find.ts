export function getUnionFindData() {
  return {
    name: "Union Find",
    slug: "union-find",
    description: "Disjoint set data structure for grouping elements. Efficiently determine if two elements are in the same group and merge groups.",
    icon: "\uD83E\uDD1D", order: 17,
    concepts: { create: [
      { title: "Union Find / Disjoint Set", content: "Maintains disjoint sets with two operations:\n- Find(x): which set does x belong to? (returns root)\n- Union(x, y): merge the sets containing x and y\n\nOptimizations: path compression (point nodes directly to root) and union by rank (attach smaller tree to larger).\n\nWith both optimizations, operations are nearly O(1) amortized (inverse Ackermann).", timeComplexity: "O(\u03B1(n)) \u2248 O(1) amortized", spaceComplexity: "O(n)", whenToUse: "Connected components, redundant connections, accounts merge, when you need to dynamically group elements.", codeExample: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True", flashcardFront: "What are the two key optimizations for Union Find, and what time complexity do they achieve together?", flashcardBack: "1) Path compression: during Find, point every node directly to the root. 2) Union by rank: attach the shorter tree under the taller tree's root. Together they achieve O(alpha(n)) amortized per operation, where alpha is the inverse Ackermann function -- effectively O(1).", order: 1 },
      { title: "Counting Components with Union Find", content: "Start with n components (each node is its own set). For each edge, union the two endpoints. If they were in different sets, decrement the component count.\n\nFinal count = number of connected components.\n\nAlternative: after processing all edges, count distinct roots.", timeComplexity: "O(n + E * \u03B1(n))", spaceComplexity: "O(n)", whenToUse: "When you need to count connected components, detect if adding an edge creates a cycle, or check if two nodes are connected.", codeExample: "def count_components(n, edges):\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n    roots = set(uf.find(i) for i in range(n))\n    return len(roots)", flashcardFront: "How do you count connected components using Union Find?", flashcardBack: "Initialize n components (one per node). For each edge (u, v), call union(u, v). If they were in different sets, decrement the count. Alternatively, after all unions, count the number of distinct roots by calling find() on each node.", order: 2 },
      { title: "Cycle Detection with Union Find", content: "In an undirected graph, an edge creates a cycle if both endpoints are already in the same connected component.\n\nProcess edges one by one. Before union, check if find(u) == find(v). If yes, this edge creates a cycle.\n\nThis is how you find redundant connections in a graph that should be a tree.", timeComplexity: "O(E * \u03B1(n))", spaceComplexity: "O(n)", whenToUse: "Detecting cycles in undirected graphs, finding redundant edges, determining if a graph is a valid tree.", codeExample: "def has_cycle(n, edges):\n    uf = UnionFind(n)\n    for u, v in edges:\n        if uf.find(u) == uf.find(v):\n            return True  # cycle detected\n        uf.union(u, v)\n    return False", flashcardFront: "How does Union Find detect cycles in an undirected graph?", flashcardBack: "Process edges one by one. For each edge (u, v), call find(u) and find(v). If they have the same root, adding this edge would create a cycle because u and v are already connected. Otherwise, union them.", order: 3 },
    ]},
    problems: { create: [
      { title: "Number of Connected Components", slug: "connected-components", difficulty: "Medium", description: "You have n nodes labeled from 0 to n - 1 and a list of undirected edges. Write a function to find the number of connected components in the graph.", examples: JSON.stringify([{input:"n = 5, edges = [[0,1],[1,2],[3,4]]",output:"2",explanation:"Components: {0,1,2} and {3,4}"},{input:"n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",output:"1"}]), hints: JSON.stringify(["Start with n separate components.","Each edge merges two components.","Union Find: union the endpoints of each edge, count remaining distinct roots."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.components = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        self.components -= 1\n\ndef count_components(n, edges):\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n    return uf.components", explanation: "Union Find: Start with n components. For each edge, union the two nodes. If they were in different components, decrement count. Final count = connected components. O(n + E * \u03B1(n)).", pattern: "Union Find", order: 1 },
      { title: "Redundant Connection", slug: "redundant-connection", difficulty: "Medium", description: "A tree is a connected graph with n nodes and n-1 edges. You are given a graph that started as a tree with one additional edge added. Return the edge that can be removed so the result is a tree.\n\nIf there are multiple answers, return the edge that occurs last in the input.", examples: JSON.stringify([{input:"edges = [[1,2],[1,3],[2,3]]",output:"[2,3]",explanation:"Removing [2,3] makes it a valid tree."},{input:"edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",output:"[1,4]"}]), hints: JSON.stringify(["Process edges one by one. The first edge that creates a cycle is redundant.","How do you check if adding an edge creates a cycle?","Union Find: if both endpoints are already in the same component, this edge creates a cycle."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n + 1))\n        self.rank = [0] * (n + 1)\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        return True\n\ndef find_redundant(edges):\n    uf = UnionFind(len(edges))\n    for a, b in edges:\n        if not uf.union(a, b):\n            return [a, b]", explanation: "Union Find: Process each edge. If both endpoints already share the same root, this edge creates a cycle -- it's the redundant one. O(n * \u03B1(n)) time.", pattern: "Union Find", order: 2 },
      { title: "Find if Path Exists in Graph", slug: "find-path-exists-in-graph", difficulty: "Easy", description: "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented as a 2D integer array edges where each edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi.\n\nDetermine if there is a valid path that exists from vertex source to vertex destination.", examples: JSON.stringify([{input:"n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2",output:"true",explanation:"There are two paths from 0 to 2: 0->1->2 and 0->2."},{input:"n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5",output:"false",explanation:"There is no path from 0 to 5."}]), hints: JSON.stringify(["Two nodes are reachable if and only if they're in the same connected component.","Use Union Find to group nodes into components.","After processing all edges, check if find(source) == find(destination)."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n\ndef valid_path(n, edges, source, destination):\n    uf = UnionFind(n)\n    for u, v in edges:\n        uf.union(u, v)\n    return uf.find(source) == uf.find(destination)", explanation: "Union Find: Union all edges, then check if source and destination have the same root. If yes, they're connected. O(n + E * \u03B1(n)) time, O(n) space.", pattern: "Union Find", order: 3 },
      { title: "Number of Provinces", slug: "number-of-provinces", difficulty: "Easy", description: "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n\nA province is a group of directly or indirectly connected cities. You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n\nReturn the total number of provinces.", examples: JSON.stringify([{input:"isConnected = [[1,1,0],[1,1,0],[0,0,1]]",output:"2",explanation:"Cities 0 and 1 form one province, city 2 is another."},{input:"isConnected = [[1,0,0],[0,1,0],[0,0,1]]",output:"3"}]), hints: JSON.stringify(["This is a connected components problem on an adjacency matrix.","For each pair (i,j) where isConnected[i][j] == 1, union i and j.","Count distinct components after processing all connections."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.count = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        self.count -= 1\n\ndef find_circle_num(isConnected):\n    n = len(isConnected)\n    uf = UnionFind(n)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if isConnected[i][j] == 1:\n                uf.union(i, j)\n    return uf.count", explanation: "Union Find on adjacency matrix: Iterate through the upper triangle of the matrix. For each connection, union the two cities. Track component count. O(n\u00B2 * \u03B1(n)) time, O(n) space.", pattern: "Union Find", order: 4 },
      { title: "Graph Valid Tree", slug: "graph-valid-tree", difficulty: "Medium", description: "You have n nodes labeled from 0 to n - 1 and a list of undirected edges. Write a function to check whether these edges make up a valid tree.\n\nA valid tree has n-1 edges, is connected, and has no cycles.", examples: JSON.stringify([{input:"n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",output:"true"},{input:"n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]",output:"false",explanation:"There is a cycle: 1->2->3->1."}]), hints: JSON.stringify(["A tree with n nodes has exactly n-1 edges.","Even with n-1 edges, you need to verify there are no cycles.","Use Union Find: process each edge. If both nodes share the same root, there's a cycle."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        return True\n\ndef valid_tree(n, edges):\n    if len(edges) != n - 1:\n        return False\n    uf = UnionFind(n)\n    for a, b in edges:\n        if not uf.union(a, b):\n            return False\n    return True", explanation: "Union Find: A valid tree has exactly n-1 edges and no cycles. First check edge count. Then process each edge with union -- if union returns False (same component), there's a cycle. O(n * \u03B1(n)) time.", pattern: "Union Find", order: 5 },
      { title: "Longest Consecutive Sequence", slug: "longest-consecutive-sequence-uf", difficulty: "Medium", description: "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.", examples: JSON.stringify([{input:"nums = [100,4,200,1,3,2]",output:"4",explanation:"The longest consecutive sequence is [1, 2, 3, 4]."},{input:"nums = [0,3,7,2,5,8,4,6,0,1]",output:"9"}]), hints: JSON.stringify(["Union consecutive numbers together.","For each number n, if n+1 exists in the set, union them.","Track the size of each component to find the largest."]), solution: "class UnionFind:\n    def __init__(self):\n        self.parent = {}\n        self.size = {}\n    def add(self, x):\n        if x not in self.parent:\n            self.parent[x] = x\n            self.size[x] = 1\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        if x not in self.parent or y not in self.parent:\n            return\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.size[px] < self.size[py]:\n            px, py = py, px\n        self.parent[py] = px\n        self.size[px] += self.size[py]\n\ndef longest_consecutive(nums):\n    uf = UnionFind()\n    for num in nums:\n        uf.add(num)\n    for num in nums:\n        uf.union(num, num + 1)\n    if not uf.size:\n        return 0\n    return max(uf.size[uf.find(x)] for x in uf.parent)", explanation: "Union Find with size tracking: Add all numbers. For each number, union it with num+1 if it exists. Track component sizes via union by size. The answer is the maximum component size. O(n) time.", pattern: "Union Find", order: 6 },
      { title: "Accounts Merge", slug: "accounts-merge", difficulty: "Hard", description: "Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\n\nMerge accounts that share a common email. Two accounts belong to the same person if they share at least one common email. Return the merged accounts with emails sorted.", examples: JSON.stringify([{input:'accounts = [["John","johnsmith@mail.com","john_newyork@mail.com"],["John","johnsmith@mail.com","john00@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]',output:'[["John","john00@mail.com","john_newyork@mail.com","johnsmith@mail.com"],["Mary","mary@mail.com"],["John","johnnybravo@mail.com"]]'},{input:'accounts = [["Alex","alex1@mail.com","alex2@mail.com"],["Alex","alex2@mail.com","alex3@mail.com"]]',output:'[["Alex","alex1@mail.com","alex2@mail.com","alex3@mail.com"]]'}]), hints: JSON.stringify(["Each email belongs to exactly one person. Two accounts with a shared email belong to the same person.","Map each email to an account index. If an email appears in multiple accounts, union those accounts.","After all unions, group emails by their root account index, sort, and prepend the name."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n\ndef accounts_merge(accounts):\n    from collections import defaultdict\n    uf = UnionFind(len(accounts))\n    email_to_id = {}\n    \n    for i, account in enumerate(accounts):\n        for email in account[1:]:\n            if email in email_to_id:\n                uf.union(i, email_to_id[email])\n            email_to_id[email] = i\n    \n    groups = defaultdict(set)\n    for email, idx in email_to_id.items():\n        groups[uf.find(idx)].add(email)\n    \n    return [[accounts[idx][0]] + sorted(emails)\n            for idx, emails in groups.items()]", explanation: "Union Find on account indices: Map each email to an account index. If an email is seen in multiple accounts, union those accounts. After processing, group all emails by their root index and sort. O(n * k * \u03B1(n)) time where k = avg emails per account.", pattern: "Union Find", order: 7 },
      { title: "Smallest String With Swaps", slug: "smallest-string-with-swaps", difficulty: "Hard", description: "You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices of the string. You can swap the characters at any pair of indices any number of times.\n\nReturn the lexicographically smallest string that s can be changed to after using the swaps.", examples: JSON.stringify([{input:'s = "dcab", pairs = [[0,3],[1,2]]',output:'"bacd"',explanation:"Swap s[0] and s[3] -> 'bcad', then swap s[1] and s[2] -> 'bacd'."},{input:'s = "dcab", pairs = [[0,3],[1,2],[0,2]]',output:'"abcd"',explanation:"All indices are connected, so we can sort the entire string."}]), hints: JSON.stringify(["If index a can swap with b, and b can swap with c, then a, b, c can all be rearranged freely.","Use Union Find to group indices that are transitively connected through swaps.","Within each connected component, sort the characters and assign them to the sorted positions."]), solution: "from collections import defaultdict\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n\ndef smallest_string_with_swaps(s, pairs):\n    n = len(s)\n    uf = UnionFind(n)\n    for a, b in pairs:\n        uf.union(a, b)\n    \n    groups = defaultdict(list)\n    for i in range(n):\n        groups[uf.find(i)].append(i)\n    \n    result = list(s)\n    for indices in groups.values():\n        chars = sorted(result[i] for i in indices)\n        for i, idx in enumerate(sorted(indices)):\n            result[idx] = chars[i]\n    return ''.join(result)", explanation: "Union Find + sort within components: Group indices connected by swap pairs. Within each group, indices can be freely rearranged. Sort the characters and positions within each group independently to get the lexicographically smallest result. O(n log n) time.", pattern: "Union Find", order: 8 },
    ]},
  };
}
