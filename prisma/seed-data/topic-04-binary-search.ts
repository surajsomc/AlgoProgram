export function getBinarySearchData() {
  return {
    name: "Binary Search",
    slug: "binary-search",
    description: "Divide the search space in half each step. Works on sorted arrays and monotonic functions. O(log n) time.",
    icon: "\uD83D\uDD0D", order: 4,
    concepts: { create: [
      {
        title: "Classic Binary Search",
        content: "Search for a target in a sorted array by repeatedly halving the search space.\n\nMaintain left and right pointers. Compute mid. If target < mid, search left half. If target > mid, search right half.",
        timeComplexity: "O(log n)",
        spaceComplexity: "O(1)",
        whenToUse: "Sorted array + find target, or any situation where you can eliminate half the search space.",
        codeExample: "def binary_search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target: return mid\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return -1",
        flashcardFront: "What are the two common binary search boundary conditions, and when do you use each?",
        flashcardBack: "1) 'while l <= r' with 'l = mid+1, r = mid-1': Use when searching for an exact target. Loop ends when l > r (search space empty). 2) 'while l < r' with 'r = mid' or 'l = mid+1': Use when searching for a boundary (first/last position satisfying a condition). Loop ends when l == r (one candidate left). The choice depends on whether you want the exact element or a boundary.",
        order: 1,
      },
      {
        title: "Binary Search on Answer",
        content: "Instead of searching in an array, search on the answer space. If you can check whether an answer is feasible in O(n), and the feasibility is monotonic, binary search on the answer.\n\nPattern: define a range [lo, hi] for possible answers. Binary search for the minimum/maximum feasible answer.",
        timeComplexity: "O(n log(range))",
        spaceComplexity: "O(1)",
        whenToUse: "Minimize the maximum or maximize the minimum of something. 'What is the smallest X such that...'",
        codeExample: "def min_eating_speed(piles, h):\n    lo, hi = 1, max(piles)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        hours = sum((p + mid - 1) // mid for p in piles)\n        if hours <= h: hi = mid\n        else: lo = mid + 1\n    return lo",
        flashcardFront: "When should you use 'binary search on the answer' instead of classic binary search?",
        flashcardBack: "Use binary search on the answer when: 1) You need to find the minimum/maximum value that satisfies a condition, 2) The feasibility function is monotonic (if X works, then X+1 also works, or vice versa), 3) You can verify a candidate answer in O(n) or similar. Examples: minimum eating speed, split array largest sum, capacity to ship packages. The search space is the range of possible answers, not an array.",
        order: 2,
      },
    ]},
    problems: { create: [
      // ===== EXISTING 3 PROBLEMS =====
      {
        title: "Binary Search",
        slug: "binary-search-basic",
        difficulty: "Easy",
        description: "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, return its index. Otherwise, return -1.",
        examples: JSON.stringify([
          { input: "nums = [-1,0,3,5,9,12], target = 9", output: "4" },
          { input: "nums = [-1,0,3,5,9,12], target = 2", output: "-1" },
        ]),
        hints: JSON.stringify([
          "The array is sorted -- you can eliminate half the elements each step.",
          "Compare the middle element with the target.",
          "Adjust left or right boundary based on comparison.",
        ]),
        solution: "def search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1",
        explanation: "Classic binary search: Compare target with middle element, narrow search space by half each iteration. O(log n) time, O(1) space.",
        pattern: "Binary Search",
        order: 1,
      },
      {
        title: "Search in Rotated Sorted Array",
        slug: "search-rotated-array",
        difficulty: "Medium",
        description: "Given a rotated sorted array nums and a target, return the index of target or -1. The array was originally sorted in ascending order and then rotated at some pivot.\n\nYou must write an algorithm with O(log n) runtime.",
        examples: JSON.stringify([
          { input: "nums = [4,5,6,7,0,1,2], target = 0", output: "4" },
          { input: "nums = [4,5,6,7,0,1,2], target = 3", output: "-1" },
        ]),
        hints: JSON.stringify([
          "One half of the array is always sorted.",
          "Check which half is sorted by comparing nums[left] with nums[mid].",
          "Determine if the target lies in the sorted half or the other half.",
        ]),
        solution: "def search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[l] <= nums[mid]:  # left half sorted\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        else:  # right half sorted\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return -1",
        explanation: "Modified Binary Search: In a rotated sorted array, one half is always sorted. Determine which half is sorted, check if target is in that half, and narrow accordingly. O(log n).",
        pattern: "Binary Search",
        order: 2,
      },
      {
        title: "Koko Eating Bananas",
        slug: "koko-eating-bananas",
        difficulty: "Medium",
        description: "Koko loves bananas. There are n piles of bananas. She can eat at speed k bananas per hour (one pile at a time). She has h hours. Return the minimum integer k such that she can eat all bananas within h hours.",
        examples: JSON.stringify([
          { input: "piles = [3,6,7,11], h = 8", output: "4" },
          { input: "piles = [30,11,23,4,20], h = 5", output: "30" },
        ]),
        hints: JSON.stringify([
          "The answer k is between 1 and max(piles).",
          "For a given k, can you calculate total hours needed?",
          "Binary search on the answer: find the minimum k where total hours <= h.",
        ]),
        solution: "import math\ndef min_eating_speed(piles, h):\n    lo, hi = 1, max(piles)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        hours = sum(math.ceil(p / mid) for p in piles)\n        if hours <= h:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo",
        explanation: "Binary Search on Answer: Search the range [1, max(piles)] for the minimum speed k. For each candidate k, check if Koko can finish in h hours. Feasibility is monotonic -- higher k always works if lower k works. O(n log m) time.",
        pattern: "Binary Search on Answer",
        order: 3,
      },

      // ===== NEW PROBLEMS =====
      {
        title: "Search Insert Position",
        slug: "search-insert-position",
        difficulty: "Easy",
        description: "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.",
        examples: JSON.stringify([
          { input: "nums = [1,3,5,6], target = 5", output: "2" },
          { input: "nums = [1,3,5,6], target = 2", output: "1" },
          { input: "nums = [1,3,5,6], target = 7", output: "4" },
        ]),
        hints: JSON.stringify([
          "This is a standard binary search with a small twist.",
          "When the element is not found, the left pointer will be at the correct insertion position.",
          "Think about what happens when l > r: l points to the first element greater than target.",
        ]),
        solution: "def search_insert(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return l",
        explanation: "Binary Search: Standard binary search. When target is not found, the left pointer ends up at the position where target should be inserted to maintain sorted order. O(log n) time, O(1) space.",
        pattern: "Binary Search",
        order: 4,
      },
      {
        title: "Guess Number Higher or Lower",
        slug: "guess-number-higher-lower",
        difficulty: "Easy",
        description: "We are playing the Guess Game. I pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API int guess(int num), which returns -1 if num is higher than the picked number, 1 if num is lower, and 0 if equal.\n\nReturn the number that I picked.",
        examples: JSON.stringify([
          { input: "n = 10, pick = 6", output: "6" },
          { input: "n = 1, pick = 1", output: "1" },
        ]),
        hints: JSON.stringify([
          "The numbers 1 to n form a sorted range.",
          "Use binary search on this range.",
          "Use the guess API to decide which half to search.",
        ]),
        solution: "def guessNumber(n):\n    l, r = 1, n\n    while l <= r:\n        mid = (l + r) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result == -1:\n            r = mid - 1\n        else:\n            l = mid + 1\n    return -1",
        explanation: "Classic Binary Search: Search the range [1, n]. Use the guess API as the comparison function. Narrow the range by half each iteration. O(log n) time, O(1) space.",
        pattern: "Binary Search",
        order: 5,
      },
      {
        title: "Find Minimum in Rotated Sorted Array",
        slug: "find-min-rotated-sorted-array",
        difficulty: "Medium",
        description: "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. Given the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.",
        examples: JSON.stringify([
          { input: "nums = [3,4,5,1,2]", output: "1", explanation: "The original array was [1,2,3,4,5] rotated 3 times." },
          { input: "nums = [4,5,6,7,0,1,2]", output: "0" },
          { input: "nums = [11,13,15,17]", output: "11" },
        ]),
        hints: JSON.stringify([
          "The minimum element is the only element where the previous element is greater than it.",
          "Compare the middle element with the rightmost element.",
          "If mid > right, the minimum is in the right half. Otherwise, it is in the left half (including mid).",
        ]),
        solution: "def find_min(nums):\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] > nums[r]:\n            l = mid + 1\n        else:\n            r = mid\n    return nums[l]",
        explanation: "Binary Search: Compare mid with right boundary. If nums[mid] > nums[r], the rotation point (minimum) is in the right half. Otherwise, it is in the left half including mid. O(log n) time, O(1) space.",
        pattern: "Binary Search",
        order: 6,
      },
      {
        title: "Search a 2D Matrix",
        slug: "search-2d-matrix",
        difficulty: "Medium",
        description: "You are given an m x n integer matrix with the following properties:\n\n- Each row is sorted in non-decreasing order.\n- The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer target, return true if target is in matrix or false otherwise. You must write a solution in O(log(m * n)) time.",
        examples: JSON.stringify([
          { input: "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3", output: "true" },
          { input: "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13", output: "false" },
        ]),
        hints: JSON.stringify([
          "The entire matrix, read row by row, forms a sorted array.",
          "Treat it as a single sorted array and apply binary search.",
          "Convert a 1D index to 2D: row = index // cols, col = index % cols.",
        ]),
        solution: "def search_matrix(matrix, target):\n    if not matrix:\n        return False\n    m, n = len(matrix), len(matrix[0])\n    l, r = 0, m * n - 1\n    while l <= r:\n        mid = (l + r) // 2\n        val = matrix[mid // n][mid % n]\n        if val == target:\n            return True\n        elif val < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return False",
        explanation: "Binary Search on flattened matrix: Treat the 2D matrix as a 1D sorted array. Use mid // cols for row and mid % cols for column. Standard binary search. O(log(m*n)) time, O(1) space.",
        pattern: "Binary Search",
        order: 7,
      },
      {
        title: "Find Peak Element",
        slug: "find-peak-element",
        difficulty: "Medium",
        description: "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = negative infinity. You must write an algorithm that runs in O(log n) time.",
        examples: JSON.stringify([
          { input: "nums = [1,2,3,1]", output: "2", explanation: "3 is a peak element and index 2 is returned." },
          { input: "nums = [1,2,1,3,5,6,4]", output: "5", explanation: "Either index 1 or 5 can be returned." },
        ]),
        hints: JSON.stringify([
          "If nums[mid] < nums[mid+1], there must be a peak to the right.",
          "If nums[mid] < nums[mid-1], there must be a peak to the left.",
          "Use binary search to climb toward a peak.",
        ]),
        solution: "def find_peak_element(nums):\n    l, r = 0, len(nums) - 1\n    while l < r:\n        mid = (l + r) // 2\n        if nums[mid] < nums[mid + 1]:\n            l = mid + 1\n        else:\n            r = mid\n    return l",
        explanation: "Binary Search: If nums[mid] < nums[mid+1], a peak must exist in the right half (values are increasing). Otherwise, a peak is in the left half including mid. Always converge toward a peak. O(log n) time, O(1) space.",
        pattern: "Binary Search",
        order: 8,
      },
      {
        title: "Median of Two Sorted Arrays",
        slug: "median-two-sorted-arrays",
        difficulty: "Hard",
        description: "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
        examples: JSON.stringify([
          { input: "nums1 = [1,3], nums2 = [2]", output: "2.0", explanation: "Merged array = [1,2,3] and median is 2." },
          { input: "nums1 = [1,2], nums2 = [3,4]", output: "2.5", explanation: "Merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5." },
        ]),
        hints: JSON.stringify([
          "The median divides the combined array into two equal halves.",
          "Binary search on the partition position in the smaller array.",
          "For a valid partition, the max of the left side must be <= the min of the right side.",
        ]),
        solution: "def find_median_sorted_arrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    l, r = 0, m\n    while l <= r:\n        i = (l + r) // 2\n        j = (m + n + 1) // 2 - i\n        left1 = nums1[i-1] if i > 0 else float('-inf')\n        right1 = nums1[i] if i < m else float('inf')\n        left2 = nums2[j-1] if j > 0 else float('-inf')\n        right2 = nums2[j] if j < n else float('inf')\n        if left1 <= right2 and left2 <= right1:\n            if (m + n) % 2 == 0:\n                return (max(left1, left2) + min(right1, right2)) / 2\n            return max(left1, left2)\n        elif left1 > right2:\n            r = i - 1\n        else:\n            l = i + 1",
        explanation: "Binary Search on partition: Binary search the cut position in the smaller array. The other array's cut is determined by the total half size. Validate that all left elements <= all right elements. O(log(min(m,n))) time, O(1) space.",
        pattern: "Binary Search",
        order: 9,
      },
      {
        title: "Split Array Largest Sum",
        slug: "split-array-largest-sum",
        difficulty: "Hard",
        description: "Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n\nReturn the minimized largest sum of the split.",
        examples: JSON.stringify([
          { input: "nums = [7,2,5,10,8], k = 2", output: "18", explanation: "Split into [7,2,5] and [10,8]. The largest sum is 18." },
          { input: "nums = [1,2,3,4,5], k = 2", output: "9", explanation: "Split into [1,2,3] and [4,5]. The largest sum is 9." },
        ]),
        hints: JSON.stringify([
          "The answer is between max(nums) and sum(nums).",
          "For a given maximum sum, can you check if the array can be split into k or fewer subarrays?",
          "Binary search on the answer: find the minimum maximum sum that allows k or fewer splits.",
        ]),
        solution: "def split_array(nums, k):\n    def can_split(max_sum):\n        count = 1\n        current = 0\n        for num in nums:\n            if current + num > max_sum:\n                count += 1\n                current = num\n            else:\n                current += num\n        return count <= k\n    \n    lo, hi = max(nums), sum(nums)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if can_split(mid):\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo",
        explanation: "Binary Search on Answer: The answer lies in [max(nums), sum(nums)]. For each candidate max_sum, greedily check if we can split into k or fewer subarrays. If yes, try smaller; if no, try larger. O(n log(sum)) time.",
        pattern: "Binary Search on Answer",
        order: 10,
      },
    ]},
  };
}
