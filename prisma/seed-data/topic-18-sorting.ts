export function getSortingData() {
  return {
    name: "Sorting & Searching",
    slug: "sorting-and-searching",
    description: "Sorting algorithms and their applications. Know merge sort, quick sort, counting sort, and when to use each.",
    icon: "\uD83D\uDCCB", order: 18,
    concepts: { create: [
      { title: "Comparison-Based Sorting", content: "Key algorithms:\n- Merge Sort: O(n log n), stable, divide-and-conquer. Split, sort halves, merge.\n- Quick Sort: O(n log n) avg, O(n\u00B2) worst, in-place. Pick pivot, partition, recurse.\n- Heap Sort: O(n log n), in-place but not stable.\n\nLower bound: comparison-based sorting cannot beat O(n log n).", timeComplexity: "O(n log n)", spaceComplexity: "O(n) merge sort, O(log n) quick sort", whenToUse: "General-purpose sorting, when stability matters (merge sort), when in-place is required (quick sort).", codeExample: "def merge_sort(arr):\n    if len(arr) <= 1: return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(l, r):\n    result = []\n    i = j = 0\n    while i < len(l) and j < len(r):\n        if l[i] <= r[j]:\n            result.append(l[i]); i += 1\n        else:\n            result.append(r[j]); j += 1\n    return result + l[i:] + r[j:]", flashcardFront: "What is the lower bound for comparison-based sorting, and which algorithms achieve it?", flashcardBack: "The lower bound is O(n log n). Merge sort, heap sort, and quick sort (average case) all achieve this. Merge sort is stable and guarantees O(n log n) worst case. Quick sort is in-place but O(n^2) worst case.", order: 1 },
      { title: "Non-Comparison Sorting", content: "When the range of values is bounded, you can sort faster than O(n log n):\n- Counting Sort: O(n + k) where k = range. Count occurrences, compute prefix sums for positions.\n- Bucket Sort: O(n + k) average. Distribute into buckets, sort each bucket.\n- Radix Sort: O(d * (n + k)) where d = digits. Sort digit by digit using counting sort.\n\nThese break the O(n log n) barrier by not comparing elements directly.", timeComplexity: "O(n + k) or O(d * (n + k))", spaceComplexity: "O(n + k)", whenToUse: "When values are in a bounded range (e.g., ages 0-150, single digits), or when you need linear-time sorting.", codeExample: "def counting_sort(arr, max_val):\n    count = [0] * (max_val + 1)\n    for x in arr:\n        count[x] += 1\n    result = []\n    for val in range(max_val + 1):\n        result.extend([val] * count[val])\n    return result", flashcardFront: "When can you sort in O(n) time, and what algorithms achieve this?", flashcardBack: "When the range of values (k) is bounded/small. Counting sort: O(n + k), counts occurrences. Bucket sort: O(n + k) avg, distributes into buckets. Radix sort: O(d*(n+k)), sorts digit by digit. These avoid comparisons entirely.", order: 2 },
      { title: "Custom Comparators and Partitioning", content: "Many problems require custom sorting logic:\n- Custom comparator: define ordering rules (e.g., largest number from digits)\n- Dutch National Flag: 3-way partition with three pointers\n- Quick Select: find kth smallest in O(n) average using partition\n\nKey insight: sorting is often a preprocessing step or the core of a greedy approach.", timeComplexity: "O(n log n) for sort, O(n) for partition", spaceComplexity: "O(1) for in-place partition", whenToUse: "When the natural ordering doesn't solve the problem -- define a custom comparator. Partitioning for k-way splits.", codeExample: "from functools import cmp_to_key\n\ndef custom_sort(items):\n    return sorted(items, key=cmp_to_key(\n        lambda a, b: -1 if a+b > b+a else 1\n    ))", flashcardFront: "What is the Dutch National Flag algorithm and when do you use it?", flashcardBack: "A 3-way partitioning algorithm using three pointers (low, mid, high). It partitions an array into three sections around a pivot value in a single pass. Use it when there are only 3 distinct values (like Sort Colors) or for 3-way quicksort partitioning. O(n) time, O(1) space.", order: 3 },
    ]},
    problems: { create: [
      { title: "Sort Colors", slug: "sort-colors", difficulty: "Medium", description: "Given an array nums with n objects colored red (0), white (1), or blue (2), sort them in-place so that objects of the same color are adjacent, in the order red, white, and blue.\n\nCan you solve it without using the library's sort function?", examples: JSON.stringify([{input:"nums = [2,0,2,1,1,0]",output:"[0,0,1,1,2,2]"},{input:"nums = [2,0,1]",output:"[0,1,2]"}]), hints: JSON.stringify(["Only 3 distinct values -- can you do better than O(n log n)?","Dutch National Flag problem: use 3 pointers.","low pointer for 0s, mid for scanning, high for 2s."]), solution: "def sort_colors(nums):\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1", explanation: "Dutch National Flag (3-way partition): Three pointers -- low (boundary of 0s), mid (current), high (boundary of 2s). Swap 0s to front, 2s to back. O(n) time, O(1) space, single pass.", pattern: "Partitioning", order: 1 },
      { title: "Largest Number", slug: "largest-number", difficulty: "Medium", description: "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it as a string.", examples: JSON.stringify([{input:"nums = [10,2]",output:'"210"'},{input:"nums = [3,30,34,5,9]",output:'"9534330"'}]), hints: JSON.stringify(["This is a custom sorting problem.","Compare two numbers a and b: which order gives a bigger result, ab or ba?","Sort using the comparator: a+b vs b+a (as strings)."]), solution: "from functools import cmp_to_key\ndef largest_number(nums):\n    strs = [str(n) for n in nums]\n    strs.sort(key=cmp_to_key(lambda a, b: -1 if a+b > b+a else 1))\n    result = ''.join(strs)\n    return '0' if result[0] == '0' else result", explanation: "Custom sort: Compare two numbers by which concatenation order produces a larger number. If '9'+'34' > '34'+'9', then 9 should come before 34. O(n log n * k) where k = avg digit length.", pattern: "Custom Sort", order: 2 },
      { title: "Valid Anagram", slug: "valid-anagram-sorting", difficulty: "Easy", description: "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn anagram is a word formed by rearranging the letters of a different word, using all the original letters exactly once.", examples: JSON.stringify([{input:'s = "anagram", t = "nagaram"',output:"true"},{input:'s = "rat", t = "car"',output:"false"}]), hints: JSON.stringify(["Two strings are anagrams if they have the same characters in the same frequencies.","One approach: sort both strings and compare.","Another approach: count character frequencies and compare."]), solution: "def is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n    for c in t:\n        count[ord(c) - ord('a')] -= 1\n    return all(c == 0 for c in count)", explanation: "Frequency counting: Count character frequencies for s (increment) and t (decrement) in a fixed-size array. If all counts are zero, they're anagrams. O(n) time, O(1) space (fixed 26 chars). Sorting approach is O(n log n).", pattern: "Counting Sort", order: 3 },
      { title: "Merge Intervals", slug: "merge-intervals-sorting", difficulty: "Easy", description: "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.", examples: JSON.stringify([{input:"intervals = [[1,3],[2,6],[8,10],[15,18]]",output:"[[1,6],[8,10],[15,18]]",explanation:"[1,3] and [2,6] overlap, merged into [1,6]."},{input:"intervals = [[1,4],[4,5]]",output:"[[1,5]]"}]), hints: JSON.stringify(["Sort the intervals by their start time.","After sorting, overlapping intervals are adjacent.","If the current interval overlaps with the last merged one, extend it. Otherwise, add a new interval."]), solution: "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", explanation: "Sort + linear scan: Sort by start time. Iterate through, merging overlapping intervals by extending the end time of the last merged interval. O(n log n) time for sorting, O(n) space for output.", pattern: "Sorting", order: 4 },
      { title: "Squares of a Sorted Array", slug: "squares-of-sorted-array", difficulty: "Easy", description: "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n\nCan you solve it in O(n) time?", examples: JSON.stringify([{input:"nums = [-4,-1,0,3,10]",output:"[0,1,9,16,100]"},{input:"nums = [-7,-3,2,3,11]",output:"[4,9,9,49,121]"}]), hints: JSON.stringify(["Squaring can make negative numbers larger than positive ones.","The largest square will be at either the left end (most negative) or right end (most positive).","Use two pointers from both ends, building the result array from largest to smallest."]), solution: "def sorted_squares(nums):\n    n = len(nums)\n    result = [0] * n\n    l, r = 0, n - 1\n    pos = n - 1\n    while l <= r:\n        if abs(nums[l]) > abs(nums[r]):\n            result[pos] = nums[l] ** 2\n            l += 1\n        else:\n            result[pos] = nums[r] ** 2\n            r -= 1\n        pos -= 1\n    return result", explanation: "Two pointers from both ends: The largest squared value must come from either the most negative or most positive number. Compare absolute values at both ends, place the larger square at the end of result, and move that pointer inward. O(n) time, O(n) space.", pattern: "Two Pointers / Sorting", order: 5 },
      { title: "Meeting Rooms II", slug: "meeting-rooms-ii-sorting", difficulty: "Medium", description: "Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.\n\nTwo meetings overlap if one starts before the other ends.", examples: JSON.stringify([{input:"intervals = [[0,30],[5,10],[15,20]]",output:"2",explanation:"Meeting [0,30] overlaps with both others, but [5,10] and [15,20] don't overlap. Need 2 rooms."},{input:"intervals = [[7,10],[2,4]]",output:"1"}]), hints: JSON.stringify(["Think of each meeting as a start event (+1 room) and end event (-1 room).","Sort all events by time. Process them in order.","The maximum number of concurrent meetings is the answer."]), solution: "def min_meeting_rooms(intervals):\n    events = []\n    for start, end in intervals:\n        events.append((start, 1))   # meeting starts\n        events.append((end, -1))    # meeting ends\n    events.sort()\n    \n    max_rooms = curr_rooms = 0\n    for time, delta in events:\n        curr_rooms += delta\n        max_rooms = max(max_rooms, curr_rooms)\n    return max_rooms", explanation: "Event sorting (sweep line): Create +1 events for starts and -1 for ends. Sort by time (ties broken by end before start). Sweep through, tracking concurrent meetings. The peak is the answer. O(n log n) time.", pattern: "Sorting / Sweep Line", order: 6 },
      { title: "Kth Largest Element in an Array", slug: "kth-largest-quickselect", difficulty: "Hard", description: "Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in sorted order, not the kth distinct element.\n\nCan you solve it without sorting the entire array?", examples: JSON.stringify([{input:"nums = [3,2,1,5,6,4], k = 2",output:"5"},{input:"nums = [3,2,3,1,2,4,5,5,6], k = 4",output:"4"}]), hints: JSON.stringify(["Sorting gives O(n log n). Can you do better?","Quick Select: partition the array around a pivot. If the pivot lands at the right position, you're done.","Quick Select has O(n) average time complexity."]), solution: "import random\n\ndef find_kth_largest(nums, k):\n    target = len(nums) - k\n    \n    def quick_select(l, r):\n        pivot_idx = random.randint(l, r)\n        nums[pivot_idx], nums[r] = nums[r], nums[pivot_idx]\n        pivot = nums[r]\n        store = l\n        for i in range(l, r):\n            if nums[i] < pivot:\n                nums[store], nums[i] = nums[i], nums[store]\n                store += 1\n        nums[store], nums[r] = nums[r], nums[store]\n        \n        if store == target:\n            return nums[store]\n        elif store < target:\n            return quick_select(store + 1, r)\n        else:\n            return quick_select(l, store - 1)\n    \n    return quick_select(0, len(nums) - 1)", explanation: "Quick Select (Hoare's algorithm): Partition array around a random pivot. If the pivot ends up at position n-k, that's our answer. Otherwise, recurse on the correct side only. O(n) average time, O(n\u00B2) worst case. Randomized pivot avoids worst case in practice.", pattern: "Quick Select", order: 7 },
      { title: "Sort List", slug: "sort-list", difficulty: "Hard", description: "Given the head of a linked list, return the list after sorting it in ascending order.\n\nCan you sort the linked list in O(n log n) time and O(1) memory (i.e., constant space)?", examples: JSON.stringify([{input:"head = [4,2,1,3]",output:"[1,2,3,4]"},{input:"head = [-1,5,3,4,0]",output:"[-1,0,3,4,5]"}]), hints: JSON.stringify(["Merge sort is ideal for linked lists -- it doesn't need random access.","Use fast/slow pointers to find the middle, split the list in two.","Recursively sort both halves and merge them."]), solution: "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef sort_list(head):\n    if not head or not head.next:\n        return head\n    \n    # Find middle with slow/fast pointers\n    slow, fast = head, head.next\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    mid = slow.next\n    slow.next = None  # Split the list\n    \n    left = sort_list(head)\n    right = sort_list(mid)\n    \n    # Merge two sorted lists\n    dummy = ListNode(0)\n    curr = dummy\n    while left and right:\n        if left.val <= right.val:\n            curr.next = left\n            left = left.next\n        else:\n            curr.next = right\n            right = right.next\n        curr = curr.next\n    curr.next = left or right\n    return dummy.next", explanation: "Merge sort on linked list: Find middle using slow/fast pointers, split, recursively sort both halves, and merge. Unlike array merge sort, linked list merge sort uses O(1) extra space since merging can be done by relinking nodes. O(n log n) time, O(log n) stack space.", pattern: "Divide and Conquer / Sorting", order: 8 },
    ]},
  };
}
