export function getBacktrackingData() {
  return {
    name: "Backtracking",
    slug: "backtracking",
    description: "Systematically explore all possibilities by making choices, exploring, and undoing (backtracking). Used for combinations, permutations, and constraint satisfaction.",
    icon: "ðŸ”™", order: 11,
    concepts: { create: [
      { title: "Backtracking Template", content: "Backtracking explores a decision tree. At each step, make a choice, recurse, then undo the choice.\n\nTemplate:\ndef backtrack(path, choices):\n    if goal_reached: add path to result\n    for choice in choices:\n        make choice\n        backtrack(path, remaining_choices)\n        undo choice\n\nKey: pruning invalid branches early makes it efficient.", timeComplexity: "O(2^n) or O(n!) depending on problem", spaceComplexity: "O(n) for recursion depth", whenToUse: "Generate all subsets, permutations, combinations. Solve constraint problems like N-Queens, Sudoku. Any 'find all possible...' question.", codeExample: "def subsets(nums):\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", flashcardFront: "What is the general backtracking template and when should you use it?", flashcardBack: "Template: make a choice, recurse, undo the choice. Use when generating all subsets, permutations, combinations, or solving constraint satisfaction problems (N-Queens, Sudoku). Prune invalid branches early for efficiency. Time is typically O(2^n) or O(n!).", order: 1 },
      { title: "Pruning in Backtracking", content: "Pruning means skipping branches of the decision tree that cannot lead to a valid solution. This drastically reduces the search space.\n\nCommon pruning strategies:\n- Skip duplicates: sort the input and skip elements equal to the previous one at the same recursion level.\n- Constraint checking: if partial solution already violates a constraint, don't recurse further.\n- Bounding: if current path can't possibly beat the best known solution, skip it.", timeComplexity: "Varies, but significantly better than brute force", spaceComplexity: "O(n) for recursion depth", whenToUse: "When the search space is large and many branches are invalid. Especially useful with sorted input arrays and duplicate elements.", codeExample: "def subsets_with_dup(nums):\n    nums.sort()\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue  # prune duplicates\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", flashcardFront: "What are the main pruning strategies in backtracking and why are they important?", flashcardBack: "Pruning skips invalid branches to reduce search space. Key strategies: (1) Skip duplicates by sorting input and skipping equal elements at the same level. (2) Constraint checking -- stop recursing if partial solution violates constraints. (3) Bounding -- skip if current path can't beat the best known answer.", order: 2 },
    ]},
    problems: { create: [
      { title: "Subsets", slug: "subsets", difficulty: "Medium", description: "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution must not contain duplicate subsets.", examples: JSON.stringify([{input:"nums = [1,2,3]",output:"[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"},{input:"nums = [0]",output:"[[],[0]]"}]), hints: JSON.stringify(["For each element, you have two choices: include it or skip it.","Use backtracking: at each position, either add the element or don't.","Use a start index to avoid duplicates."]), solution: "def subsets(nums):\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", explanation: "Backtracking: At each step, add current path to result, then try including each remaining element. The start index ensures we don't revisit earlier elements. O(2^n) subsets.", pattern: "Backtracking", order: 1 },
      { title: "Permutations", slug: "permutations", difficulty: "Medium", description: "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.", examples: JSON.stringify([{input:"nums = [1,2,3]",output:"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"},{input:"nums = [1]",output:"[[1]]"}]), hints: JSON.stringify(["A permutation uses all elements in different orders.","At each position, try each unused element.","Track used elements with a set or by swapping."]), solution: "def permute(nums):\n    result = []\n    def backtrack(path, remaining):\n        if not remaining:\n            result.append(path)\n            return\n        for i in range(len(remaining)):\n            backtrack(path + [remaining[i]],\n                      remaining[:i] + remaining[i+1:])\n    backtrack([], nums)\n    return result", explanation: "Backtracking: At each position, try each remaining element. Remove it from available choices and recurse. When no elements remain, we have a complete permutation. O(n!) permutations.", pattern: "Backtracking", order: 2 },
      { title: "Combination Sum", slug: "combination-sum", difficulty: "Medium", description: "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. The same number may be used unlimited times.", examples: JSON.stringify([{input:"candidates = [2,3,6,7], target = 7",output:"[[2,2,3],[7]]"},{input:"candidates = [2,3,5], target = 8",output:"[[2,2,2,2],[2,3,3],[3,5]]"}]), hints: JSON.stringify(["Try including each candidate and recursing with reduced target.","Since we can reuse numbers, don't advance the start index after picking a number.","Prune: if remaining target < 0, stop."]), solution: "def combination_sum(candidates, target):\n    result = []\n    def backtrack(start, path, remaining):\n        if remaining == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > remaining:\n                continue\n            path.append(candidates[i])\n            backtrack(i, path, remaining - candidates[i])\n            path.pop()\n    backtrack(0, [], target)\n    return result", explanation: "Backtracking with reuse: Try each candidate from the current index (allowing reuse by not incrementing start). Prune when the remaining target goes below 0. O(n^(T/M)) where T=target, M=min candidate.", pattern: "Backtracking", order: 3 },
      { title: "Letter Combinations of a Phone Number", slug: "letter-combinations-phone", difficulty: "Easy", description: "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons):\n2: abc, 3: def, 4: ghi, 5: jkl, 6: mno, 7: pqrs, 8: tuv, 9: wxyz", examples: JSON.stringify([{input:'digits = "23"',output:'["ad","ae","af","bd","be","bf","cd","ce","cf"]'},{input:'digits = ""',output:"[]"},{input:'digits = "2"',output:'["a","b","c"]'}]), hints: JSON.stringify(["Map each digit to its corresponding letters.","For each digit, try each possible letter and recurse on the remaining digits.","Build the combination character by character."]), solution: "def letter_combinations(digits):\n    if not digits:\n        return []\n    phone = {'2':'abc','3':'def','4':'ghi','5':'jkl',\n             '6':'mno','7':'pqrs','8':'tuv','9':'wxyz'}\n    result = []\n    def backtrack(idx, path):\n        if idx == len(digits):\n            result.append(''.join(path))\n            return\n        for char in phone[digits[idx]]:\n            path.append(char)\n            backtrack(idx + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", explanation: "Backtracking: For each digit position, try every letter mapped to that digit. Recurse to the next digit. When all digits are processed, add the combination. O(4^n) time where n = number of digits.", pattern: "Backtracking", order: 4 },
      { title: "Generate Parentheses", slug: "generate-parentheses-bt", difficulty: "Easy", description: "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.", examples: JSON.stringify([{input:"n = 3",output:'["((()))","(()())","(())()","()(())","()()()"]'},{input:"n = 1",output:'["()"]'}]), hints: JSON.stringify(["At each step you can add an open paren if you haven't used all n.","You can add a close paren if the number of close parens is less than open parens.","Use backtracking with open_count and close_count as state."]), solution: "def generate_parenthesis(n):\n    result = []\n    def backtrack(path, open_count, close_count):\n        if len(path) == 2 * n:\n            result.append(''.join(path))\n            return\n        if open_count < n:\n            path.append('(')\n            backtrack(path, open_count + 1, close_count)\n            path.pop()\n        if close_count < open_count:\n            path.append(')')\n            backtrack(path, open_count, close_count + 1)\n            path.pop()\n    backtrack([], 0, 0)\n    return result", explanation: "Backtracking with constraints: Add '(' if open_count < n. Add ')' if close_count < open_count. This ensures only valid parentheses are generated. O(4^n / sqrt(n)) -- the nth Catalan number.", pattern: "Backtracking", order: 5 },
      { title: "Combination Sum II", slug: "combination-sum-ii", difficulty: "Medium", description: "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination. The solution set must not contain duplicate combinations.", examples: JSON.stringify([{input:"candidates = [10,1,2,7,6,1,5], target = 8",output:"[[1,1,6],[1,2,5],[1,7],[2,6]]"},{input:"candidates = [2,5,2,1,2], target = 5",output:"[[1,2,2],[5]]"}]), hints: JSON.stringify(["Sort the candidates first.","Skip duplicates at the same recursion level to avoid duplicate combinations.","Move start index forward after picking each element since each can be used once."]), solution: "def combination_sum_2(candidates, target):\n    candidates.sort()\n    result = []\n    def backtrack(start, path, remaining):\n        if remaining == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > remaining:\n                break\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            path.append(candidates[i])\n            backtrack(i + 1, path, remaining - candidates[i])\n            path.pop()\n    backtrack(0, [], target)\n    return result", explanation: "Backtracking with pruning: Sort to enable duplicate skipping. At each level, skip candidates equal to the previous one (i > start and candidates[i] == candidates[i-1]). Each element used at most once (start = i+1). O(2^n) time.", pattern: "Backtracking", order: 6 },
      { title: "Subsets II", slug: "subsets-ii", difficulty: "Easy", description: "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.", examples: JSON.stringify([{input:"nums = [1,2,2]",output:"[[],[1],[1,2],[1,2,2],[2],[2,2]]"},{input:"nums = [0]",output:"[[],[0]]"}]), hints: JSON.stringify(["Sort the array first to bring duplicates together.","When iterating choices at the same level, skip elements equal to the previous.","This is the subsets problem plus a duplicate-skipping technique."]), solution: "def subsets_with_dup(nums):\n    nums.sort()\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", explanation: "Backtracking with duplicate pruning: Sort the array, then skip elements equal to the previous one at the same recursion level (i > start). This prevents generating duplicate subsets. O(2^n) time.", pattern: "Backtracking", order: 7 },
      { title: "Word Search", slug: "word-search", difficulty: "Medium", description: "Given an m x n grid of characters board and a string word, return true if word exists in the grid.\n\nThe word can be constructed from letters of sequentially adjacent cells (horizontally or vertically neighboring). The same cell may not be used more than once.", examples: JSON.stringify([{input:'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"',output:"true"},{input:'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"',output:"true"},{input:'board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"',output:"false"}]), hints: JSON.stringify(["Try starting from every cell that matches the first character.","Use DFS/backtracking: explore all 4 directions for the next character.","Mark cells as visited during exploration and unmark when backtracking."]), solution: "def exist(board, word):\n    rows, cols = len(board), len(board[0])\n    def backtrack(r, c, idx):\n        if idx == len(word):\n            return True\n        if (r < 0 or r >= rows or c < 0 or c >= cols\n                or board[r][c] != word[idx]):\n            return False\n        temp = board[r][c]\n        board[r][c] = '#'  # mark visited\n        found = (backtrack(r+1,c,idx+1) or backtrack(r-1,c,idx+1)\n                 or backtrack(r,c+1,idx+1) or backtrack(r,c-1,idx+1))\n        board[r][c] = temp  # unmark\n        return found\n    for r in range(rows):\n        for c in range(cols):\n            if backtrack(r, c, 0):\n                return True\n    return False", explanation: "Grid backtracking: Start DFS from each cell matching the first character. Mark cells visited by overwriting, restore on backtrack. Explore 4 directions. O(m*n*4^L) where L = word length.", pattern: "Backtracking", order: 8 },
      { title: "Palindrome Partitioning", slug: "palindrome-partitioning", difficulty: "Medium", description: "Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitionings of s.", examples: JSON.stringify([{input:'s = "aab"',output:'[["a","a","b"],["aa","b"]]'},{input:'s = "a"',output:'[["a"]]'}]), hints: JSON.stringify(["At each position, try all possible substrings starting from that position.","Only recurse further if the current substring is a palindrome.","Use backtracking to build partitions one palindromic substring at a time."]), solution: "def partition(s):\n    result = []\n    def is_palindrome(sub):\n        return sub == sub[::-1]\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path[:])\n            return\n        for end in range(start + 1, len(s) + 1):\n            substring = s[start:end]\n            if is_palindrome(substring):\n                path.append(substring)\n                backtrack(end, path)\n                path.pop()\n    backtrack(0, [])\n    return result", explanation: "Backtracking with palindrome check: At each index, try every possible ending position. If the substring is a palindrome, include it and recurse on the remainder. O(n * 2^n) time.", pattern: "Backtracking", order: 9 },
      { title: "N-Queens", slug: "n-queens", difficulty: "Hard", description: "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\n\nGiven an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration where 'Q' indicates a queen and '.' indicates an empty space.", examples: JSON.stringify([{input:"n = 4",output:'[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]'},{input:"n = 1",output:'[["Q"]]'}]), hints: JSON.stringify(["Place queens row by row. In each row, try each column.","Track which columns and diagonals are under attack.","Two cells are on the same diagonal if (row-col) or (row+col) match."]), solution: "def solve_n_queens(n):\n    result = []\n    cols = set()\n    pos_diag = set()  # row + col\n    neg_diag = set()  # row - col\n    board = [['.' ] * n for _ in range(n)]\n    def backtrack(row):\n        if row == n:\n            result.append([''.join(r) for r in board])\n            return\n        for col in range(n):\n            if col in cols or (row+col) in pos_diag or (row-col) in neg_diag:\n                continue\n            cols.add(col)\n            pos_diag.add(row+col)\n            neg_diag.add(row-col)\n            board[row][col] = 'Q'\n            backtrack(row + 1)\n            board[row][col] = '.'\n            cols.remove(col)\n            pos_diag.remove(row+col)\n            neg_diag.remove(row-col)\n    backtrack(0)\n    return result", explanation: "Backtracking with constraint sets: Place queens row by row. Track attacked columns, positive diagonals (row+col), and negative diagonals (row-col) in sets. Skip invalid placements. O(n!) time.", pattern: "Backtracking", order: 10 },
      { title: "Sudoku Solver", slug: "sudoku-solver", difficulty: "Hard", description: "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes.\n\nThe '.' character indicates empty cells.", examples: JSON.stringify([{input:'board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]',output:"(the completed board)"},{input:'board = (any valid incomplete sudoku)',output:"(the completed board)"}]), hints: JSON.stringify(["Find the next empty cell and try digits 1-9.","Check if placing a digit violates row, column, or 3x3 box constraints.","If no digit works for a cell, backtrack to the previous cell and try the next digit."]), solution: "def solve_sudoku(board):\n    def is_valid(r, c, ch):\n        for i in range(9):\n            if board[r][i] == ch: return False\n            if board[i][c] == ch: return False\n            if board[3*(r//3)+i//3][3*(c//3)+i%3] == ch: return False\n        return True\n    def solve():\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == '.':\n                    for ch in '123456789':\n                        if is_valid(r, c, ch):\n                            board[r][c] = ch\n                            if solve():\n                                return True\n                            board[r][c] = '.'\n                    return False\n        return True\n    solve()", explanation: "Constraint backtracking: Find the next empty cell, try digits 1-9 that satisfy row, column, and box constraints. Recurse. If stuck, backtrack. Pruning via constraint checking keeps it tractable. O(9^(empty cells)) worst case.", pattern: "Backtracking", order: 11 },
    ]},
  };
}
