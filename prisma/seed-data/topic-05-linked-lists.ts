export function getLinkedListsData() {
  return {
    name: "Linked Lists",
    slug: "linked-lists",
    description: "Master pointer manipulation: fast/slow pointers for cycles and midpoints, reversal for reordering, and merge techniques.",
    icon: "\uD83D\uDD17", order: 5,
    concepts: { create: [
      {
        title: "Fast & Slow Pointers",
        content: "Two pointers move at different speeds (slow by 1, fast by 2). They meet if there's a cycle. When fast reaches the end, slow is at the middle.\n\nCycle detection (Floyd's): if fast and slow meet, there's a cycle. To find the cycle start, reset one pointer to head and move both by 1.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(1)",
        whenToUse: "Detect cycles, find the middle node, find the start of a cycle, check if a linked list is a palindrome.",
        codeExample: "def has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
        flashcardFront: "How does Floyd's cycle detection algorithm work, and how do you find the start of the cycle?",
        flashcardBack: "Floyd's algorithm uses two pointers: slow (moves 1 step) and fast (moves 2 steps). If they meet, a cycle exists. To find the cycle start: reset one pointer to head, keep the other at the meeting point, and move both by 1 step. They will meet at the cycle start. Proof: if the distance from head to cycle start is 'a' and cycle length is 'c', slow travels a+b steps, fast travels a+b+c steps. Since fast = 2*slow, a+b+c = 2(a+b), so c = a+b, meaning a = c-b. Walking 'a' steps from both head and meeting point converges at the cycle start.",
        order: 1,
      },
      {
        title: "Linked List Reversal",
        content: "Reverse a linked list by redirecting the next pointers. Use three pointers: prev, curr, next.\n\nPattern: save next, point curr.next to prev, advance prev and curr.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(1)",
        whenToUse: "When you need to reverse all or part of a linked list, check palindromes, or reorder nodes.",
        codeExample: "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev",
        flashcardFront: "What are the three pointers needed to reverse a linked list iteratively, and what does each do?",
        flashcardBack: "1) prev: points to the already-reversed portion (starts as None). 2) curr: the current node being processed. 3) nxt (next): temporarily stores curr.next before we overwrite it. At each step: save nxt = curr.next, reverse the link (curr.next = prev), advance prev = curr and curr = nxt. When curr is None, prev is the new head. O(n) time, O(1) space.",
        order: 2,
      },
    ]},
    problems: { create: [
      // ===== EXISTING 3 PROBLEMS =====
      {
        title: "Reverse Linked List",
        slug: "reverse-linked-list",
        difficulty: "Easy",
        description: "Given the head of a singly linked list, reverse the list, and return the reversed list.",
        examples: JSON.stringify([
          { input: "head = [1,2,3,4,5]", output: "[5,4,3,2,1]" },
          { input: "head = [1,2]", output: "[2,1]" },
        ]),
        hints: JSON.stringify([
          "You need to redirect each node's next pointer.",
          "Use three pointers: prev, current, and next.",
          "At each step: save next, reverse the link, advance pointers.",
        ]),
        solution: "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev",
        explanation: "Linked List Reversal: Iterate through the list, reversing each pointer. Maintain prev, curr, nxt pointers. After the loop, prev is the new head. O(n) time, O(1) space.",
        pattern: "Linked List Reversal",
        order: 1,
      },
      {
        title: "Linked List Cycle",
        slug: "linked-list-cycle",
        difficulty: "Easy",
        description: "Given head, the head of a linked list, determine if the linked list has a cycle in it. A cycle exists if some node can be reached again by continuously following the next pointer.",
        examples: JSON.stringify([
          { input: "head = [3,2,0,-4], pos = 1", output: "true", explanation: "Tail connects to node at index 1" },
          { input: "head = [1], pos = -1", output: "false" },
        ]),
        hints: JSON.stringify([
          "Can you use two pointers moving at different speeds?",
          "If there's a cycle, a faster pointer will eventually catch the slower one.",
          "Floyd's cycle detection: slow moves 1 step, fast moves 2 steps.",
        ]),
        solution: "def has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False",
        explanation: "Fast & Slow Pointers (Floyd's): Slow moves 1 step, fast moves 2 steps. If there's a cycle, they'll eventually meet. If fast reaches null, no cycle. O(n) time, O(1) space.",
        pattern: "Fast & Slow Pointers",
        order: 2,
      },
      {
        title: "Merge Two Sorted Lists",
        slug: "merge-two-sorted-lists",
        difficulty: "Easy",
        description: "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list by splicing together the nodes. Return the head of the merged list.",
        examples: JSON.stringify([
          { input: "list1 = [1,2,4], list2 = [1,3,4]", output: "[1,1,2,3,4,4]" },
          { input: "list1 = [], list2 = [0]", output: "[0]" },
        ]),
        hints: JSON.stringify([
          "Use a dummy node to build the result.",
          "Compare current nodes of both lists, append the smaller one.",
          "When one list is exhausted, append the remainder of the other.",
        ]),
        solution: "def merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    while l1 and l2:\n        if l1.val <= l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 or l2\n    return dummy.next",
        explanation: "Merge technique with dummy node: Compare heads of both lists, always pick the smaller one. Use a dummy node to simplify building the result. O(n + m) time, O(1) space.",
        pattern: "Linked List Reversal",
        order: 3,
      },

      // ===== NEW PROBLEMS =====
      {
        title: "Remove Nth Node From End of List",
        slug: "remove-nth-from-end",
        difficulty: "Medium",
        description: "Given the head of a linked list, remove the nth node from the end of the list and return its head.",
        examples: JSON.stringify([
          { input: "head = [1,2,3,4,5], n = 2", output: "[1,2,3,5]", explanation: "Remove the 2nd node from end (node 4)." },
          { input: "head = [1], n = 1", output: "[]" },
          { input: "head = [1,2], n = 1", output: "[1]" },
        ]),
        hints: JSON.stringify([
          "Use two pointers with a gap of n between them.",
          "Move the first pointer n steps ahead, then move both together.",
          "When the first pointer reaches the end, the second is at the node before the target.",
        ]),
        solution: "def remove_nth_from_end(head, n):\n    dummy = ListNode(0, head)\n    first = second = dummy\n    for _ in range(n + 1):\n        first = first.next\n    while first:\n        first = first.next\n        second = second.next\n    second.next = second.next.next\n    return dummy.next",
        explanation: "Two Pointers with gap: Advance the first pointer n+1 steps ahead. Then move both pointers until first reaches null. Second pointer is now just before the node to remove. Use a dummy node to handle edge cases. O(n) time, O(1) space.",
        pattern: "Two Pointers",
        order: 4,
      },
      {
        title: "Reorder List",
        slug: "reorder-list",
        difficulty: "Medium",
        description: "You are given the head of a singly linked list. The list can be represented as:\n\nL0 -> L1 -> ... -> Ln-1 -> Ln\n\nReorder the list to be on the following form:\n\nL0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.",
        examples: JSON.stringify([
          { input: "head = [1,2,3,4]", output: "[1,4,2,3]" },
          { input: "head = [1,2,3,4,5]", output: "[1,5,2,4,3]" },
        ]),
        hints: JSON.stringify([
          "This problem combines three linked list techniques.",
          "Step 1: Find the middle using fast/slow pointers. Step 2: Reverse the second half.",
          "Step 3: Merge the two halves by alternating nodes.",
        ]),
        solution: "def reorder_list(head):\n    # Find middle\n    slow = fast = head\n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # Reverse second half\n    prev = None\n    curr = slow.next\n    slow.next = None\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    \n    # Merge two halves\n    first, second = head, prev\n    while second:\n        tmp1, tmp2 = first.next, second.next\n        first.next = second\n        second.next = tmp1\n        first = tmp1\n        second = tmp2",
        explanation: "Three techniques combined: 1) Find middle with fast/slow pointers. 2) Reverse the second half. 3) Merge by alternating nodes from each half. O(n) time, O(1) space.",
        pattern: "Fast & Slow + Reversal + Merge",
        order: 5,
      },
      {
        title: "Linked List Cycle II",
        slug: "linked-list-cycle-ii",
        difficulty: "Medium",
        description: "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nDo not modify the linked list.",
        examples: JSON.stringify([
          { input: "head = [3,2,0,-4], pos = 1", output: "Node at index 1", explanation: "Tail connects to node at index 1 (value 2)." },
          { input: "head = [1,2], pos = 0", output: "Node at index 0", explanation: "Tail connects to the first node." },
          { input: "head = [1], pos = -1", output: "null" },
        ]),
        hints: JSON.stringify([
          "First, detect if a cycle exists using Floyd's algorithm.",
          "If slow and fast meet, a cycle exists. Now find the start.",
          "Reset one pointer to head, keep the other at the meeting point, and advance both by 1 step until they meet.",
        ]),
        solution: "def detect_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            # Find cycle start\n            slow = head\n            while slow != fast:\n                slow = slow.next\n                fast = fast.next\n            return slow\n    return None",
        explanation: "Floyd's Algorithm (extended): Phase 1 - detect cycle with slow/fast pointers. Phase 2 - reset slow to head, advance both by 1. They meet at the cycle start. Mathematical proof: distance from head to cycle start equals distance from meeting point to cycle start. O(n) time, O(1) space.",
        pattern: "Fast & Slow Pointers",
        order: 6,
      },
      {
        title: "Copy List with Random Pointer",
        slug: "copy-list-random-pointer",
        difficulty: "Medium",
        description: "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\n\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list.",
        examples: JSON.stringify([
          { input: "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]", output: "[[7,null],[13,0],[11,4],[10,2],[1,0]]" },
          { input: "head = [[1,1],[2,1]]", output: "[[1,1],[2,1]]" },
        ]),
        hints: JSON.stringify([
          "The tricky part is mapping old nodes to new nodes for the random pointers.",
          "Use a hash map to store old_node -> new_node mapping.",
          "First pass: create all new nodes. Second pass: set next and random pointers.",
        ]),
        solution: "def copy_random_list(head):\n    if not head:\n        return None\n    old_to_new = {}\n    curr = head\n    while curr:\n        old_to_new[curr] = Node(curr.val)\n        curr = curr.next\n    curr = head\n    while curr:\n        old_to_new[curr].next = old_to_new.get(curr.next)\n        old_to_new[curr].random = old_to_new.get(curr.random)\n        curr = curr.next\n    return old_to_new[head]",
        explanation: "Hash Map for node mapping: First pass creates new nodes and maps old to new. Second pass wires up next and random pointers using the map. O(n) time, O(n) space.",
        pattern: "Hash Map / Linked List",
        order: 7,
      },
      {
        title: "Add Two Numbers",
        slug: "add-two-numbers",
        difficulty: "Medium",
        description: "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        examples: JSON.stringify([
          { input: "l1 = [2,4,3], l2 = [5,6,4]", output: "[7,0,8]", explanation: "342 + 465 = 807" },
          { input: "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]", output: "[8,9,9,9,0,0,0,1]" },
        ]),
        hints: JSON.stringify([
          "Since digits are in reverse order, you can add from the head.",
          "Track the carry from each digit addition.",
          "Don't forget the final carry at the end.",
        ]),
        solution: "def add_two_numbers(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n    while l1 or l2 or carry:\n        val = carry\n        if l1:\n            val += l1.val\n            l1 = l1.next\n        if l2:\n            val += l2.val\n            l2 = l2.next\n        carry = val // 10\n        curr.next = ListNode(val % 10)\n        curr = curr.next\n    return dummy.next",
        explanation: "Elementary Math on Linked Lists: Add corresponding digits plus carry. Create new nodes for each digit of the result. Continue until both lists are exhausted and carry is 0. O(max(m,n)) time, O(max(m,n)) space.",
        pattern: "Linked List Traversal",
        order: 8,
      },
      {
        title: "Reverse Nodes in k-Group",
        slug: "reverse-nodes-k-group",
        difficulty: "Hard",
        description: "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\n\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\n\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        examples: JSON.stringify([
          { input: "head = [1,2,3,4,5], k = 2", output: "[2,1,4,3,5]" },
          { input: "head = [1,2,3,4,5], k = 3", output: "[3,2,1,4,5]" },
        ]),
        hints: JSON.stringify([
          "First, check if there are at least k nodes remaining.",
          "If yes, reverse the next k nodes using standard reversal.",
          "Connect the reversed group to the previous group and recurse/iterate for the next group.",
        ]),
        solution: "def reverse_k_group(head, k):\n    # Check if there are k nodes\n    count = 0\n    node = head\n    while node and count < k:\n        node = node.next\n        count += 1\n    if count < k:\n        return head\n    \n    # Reverse k nodes\n    prev = None\n    curr = head\n    for _ in range(k):\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    \n    # head is now the tail of reversed group\n    head.next = reverse_k_group(curr, k)\n    return prev",
        explanation: "Recursive Reversal: For each group of k nodes: 1) Verify k nodes exist. 2) Reverse them using standard reversal. 3) Connect the tail of the reversed group to the result of recursing on the remaining list. O(n) time, O(n/k) recursion space.",
        pattern: "Linked List Reversal",
        order: 9,
      },
      {
        title: "Merge K Sorted Linked Lists",
        slug: "merge-k-sorted-linked-lists",
        difficulty: "Hard",
        description: "You are given an array of k linked lists lists, each linked list is sorted in ascending order.\n\nMerge all the linked lists into one sorted linked list and return it.",
        examples: JSON.stringify([
          { input: "lists = [[1,4,5],[1,3,4],[2,6]]", output: "[1,1,2,3,4,4,5,6]" },
          { input: "lists = []", output: "[]" },
          { input: "lists = [[]]", output: "[]" },
        ]),
        hints: JSON.stringify([
          "You need to always pick the smallest element among k candidates.",
          "Use divide and conquer: merge pairs of lists repeatedly.",
          "Alternatively, use a min-heap to always get the smallest head in O(log k).",
        ]),
        solution: "def merge_k_lists(lists):\n    if not lists:\n        return None\n    \n    def merge_two(l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        while l1 and l2:\n            if l1.val <= l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        curr.next = l1 or l2\n        return dummy.next\n    \n    while len(lists) > 1:\n        merged = []\n        for i in range(0, len(lists), 2):\n            l1 = lists[i]\n            l2 = lists[i + 1] if i + 1 < len(lists) else None\n            merged.append(merge_two(l1, l2))\n        lists = merged\n    return lists[0]",
        explanation: "Divide and Conquer: Merge lists pairwise, halving the number of lists each round. After log(k) rounds, all lists are merged. Each round processes all n nodes. O(n log k) time, O(1) space (excluding recursion).",
        pattern: "Divide and Conquer / Merge",
        order: 10,
      },
    ]},
  };
}
