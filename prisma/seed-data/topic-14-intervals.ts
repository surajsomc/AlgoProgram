export function getIntervalsData() {
  return {
    name: "Intervals",
    slug: "intervals",
    description: "Sort intervals and process them in order. Merge overlapping intervals, find gaps, or count overlaps.",
    icon: "↔️", order: 14,
    concepts: { create: [
      { title: "Interval Merging", content: "Sort intervals by start time. Iterate and merge overlapping ones.\n\nTwo intervals overlap if the second starts before the first ends: b.start <= a.end.\n\nWhen merging: new_end = max(a.end, b.end).", timeComplexity: "O(n log n) for sorting", spaceComplexity: "O(n)", whenToUse: "Merge overlapping intervals, insert interval, find minimum meeting rooms, determine if person can attend all meetings.", codeExample: "def merge(intervals):\n    intervals.sort()\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", flashcardFront: "How do you merge overlapping intervals and what is the time complexity?", flashcardBack: "Sort intervals by start time. Iterate through: if current start <= previous end, they overlap so extend previous end to max(prev_end, curr_end). Otherwise, start a new group. Time O(n log n) for sorting, O(n) space for output.", order: 1 },
      { title: "Sweep Line / Event Points", content: "Instead of working with intervals directly, decompose them into start and end events. Sort events by time and process them in order.\n\nAt each start event: increment active count. At each end event: decrement. The maximum active count tells you the peak overlap.\n\nThis technique is also called the 'sweep line' algorithm.", timeComplexity: "O(n log n)", spaceComplexity: "O(n)", whenToUse: "Counting maximum overlapping intervals, minimum meeting rooms, skyline problem, or any problem where you need to track how many intervals are active at any point.", codeExample: "def min_meeting_rooms(intervals):\n    events = []\n    for s, e in intervals:\n        events.append((s, 1))   # start\n        events.append((e, -1))  # end\n    events.sort()\n    rooms = max_rooms = 0\n    for time, delta in events:\n        rooms += delta\n        max_rooms = max(max_rooms, rooms)\n    return max_rooms", flashcardFront: "What is the sweep line technique for interval problems?", flashcardBack: "Decompose intervals into start (+1) and end (-1) events. Sort events by time. Sweep through, maintaining a running count of active intervals. The maximum count is the peak overlap. Used for: minimum meeting rooms, maximum concurrent events, skyline problems. Time O(n log n).", order: 2 },
    ]},
    problems: { create: [
      { title: "Merge Intervals", slug: "merge-intervals", difficulty: "Medium", description: "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals.", examples: JSON.stringify([{input:"intervals = [[1,3],[2,6],[8,10],[15,18]]",output:"[[1,6],[8,10],[15,18]]",explanation:"[1,3] and [2,6] overlap, merged to [1,6]."},{input:"intervals = [[1,4],[4,5]]",output:"[[1,5]]"}]), hints: JSON.stringify(["Sort intervals by start time.","If current interval overlaps with previous, merge them.","Two intervals overlap if the second's start <= the first's end."]), solution: "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", explanation: "Merge Intervals: Sort by start time, then iterate. If current overlaps with last merged (start <= prev_end), extend the end. Otherwise, start a new interval. O(n log n) time.", pattern: "Merge Intervals", order: 1 },
      { title: "Non-Overlapping Intervals", slug: "non-overlapping-intervals", difficulty: "Medium", description: "Given an array of intervals, return the minimum number of intervals you need to remove to make the rest non-overlapping.", examples: JSON.stringify([{input:"intervals = [[1,2],[2,3],[3,4],[1,3]]",output:"1",explanation:"Remove [1,3] to make the rest non-overlapping."},{input:"intervals = [[1,2],[1,2],[1,2]]",output:"2"}]), hints: JSON.stringify(["Sort by end time.","Greedily keep intervals that end earliest.","If an interval overlaps with the previous kept interval, remove it."]), solution: "def erase_overlap_intervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    count = 0\n    prev_end = float('-inf')\n    for start, end in intervals:\n        if start >= prev_end:\n            prev_end = end\n        else:\n            count += 1\n    return count", explanation: "Greedy (sort by end time): Keep intervals that end earliest to leave maximum room. Count intervals that overlap with the previously kept one. O(n log n) time.", pattern: "Merge Intervals", order: 2 },
      { title: "Meeting Rooms II", slug: "meeting-rooms-ii", difficulty: "Medium", description: "Given an array of meeting time intervals consisting of start and end times, find the minimum number of conference rooms required.", examples: JSON.stringify([{input:"intervals = [[0,30],[5,10],[15,20]]",output:"2",explanation:"Meetings [0,30] and [5,10] overlap, need 2 rooms."},{input:"intervals = [[7,10],[2,4]]",output:"1"}]), hints: JSON.stringify(["Think about it as counting maximum concurrent meetings.","Separate start times and end times, sort both.","Use two pointers: increment rooms at each start, decrement at each end."]), solution: "def min_meeting_rooms(intervals):\n    starts = sorted(i[0] for i in intervals)\n    ends = sorted(i[1] for i in intervals)\n    rooms = max_rooms = 0\n    s = e = 0\n    while s < len(starts):\n        if starts[s] < ends[e]:\n            rooms += 1\n            max_rooms = max(max_rooms, rooms)\n            s += 1\n        else:\n            rooms -= 1\n            e += 1\n    return max_rooms", explanation: "Sort start/end times separately, sweep through with two pointers. Each start adds a room, each end frees a room. Track the maximum concurrent rooms. O(n log n) time.", pattern: "Merge Intervals", order: 3 },
      { title: "Meeting Rooms", slug: "meeting-rooms", difficulty: "Easy", description: "Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.\n\nA person can attend all meetings if no two meetings overlap.", examples: JSON.stringify([{input:"intervals = [[0,30],[5,10],[15,20]]",output:"false",explanation:"[0,30] and [5,10] overlap."},{input:"intervals = [[7,10],[2,4]]",output:"true"}]), hints: JSON.stringify(["Sort the intervals by start time.","Check if any interval overlaps with the next one.","Two intervals overlap if one starts before the other ends."]), solution: "def can_attend_meetings(intervals):\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True", explanation: "Sort by start time, then check adjacent pairs. If any meeting starts before the previous one ends, there is an overlap. O(n log n) time for sorting, O(1) extra space.", pattern: "Merge Intervals", order: 4 },
      { title: "Insert Interval", slug: "insert-interval", difficulty: "Easy", description: "You are given an array of non-overlapping intervals sorted by start time and a new interval. Insert the new interval into the intervals (merge if necessary).\n\nReturn the resulting array of non-overlapping intervals sorted by start time.", examples: JSON.stringify([{input:"intervals = [[1,3],[6,9]], newInterval = [2,5]",output:"[[1,5],[6,9]]"},{input:"intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]",output:"[[1,2],[3,10],[12,16]]"}]), hints: JSON.stringify(["Add all intervals that come entirely before the new interval.","Merge all intervals that overlap with the new interval.","Add all intervals that come entirely after the merged interval."]), solution: "def insert(intervals, new_interval):\n    result = []\n    i = 0\n    n = len(intervals)\n    # Add all intervals before new_interval\n    while i < n and intervals[i][1] < new_interval[0]:\n        result.append(intervals[i])\n        i += 1\n    # Merge overlapping intervals\n    while i < n and intervals[i][0] <= new_interval[1]:\n        new_interval[0] = min(new_interval[0], intervals[i][0])\n        new_interval[1] = max(new_interval[1], intervals[i][1])\n        i += 1\n    result.append(new_interval)\n    # Add remaining intervals\n    while i < n:\n        result.append(intervals[i])\n        i += 1\n    return result", explanation: "Three-phase approach: (1) Add intervals ending before the new one starts. (2) Merge all overlapping intervals with the new one. (3) Add remaining intervals. O(n) time since intervals are already sorted.", pattern: "Merge Intervals", order: 5 },
      { title: "Interval List Intersections", slug: "interval-list-intersections", difficulty: "Medium", description: "You are given two lists of closed intervals, firstList and secondList, where each list is pairwise disjoint and sorted.\n\nReturn the intersection of these two interval lists. A closed interval [a, b] (with a <= b) denotes the set of real numbers x with a <= x <= b.", examples: JSON.stringify([{input:"firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]",output:"[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]"},{input:"firstList = [[1,3],[5,9]], secondList = []",output:"[]"}]), hints: JSON.stringify(["Two intervals intersect if max(start1, start2) <= min(end1, end2).","Use two pointers, one for each list.","Advance the pointer of the interval that ends first."]), solution: "def interval_intersection(first_list, second_list):\n    result = []\n    i = j = 0\n    while i < len(first_list) and j < len(second_list):\n        lo = max(first_list[i][0], second_list[j][0])\n        hi = min(first_list[i][1], second_list[j][1])\n        if lo <= hi:\n            result.append([lo, hi])\n        if first_list[i][1] < second_list[j][1]:\n            i += 1\n        else:\n            j += 1\n    return result", explanation: "Two pointers: Compute intersection as [max(starts), min(ends)]. If valid (lo <= hi), add it. Advance the pointer of whichever interval ends first. O(m + n) time, O(1) extra space.", pattern: "Merge Intervals", order: 6 },
      { title: "Minimum Interval to Include Each Query", slug: "min-interval-include-query", difficulty: "Hard", description: "You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is righti - lefti + 1.\n\nYou are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1.\n\nReturn an array containing the answers to the queries.", examples: JSON.stringify([{input:"intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",output:"[3,3,1,4]",explanation:"Query 2: [2,4] has size 3. Query 3: [2,4] has size 3. Query 4: [4,4] has size 1. Query 5: [3,6] has size 4."},{input:"intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",output:"[2,-1,4,6]"}]), hints: JSON.stringify(["Sort intervals by start and queries by value.","Use a min-heap to track active intervals, keyed by size.","For each query, add all intervals that start before the query, remove expired ones, and pick the smallest."]), solution: "import heapq\ndef min_interval(intervals, queries):\n    intervals.sort()\n    sorted_queries = sorted(enumerate(queries), key=lambda x: x[1])\n    heap = []\n    result = [-1] * len(queries)\n    i = 0\n    for idx, q in sorted_queries:\n        while i < len(intervals) and intervals[i][0] <= q:\n            l, r = intervals[i]\n            heapq.heappush(heap, (r - l + 1, r))\n            i += 1\n        while heap and heap[0][1] < q:\n            heapq.heappop(heap)\n        if heap:\n            result[idx] = heap[0][0]\n    return result", explanation: "Sort + Min-Heap: Sort intervals by start, queries by value. For each query, push all intervals starting before it into a min-heap (keyed by size). Pop expired intervals (end < query). The top of the heap is the smallest valid interval. O((n+q) log n) time.", pattern: "Merge Intervals", order: 7 },
      { title: "Employee Free Time", slug: "employee-free-time", difficulty: "Hard", description: "We are given a list of schedules for employees, where each schedule is a list of non-overlapping intervals in sorted order.\n\nReturn the list of finite intervals representing the common free time for all employees, in sorted order.", examples: JSON.stringify([{input:"schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]",output:"[[3,4]]",explanation:"All employees are free during [3,4]."},{input:"schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]",output:"[[5,6],[7,9]]"}]), hints: JSON.stringify(["Flatten all intervals into one list and merge them.","The gaps between merged intervals are the common free times.","Sort all intervals by start time, merge overlapping ones, then find gaps."]), solution: "def employee_free_time(schedule):\n    intervals = []\n    for emp in schedule:\n        for interval in emp:\n            intervals.append(interval)\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    free = []\n    for i in range(1, len(merged)):\n        free.append([merged[i-1][1], merged[i][0]])\n    return free", explanation: "Flatten + Merge + Gap detection: Collect all intervals, sort by start, merge overlapping ones. The gaps between consecutive merged intervals are the free times. O(n log n) where n = total intervals.", pattern: "Merge Intervals", order: 8 },
    ]},
  };
}
