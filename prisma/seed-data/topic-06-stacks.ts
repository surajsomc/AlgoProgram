export function getStacksData() {
  return {
    name: "Stacks & Queues",
    slug: "stacks-and-queues",
    description: "Stacks (LIFO) for matching, parsing, and monotonic problems. Queues (FIFO) for BFS and order processing.",
    icon: "ðŸ“š", order: 6,
    concepts: { create: [
      { title: "Monotonic Stack", content: "A stack that maintains elements in increasing or decreasing order. When you push a new element, pop all elements that violate the order.\n\nUseful for: finding the next greater/smaller element for each position in O(n) total.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "Next greater element, next smaller element, daily temperatures, stock span, largest rectangle in histogram.", codeExample: "def next_greater(nums):\n    result = [-1] * len(nums)\n    stack = []  # indices\n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] < num:\n            result[stack.pop()] = num\n        stack.append(i)\n    return result", flashcardFront: "What is a monotonic stack and when do you use it?", flashcardBack: "A monotonic stack maintains elements in strictly increasing or decreasing order. When pushing a new element, pop all elements that violate the monotonic property. Use it for 'next greater element' or 'next smaller element' patterns, such as daily temperatures or stock span. Each element is pushed and popped at most once, giving O(n) total time.", order: 1 },
      { title: "Stack for Matching", content: "Use a stack to match opening/closing pairs. Push opening symbols, pop when you see the matching closing symbol.\n\nIf the stack is empty when you need to pop, or non-empty at the end, the string is invalid.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "Valid parentheses, matching brackets, nested structures, expression evaluation.", codeExample: "def is_valid(s):\n    stack = []\n    pairs = {')':'(', ']':'[', '}':'{'}\n    for c in s:\n        if c in pairs:\n            if not stack or stack[-1] != pairs[c]:\n                return False\n            stack.pop()\n        else:\n            stack.append(c)\n    return len(stack) == 0", flashcardFront: "How does a stack help with matching parentheses or brackets?", flashcardBack: "Push each opening bracket onto the stack. When you encounter a closing bracket, check if the top of the stack is the matching opening bracket and pop it. If the stack is empty when you need to pop, or non-empty after processing all characters, the string is invalid. The stack ensures correct nesting order (LIFO).", order: 2 },
      { title: "Queue and BFS", content: "A queue (FIFO) processes elements in the order they arrive. In BFS, the queue holds nodes to visit next, ensuring level-by-level exploration.\n\nA deque (double-ended queue) supports O(1) append/pop from both ends and is useful for sliding window maximums.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "BFS traversal, task scheduling, sliding window maximum (deque), implementing a stack using queues.", codeExample: "from collections import deque\ndef bfs(graph, start):\n    visited = {start}\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)", flashcardFront: "What is the difference between a stack and a queue, and when do you use each?", flashcardBack: "A stack is LIFO (Last In, First Out) -- the most recently added element is removed first. Use stacks for matching/parsing, undo operations, DFS, and monotonic problems. A queue is FIFO (First In, First Out) -- the earliest added element is removed first. Use queues for BFS, task scheduling, and order-preserving processing. In Python, use collections.deque for efficient O(1) operations on both ends.", order: 3 },
    ]},
    problems: { create: [
      // === Existing 3 problems ===
      { title: "Valid Parentheses", slug: "valid-parentheses", difficulty: "Easy", description: "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.", examples: JSON.stringify([{input:'s = "()"',output:"true"},{input:'s = "()[]{}"',output:"true"},{input:'s = "(]"',output:"false"}]), hints: JSON.stringify(["When you see an opening bracket, you need its closing bracket later.","A stack preserves the order â€” the most recent opening bracket should be closed first.","Push opening brackets, pop and check when you see closing brackets."]), solution: "def is_valid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return len(stack) == 0", explanation: "Stack for Matching: Push opening brackets onto stack. For each closing bracket, check if the top of the stack is the matching opening bracket. Stack ensures correct nesting order. O(n) time.", pattern: "Stack (Matching/Parsing)", order: 1 },
      { title: "Daily Temperatures", slug: "daily-temperatures", difficulty: "Medium", description: "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day with warmer temperature, answer[i] = 0.", examples: JSON.stringify([{input:"temperatures = [73,74,75,71,69,72,76,73]",output:"[1,1,4,2,1,1,0,0]"},{input:"temperatures = [30,40,50,60]",output:"[1,1,1,0]"}]), hints: JSON.stringify(["For each day, you need the next day with a higher temperature.","This is the 'next greater element' pattern.","Use a monotonic decreasing stack of indices."]), solution: "def daily_temperatures(temps):\n    n = len(temps)\n    answer = [0] * n\n    stack = []  # indices of decreasing temps\n    for i in range(n):\n        while stack and temps[i] > temps[stack[-1]]:\n            j = stack.pop()\n            answer[j] = i - j\n        stack.append(i)\n    return answer", explanation: "Monotonic Stack: Maintain a stack of indices with decreasing temperatures. When a warmer day is found, pop all cooler days from the stack and record the difference. O(n) time, each element pushed/popped at most once.", pattern: "Monotonic Stack", order: 2 },
      { title: "Min Stack", slug: "min-stack", difficulty: "Medium", description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n- push(val): pushes element onto stack\n- pop(): removes the element on the top\n- top(): gets the top element\n- getMin(): retrieves the minimum element", examples: JSON.stringify([{input:"push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()",output:"-3, 0, -2"}]), hints: JSON.stringify(["You need O(1) for getMin â€” you can't scan the whole stack each time.","What if you stored the current minimum alongside each element?","Use a second stack (or store tuples) that tracks the min at each level."]), solution: "class MinStack:\n    def __init__(self):\n        self.stack = []  # (val, current_min)\n    \n    def push(self, val):\n        curr_min = min(val, self.stack[-1][1] if self.stack else val)\n        self.stack.append((val, curr_min))\n    \n    def pop(self):\n        self.stack.pop()\n    \n    def top(self):\n        return self.stack[-1][0]\n    \n    def getMin(self):\n        return self.stack[-1][1]", explanation: "Design (Data Structure): Store each element as a tuple (value, current_minimum). The minimum at each level is min(value, previous_minimum). All operations are O(1).", pattern: "Design (Data Structure)", order: 3 },
      // === New problems (2E + 5M) to reach 3E/5M/2H ===
      { title: "Implement Queue Using Stacks", slug: "implement-queue-using-stacks", difficulty: "Easy", description: "Implement a first-in-first-out (FIFO) queue using only two stacks. The implemented queue should support the standard queue operations: push, peek, pop, and empty.\n\nImplement the MyQueue class:\n- push(x): Pushes element x to the back of the queue.\n- pop(): Removes the element from the front of the queue and returns it.\n- peek(): Returns the element at the front of the queue.\n- empty(): Returns true if the queue is empty, false otherwise.", examples: JSON.stringify([{input:"push(1), push(2), peek(), pop(), empty()",output:"1, 1, false",explanation:"peek returns 1 (front), pop removes and returns 1, queue still has 2"},{input:"push(1), push(2), pop(), push(3), peek()",output:"1, 2",explanation:"After popping 1, push 3. Peek returns 2 which was pushed before 3"}]), hints: JSON.stringify(["One stack can reverse the order of elements.","Use one stack for input (push operations) and one for output (pop/peek operations).","When the output stack is empty, transfer all elements from the input stack to it."]), solution: "class MyQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n    \n    def push(self, x):\n        self.stack_in.append(x)\n    \n    def pop(self):\n        self.peek()\n        return self.stack_out.pop()\n    \n    def peek(self):\n        if not self.stack_out:\n            while self.stack_in:\n                self.stack_out.append(self.stack_in.pop())\n        return self.stack_out[-1]\n    \n    def empty(self):\n        return not self.stack_in and not self.stack_out", explanation: "Two Stacks: Use an input stack for pushes and an output stack for pops/peeks. When the output stack is empty, transfer all elements from input to output (reversing their order). This gives amortized O(1) per operation since each element is moved at most twice.", pattern: "Design (Data Structure)", order: 4 },
      { title: "Baseball Game", slug: "baseball-game", difficulty: "Easy", description: "You are keeping score for a baseball game with unusual rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings operations, where operations[i] is one of:\n- An integer x: Record a new score of x.\n- '+': Record a new score that is the sum of the previous two scores.\n- 'D': Record a new score that is double of the previous score.\n- 'C': Invalidate the previous score, removing it from the record.\n\nReturn the sum of all scores after applying all operations.", examples: JSON.stringify([{input:'ops = ["5","2","C","D","+"]',output:"30",explanation:"'5' -> [5], '2' -> [5,2], 'C' -> [5], 'D' -> [5,10], '+' -> [5,10,15]. Sum = 30"},{input:'ops = ["5","-2","4","C","D","9","+","+"]',output:"27"}]), hints: JSON.stringify(["A stack naturally supports the operations described: push new scores, pop for 'C'.","For '+', peek at the top two elements of the stack.","Process each operation in order, using the stack to track the current record."]), solution: "def cal_points(operations):\n    stack = []\n    for op in operations:\n        if op == 'C':\n            stack.pop()\n        elif op == 'D':\n            stack.append(2 * stack[-1])\n        elif op == '+':\n            stack.append(stack[-1] + stack[-2])\n        else:\n            stack.append(int(op))\n    return sum(stack)", explanation: "Stack simulation: Use a stack to track the running record. Push numbers, pop for 'C', peek for 'D' and '+'. At the end, sum all remaining elements in the stack. O(n) time, O(n) space.", pattern: "Stack (Simulation)", order: 5 },
      { title: "Evaluate Reverse Polish Notation", slug: "evaluate-reverse-polish-notation", difficulty: "Medium", description: "You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation (postfix notation).\n\nEvaluate the expression and return the result as an integer. The valid operators are '+', '-', '*', and '/'. Each operand may be an integer or another expression. Division between two integers truncates toward zero.", examples: JSON.stringify([{input:'tokens = ["2","1","+","3","*"]',output:"9",explanation:"((2 + 1) * 3) = 9"},{input:'tokens = ["4","13","5","/","+"]',output:"6",explanation:"(4 + (13 / 5)) = 6"}]), hints: JSON.stringify(["In postfix notation, an operator acts on the two most recent operands.","Use a stack to hold operands. When you see an operator, pop two operands, compute, and push the result.","Be careful with integer division truncating toward zero in Python (use int(a/b) not a//b for negative numbers)."]), solution: "def eval_rpn(tokens):\n    stack = []\n    for token in tokens:\n        if token in '+-*/':\n            b, a = stack.pop(), stack.pop()\n            if token == '+': stack.append(a + b)\n            elif token == '-': stack.append(a - b)\n            elif token == '*': stack.append(a * b)\n            else: stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[0]", explanation: "Stack evaluation: Push numbers onto the stack. When an operator is encountered, pop two operands, apply the operator, and push the result. The final value on the stack is the answer. O(n) time, O(n) space.", pattern: "Stack (Expression Evaluation)", order: 6 },
      { title: "Generate Parentheses", slug: "generate-parentheses", difficulty: "Medium", description: "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\nFor example, given n = 3, the result should include strings like '((()))', '(()())', '(())()', '()(())', '()()()'.", examples: JSON.stringify([{input:"n = 3",output:'["((()))","(()())","(())()","()(())","()()()"]'},{input:"n = 1",output:'["()"]'}]), hints: JSON.stringify(["At each step, you can add '(' if you haven't used all n opening parens.","You can add ')' only if the count of closing parens used is less than opening parens used.","Use backtracking/recursion, tracking the count of open and close parentheses."]), solution: "def generate_parenthesis(n):\n    result = []\n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    backtrack('', 0, 0)\n    return result", explanation: "Backtracking with stack-like logic: Build strings character by character. Add '(' if we have remaining opens, add ')' only if closes < opens (ensuring validity). The implicit stack of open parens guides the generation. O(4^n / sqrt(n)) time (Catalan number).", pattern: "Stack (Matching/Parsing)", order: 7 },
      { title: "Car Fleet", slug: "car-fleet", difficulty: "Medium", description: "There are n cars going to the same destination along a one-lane road. You are given two integer arrays position and speed, both of length n, where position[i] is the position of the ith car and speed[i] is the speed of the ith car (in units per hour).\n\nA car can never pass another car ahead of it, but it can catch up and then travel at the same speed as the car ahead. A car fleet is some non-empty set of cars driving at the same position and speed. A single car is also a fleet.\n\nReturn the number of car fleets that will arrive at the target destination.", examples: JSON.stringify([{input:"target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",output:"3",explanation:"Cars at positions 10 and 8 form a fleet, car at 0 is alone, cars at 5 and 3 form a fleet"},{input:"target = 10, position = [3], speed = [3]",output:"1"}]), hints: JSON.stringify(["Sort cars by position in descending order (closest to target first).","Calculate the time each car takes to reach the target.","If a car behind takes less or equal time than the car ahead, they merge into one fleet. Use a stack."]), solution: "def car_fleet(target, position, speed):\n    pairs = sorted(zip(position, speed), reverse=True)\n    stack = []\n    for pos, spd in pairs:\n        time = (target - pos) / spd\n        if not stack or time > stack[-1]:\n            stack.append(time)\n    return len(stack)", explanation: "Monotonic Stack on arrival times: Sort cars by position (descending). Calculate each car's arrival time. If a car arrives faster than or equal to the car ahead, it merges into that fleet. Otherwise, it starts a new fleet. The stack tracks distinct fleet arrival times. O(n log n) time.", pattern: "Monotonic Stack", order: 8 },
      { title: "Largest Rectangle in Histogram", slug: "largest-rectangle-histogram", difficulty: "Hard", description: "Given an array of integers heights representing the histogram's bar heights where the width of each bar is 1, return the area of the largest rectangle in the histogram.\n\nThe rectangle must be formed by contiguous bars.", examples: JSON.stringify([{input:"heights = [2,1,5,6,2,3]",output:"10",explanation:"The largest rectangle has area = 5 * 2 = 10 (bars at index 2 and 3 with height 5)"},{input:"heights = [2,4]",output:"4"}]), hints: JSON.stringify(["For each bar, find how far left and right it can extend (while all bars are >= its height).","A monotonic increasing stack can help find the boundaries efficiently.","When a bar is shorter than the top of the stack, the top bar's rectangle is bounded."]), solution: "def largest_rectangle_area(heights):\n    stack = []  # indices\n    max_area = 0\n    for i, h in enumerate(heights):\n        start = i\n        while stack and stack[-1][1] > h:\n            idx, height = stack.pop()\n            max_area = max(max_area, height * (i - idx))\n            start = idx\n        stack.append((start, h))\n    for idx, height in stack:\n        max_area = max(max_area, height * (len(heights) - idx))\n    return max_area", explanation: "Monotonic Increasing Stack: Maintain a stack of (index, height) pairs in increasing order. When a shorter bar is encountered, pop taller bars and compute their max rectangle (they can't extend further right). After processing all bars, remaining bars extend to the end. O(n) time.", pattern: "Monotonic Stack", order: 9 },
      { title: "Trapping Rain Water", slug: "trapping-rain-water-stack", difficulty: "Hard", description: "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\nWater is trapped between bars where shorter bars are flanked by taller bars on both sides.", examples: JSON.stringify([{input:"height = [0,1,0,2,1,0,1,3,2,1,2,1]",output:"6",explanation:"6 units of rain water are trapped between the bars"},{input:"height = [4,2,0,3,2,5]",output:"9"}]), hints: JSON.stringify(["A monotonic decreasing stack can identify 'valleys' where water can be trapped.","When you encounter a bar taller than the stack top, water can be trapped between the current bar and the bar below the top.","Pop the top, compute the bounded water using the width and the minimum of the two bounding heights minus the popped height."]), solution: "def trap(height):\n    stack = []  # indices\n    water = 0\n    for i, h in enumerate(height):\n        while stack and height[stack[-1]] < h:\n            bottom = height[stack.pop()]\n            if not stack:\n                break\n            width = i - stack[-1] - 1\n            bounded_height = min(h, height[stack[-1]]) - bottom\n            water += width * bounded_height\n        stack.append(i)\n    return water", explanation: "Monotonic Decreasing Stack: Maintain a stack of indices in decreasing height order. When a taller bar is found, pop the valley bottom and compute trapped water between the current bar and the new stack top. Width is the horizontal distance between them. O(n) time, O(n) space.", pattern: "Monotonic Stack", order: 10 },
    ]},
  };
}
