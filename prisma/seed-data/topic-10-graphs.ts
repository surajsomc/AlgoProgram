export function getGraphsData() {
  return {
    name: "Graphs",
    slug: "graphs",
    description: "BFS for shortest paths, DFS for exploring all paths and connectivity, topological sort for ordering dependencies.",
    icon: "üï∏Ô∏è", order: 10,
    concepts: { create: [
      { title: "Graph BFS", content: "Breadth-first search explores nodes level by level using a queue. In unweighted graphs, BFS finds the shortest path.\n\nPattern: add start to queue + visited set. Process each node, add unvisited neighbors to queue.", timeComplexity: "O(V + E)", spaceComplexity: "O(V)", whenToUse: "Shortest path in unweighted graph, minimum steps/moves, level-by-level exploration.", codeExample: "from collections import deque\ndef bfs_shortest_path(graph, start, end):\n    queue = deque([(start, 0)])\n    visited = {start}\n    while queue:\n        node, dist = queue.popleft()\n        if node == end: return dist\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    return -1", flashcardFront: "When should you use BFS on a graph, and why does it find shortest paths in unweighted graphs?", flashcardBack: "Use BFS when you need the shortest path in an unweighted graph, minimum steps/moves, or level-by-level exploration. BFS finds shortest paths because it explores all nodes at distance d before any node at distance d+1. The queue (FIFO) ensures this ordering. Time: O(V + E), Space: O(V). Always mark nodes as visited WHEN ADDING to the queue (not when processing) to avoid duplicates.", order: 1 },
      { title: "Graph DFS", content: "Depth-first search explores as deep as possible before backtracking. Use recursion or an explicit stack.\n\nGood for: finding all paths, connected components, cycle detection, topological ordering.", timeComplexity: "O(V + E)", spaceComplexity: "O(V)", whenToUse: "Connected components, cycle detection, all paths, topological sort, island counting.", codeExample: "def count_islands(grid):\n    def dfs(r, c):\n        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n            return\n        if grid[r][c] != '1': return\n        grid[r][c] = '0'\n        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n            dfs(r+dr, c+dc)\n    \n    count = 0\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1\n    return count", flashcardFront: "What are the key differences between DFS and BFS on graphs, and when do you choose each?", flashcardBack: "DFS goes as deep as possible before backtracking (uses stack/recursion). Use for: connected components, cycle detection, topological sort, finding all paths, and problems where you need to explore entire subtrees. BFS explores level by level (uses queue). Use for: shortest path in unweighted graphs, minimum steps, and when you need to process nodes by distance. Both are O(V + E) time. DFS uses O(V) stack space; BFS uses O(V) queue space.", order: 2 },
      { title: "Topological Sort", content: "Topological sort orders nodes in a directed acyclic graph (DAG) such that for every edge u->v, u comes before v.\n\nKahn's algorithm (BFS): Start with nodes having in-degree 0. Process them, decrement neighbors' in-degrees. If a neighbor reaches in-degree 0, add to queue. If not all nodes are processed, there is a cycle.\n\nDFS approach: Post-order DFS, then reverse. Nodes added after all descendants are processed.", timeComplexity: "O(V + E)", spaceComplexity: "O(V + E)", whenToUse: "Task scheduling with dependencies, course prerequisites, build systems, detecting cycles in directed graphs.", codeExample: "from collections import deque\ndef topological_sort(num_nodes, edges):\n    graph = [[] for _ in range(num_nodes)]\n    in_degree = [0] * num_nodes\n    for u, v in edges:\n        graph[u].append(v)\n        in_degree[v] += 1\n    queue = deque(i for i in range(num_nodes) if in_degree[i] == 0)\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return order if len(order) == num_nodes else []", flashcardFront: "What is topological sort and how does Kahn's algorithm work?", flashcardBack: "Topological sort linearly orders vertices of a DAG so that for every directed edge u->v, u comes before v. Kahn's algorithm (BFS-based): 1) Compute in-degree of all nodes. 2) Add all nodes with in-degree 0 to a queue. 3) Process each node: add to result, decrement in-degree of its neighbors. 4) If a neighbor's in-degree reaches 0, add to queue. 5) If result length != number of nodes, a cycle exists. Time: O(V + E).", order: 3 },
    ]},
    problems: { create: [
      // === Existing 3 problems ===
      { title: "Number of Islands", slug: "number-of-islands", difficulty: "Medium", description: "Given an m x n 2D grid of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and formed by connecting adjacent land cells horizontally or vertically.", examples: JSON.stringify([{input:'grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]',output:"3"}]), hints: JSON.stringify(["Each island is a connected component of '1's.","When you find a '1', explore all connected '1's (DFS/BFS) and mark them visited.","Count how many times you start a new exploration."]), solution: "def num_islands(grid):\n    def dfs(r, c):\n        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n            return\n        if grid[r][c] != '1': return\n        grid[r][c] = '0'\n        dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1)\n    \n    count = 0\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1\n    return count", explanation: "Graph DFS: Treat the grid as a graph. For each unvisited '1', run DFS to mark all connected land as visited. Each DFS call = one island. O(m*n) time.", pattern: "Graph DFS", order: 1 },
      { title: "Clone Graph", slug: "clone-graph", difficulty: "Medium", description: "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node has a value and a list of neighbors.", examples: JSON.stringify([{input:"adjList = [[2,4],[1,3],[2,4],[1,3]]",output:"[[2,4],[1,3],[2,4],[1,3]]",explanation:"Deep copy of the graph"}]), hints: JSON.stringify(["You need to create new nodes and map old nodes to new ones.","Use a hash map to track which nodes have been cloned.","DFS or BFS: for each node, clone it, then recursively clone its neighbors."]), solution: "def clone_graph(node):\n    if not node: return None\n    cloned = {}\n    def dfs(n):\n        if n in cloned: return cloned[n]\n        copy = Node(n.val)\n        cloned[n] = copy\n        for neighbor in n.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        return copy\n    return dfs(node)", explanation: "Graph DFS with hash map: Clone each node, store the mapping old->new. When visiting a neighbor, if already cloned, use the clone. Otherwise, recurse. O(V+E) time.", pattern: "Graph DFS", order: 2 },
      { title: "Course Schedule", slug: "course-schedule", difficulty: "Medium", description: "There are numCourses courses labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates you must take course bi before course ai.\n\nReturn true if you can finish all courses (i.e., no circular dependency).", examples: JSON.stringify([{input:"numCourses = 2, prerequisites = [[1,0]]",output:"true"},{input:"numCourses = 2, prerequisites = [[1,0],[0,1]]",output:"false",explanation:"Circular dependency"}]), hints: JSON.stringify(["This is a directed graph. Courses are nodes, prerequisites are edges.","You can finish all courses if and only if there's no cycle.","Use topological sort (BFS with in-degree counting) or DFS cycle detection."]), solution: "from collections import deque\ndef can_finish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        in_degree[a] += 1\n    queue = deque(i for i in range(numCourses) if in_degree[i] == 0)\n    count = 0\n    while queue:\n        node = queue.popleft()\n        count += 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return count == numCourses", explanation: "Topological Sort (Kahn's BFS): Build adjacency list and count in-degrees. Start with nodes having in-degree 0. Process them, decrement neighbors' in-degrees. If all nodes processed, no cycle exists. O(V+E).", pattern: "Topological Sort", order: 3 },
      // === New problems: 4E + 3M + 2H to reach 4E/6M/2H total ===
      { title: "Find if Path Exists in Graph", slug: "find-path-exists-graph", difficulty: "Easy", description: "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented as a 2D integer array edges where each edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi.\n\nDetermine if there is a valid path from source to destination.", examples: JSON.stringify([{input:"n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2",output:"true",explanation:"There are two paths: 0 -> 1 -> 2 and 0 -> 2"},{input:"n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5",output:"false",explanation:"No path exists between vertex 0 and vertex 5"}]), hints: JSON.stringify(["Build an adjacency list from the edges.","Use BFS or DFS starting from the source node.","Track visited nodes to avoid cycles. If you reach the destination, return true."]), solution: "from collections import deque, defaultdict\ndef valid_path(n, edges, source, destination):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = {source}\n    queue = deque([source])\n    while queue:\n        node = queue.popleft()\n        if node == destination:\n            return True\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    return False", explanation: "BFS traversal: Build an adjacency list, then BFS from source. If destination is reached, return true. Otherwise, after exhausting the BFS, return false. O(V + E) time, O(V + E) space.", pattern: "Graph BFS", order: 4 },
      { title: "Find Center of Star Graph", slug: "find-center-star-graph", difficulty: "Easy", description: "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\n\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.", examples: JSON.stringify([{input:"edges = [[1,2],[2,3],[4,2]]",output:"2",explanation:"Node 2 is connected to every other node, so 2 is the center"},{input:"edges = [[1,2],[5,1],[1,3],[1,4]]",output:"1"}]), hints: JSON.stringify(["The center node appears in every edge.","You only need to check the first two edges to find the center.","The common node in the first two edges is the center."]), solution: "def find_center(edges):\n    if edges[0][0] in edges[1]:\n        return edges[0][0]\n    return edges[0][1]", explanation: "Observation: The center node must appear in every edge. Check the first two edges and return the node that appears in both. O(1) time, O(1) space.", pattern: "Graph Property", order: 5 },
      { title: "Flood Fill", slug: "flood-fill", difficulty: "Easy", description: "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color.\n\nPerform a flood fill on the image starting from the pixel image[sr][sc]. Change the color of the starting pixel and all connected pixels that share the same original color to the given color. Two pixels are connected if they are adjacent horizontally or vertically and share the same color.\n\nReturn the modified image.", examples: JSON.stringify([{input:"image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2",output:"[[2,2,2],[2,2,0],[2,0,1]]",explanation:"Starting from (1,1), all connected pixels with value 1 are changed to 2"},{input:"image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0",output:"[[0,0,0],[0,0,0]]"}]), hints: JSON.stringify(["This is a connected component problem -- find all pixels connected to the start with the same color.","Use DFS or BFS from the starting pixel.","Don't forget the edge case: if the starting pixel already has the target color, no work is needed."]), solution: "def flood_fill(image, sr, sc, color):\n    original = image[sr][sc]\n    if original == color:\n        return image\n    rows, cols = len(image), len(image[0])\n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if image[r][c] != original:\n            return\n        image[r][c] = color\n        dfs(r+1, c); dfs(r-1, c); dfs(r, c+1); dfs(r, c-1)\n    dfs(sr, sc)\n    return image", explanation: "Graph DFS on grid: Start from (sr, sc) and DFS to all connected pixels with the same original color, changing each to the new color. The early return when original == color prevents infinite recursion. O(m * n) time.", pattern: "Graph DFS", order: 6 },
      { title: "Surrounded Regions", slug: "surrounded-regions", difficulty: "Easy", description: "Given an m x n matrix board containing 'X' and 'O', capture all regions that are completely surrounded by 'X'.\n\nA region is captured by flipping all 'O's into 'X's in that surrounded region. An 'O' cell is NOT surrounded if it is on the border or connected to a border 'O' cell.", examples: JSON.stringify([{input:'board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]',output:'[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]',explanation:"The bottom-left O is on the border so it stays. The inner Os are surrounded and get captured."},{input:'board = [["X"]]',output:'[["X"]]'}]), hints: JSON.stringify(["Instead of finding surrounded regions, find UNsurrounded ones (connected to border).","DFS/BFS from all border 'O' cells and mark them as safe.","After marking, any remaining 'O' is surrounded and should be flipped to 'X'."]), solution: "def solve(board):\n    if not board:\n        return\n    rows, cols = len(board), len(board[0])\n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if board[r][c] != 'O':\n            return\n        board[r][c] = 'S'  # safe\n        dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1)\n    # Mark border-connected O's as safe\n    for r in range(rows):\n        for c in range(cols):\n            if (r in (0, rows-1) or c in (0, cols-1)) and board[r][c] == 'O':\n                dfs(r, c)\n    # Flip remaining O's to X, restore S to O\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == 'O':\n                board[r][c] = 'X'\n            elif board[r][c] == 'S':\n                board[r][c] = 'O'", explanation: "Reverse thinking with DFS: Instead of finding surrounded regions, find the unsurrounded ones. DFS from all border 'O' cells, marking them as safe ('S'). Then flip all remaining 'O' to 'X' (they are surrounded) and restore 'S' back to 'O'. O(m * n) time.", pattern: "Graph DFS", order: 7 },
      { title: "Course Schedule II", slug: "course-schedule-ii", difficulty: "Medium", description: "There are numCourses courses labeled 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates you must take course bi before ai.\n\nReturn the ordering of courses you should take to finish all courses. If there are multiple valid orderings, return any of them. If it is impossible to finish all courses, return an empty array.", examples: JSON.stringify([{input:"numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",output:"[0,1,2,3] or [0,2,1,3]",explanation:"Take 0 first, then 1 and 2 in either order, then 3"},{input:"numCourses = 1, prerequisites = []",output:"[0]"}]), hints: JSON.stringify(["This is the same as Course Schedule but you need to return the actual ordering.","Use topological sort and record the order in which nodes are processed.","If the result has fewer nodes than numCourses, a cycle exists."]), solution: "from collections import deque\ndef find_order(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        in_degree[a] += 1\n    queue = deque(i for i in range(numCourses) if in_degree[i] == 0)\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return order if len(order) == numCourses else []", explanation: "Topological Sort (Kahn's BFS): Same as Course Schedule, but record the processing order. Start with in-degree 0 nodes, process them, and add neighbors that reach in-degree 0. The processing order is a valid topological ordering. O(V + E) time.", pattern: "Topological Sort", order: 8 },
      { title: "Pacific Atlantic Water Flow", slug: "pacific-atlantic-water-flow", difficulty: "Medium", description: "There is an m x n rectangular island that borders both the Pacific Ocean (top and left edges) and the Atlantic Ocean (bottom and right edges).\n\nWater can flow from a cell to an adjacent cell (up, down, left, right) if the adjacent cell's height is less than or equal to the current cell's height. Water can also flow into the ocean from cells adjacent to the ocean.\n\nReturn a list of all cells where water can flow to both the Pacific and Atlantic oceans.", examples: JSON.stringify([{input:"heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",output:"[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",explanation:"These cells can reach both the Pacific (top/left) and Atlantic (bottom/right) oceans"},{input:"heights = [[1]]",output:"[[0,0]]"}]), hints: JSON.stringify(["Instead of flowing water downhill from each cell, think in reverse: flow uphill from the oceans.","Do DFS/BFS from all Pacific border cells and mark which cells can reach the Pacific.","Do the same from Atlantic border cells. The intersection gives cells that reach both."]), solution: "def pacific_atlantic(heights):\n    if not heights:\n        return []\n    rows, cols = len(heights), len(heights[0])\n    pacific = set()\n    atlantic = set()\n    \n    def dfs(r, c, reachable, prev_height):\n        if (r, c) in reachable or r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        if heights[r][c] < prev_height:\n            return\n        reachable.add((r, c))\n        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n            dfs(r+dr, c+dc, reachable, heights[r][c])\n    \n    for c in range(cols):\n        dfs(0, c, pacific, heights[0][c])\n        dfs(rows-1, c, atlantic, heights[rows-1][c])\n    for r in range(rows):\n        dfs(r, 0, pacific, heights[r][0])\n        dfs(r, cols-1, atlantic, heights[r][cols-1])\n    \n    return list(pacific & atlantic)", explanation: "Reverse DFS from ocean borders: Instead of checking each cell, DFS from ocean borders going uphill (to cells with equal or greater height). Track which cells reach each ocean. The intersection of both sets is the answer. O(m * n) time.", pattern: "Graph DFS", order: 9 },
      { title: "Rotting Oranges", slug: "rotting-oranges", difficulty: "Medium", description: "You are given an m x n grid where each cell can have one of three values:\n- 0 representing an empty cell\n- 1 representing a fresh orange\n- 2 representing a rotten orange\n\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.", examples: JSON.stringify([{input:"grid = [[2,1,1],[1,1,0],[0,1,1]]",output:"4",explanation:"After 4 minutes, all oranges are rotten"},{input:"grid = [[2,1,1],[0,1,1],[1,0,1]]",output:"-1",explanation:"The bottom-left orange can never be reached"}]), hints: JSON.stringify(["This is a multi-source BFS problem. All rotten oranges spread simultaneously.","Start BFS from all initially rotten oranges at the same time.","Track the number of BFS levels (minutes). At the end, check if any fresh oranges remain."]), solution: "from collections import deque\ndef oranges_rotting(grid):\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    fresh = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 2:\n                queue.append((r, c))\n            elif grid[r][c] == 1:\n                fresh += 1\n    if fresh == 0:\n        return 0\n    minutes = 0\n    while queue:\n        minutes += 1\n        for _ in range(len(queue)):\n            r, c = queue.popleft()\n            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n                nr, nc = r+dr, c+dc\n                if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n        if fresh == 0:\n            return minutes\n    return -1", explanation: "Multi-source BFS: Start BFS from all rotten oranges simultaneously (add all to queue initially). Each BFS level represents one minute. Count fresh oranges; when all are rotten, return the minutes. If fresh > 0 after BFS, return -1. O(m * n) time.", pattern: "Graph BFS", order: 10 },
      { title: "Word Ladder", slug: "word-ladder", difficulty: "Hard", description: "A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\n- Every adjacent pair of words differs by a single letter.\n- Every si is in wordList. Note that beginWord does not need to be in wordList.\n- sk == endWord\n\nGiven two words and a word list, return the number of words in the shortest transformation sequence, or 0 if no such sequence exists.", examples: JSON.stringify([{input:'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]',output:"5",explanation:'One shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog", which is 5 words'},{input:'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]',output:"0",explanation:"The endWord 'cog' is not in wordList"}]), hints: JSON.stringify(["This is a shortest path problem in an unweighted graph. Use BFS.","Each word is a node. Two words are connected if they differ by exactly one letter.","To find neighbors efficiently, try replacing each character with every letter a-z."]), solution: "from collections import deque\ndef ladder_length(beginWord, endWord, wordList):\n    word_set = set(wordList)\n    if endWord not in word_set:\n        return 0\n    queue = deque([(beginWord, 1)])\n    visited = {beginWord}\n    while queue:\n        word, length = queue.popleft()\n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = word[:i] + c + word[i+1:]\n                if next_word == endWord:\n                    return length + 1\n                if next_word in word_set and next_word not in visited:\n                    visited.add(next_word)\n                    queue.append((next_word, length + 1))\n    return 0", explanation: "BFS shortest path: Treat each word as a graph node. Two words are adjacent if they differ by one letter. BFS from beginWord to endWord gives the shortest transformation sequence. Generate neighbors by trying all single-character substitutions. O(M^2 * N) time where M = word length, N = number of words.", pattern: "Graph BFS", order: 11 },
      { title: "Alien Dictionary", slug: "alien-dictionary", difficulty: "Hard", description: "There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings words from the alien language's dictionary, where the strings are sorted lexicographically by the rules of this new language.\n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid orderings, return any of them.", examples: JSON.stringify([{input:'words = ["wrt","wrf","er","ett","rftt"]',output:'"wertf"',explanation:"From comparing adjacent words: w->e, r->t, t->f, e->r. Order: w,e,r,t,f"},{input:'words = ["z","x"]',output:'"zx"',explanation:"z comes before x in the alien alphabet"}]), hints: JSON.stringify(["Compare adjacent words to extract ordering rules (which letter comes before which).","This gives you directed edges in a graph. The answer is a topological sort of this graph.","Watch for invalid cases: if a longer word appears before its prefix (e.g., 'abc' before 'ab')."]), solution: "from collections import deque, defaultdict\ndef alien_order(words):\n    # Build graph\n    graph = defaultdict(set)\n    in_degree = {c: 0 for word in words for c in word}\n    \n    for i in range(len(words) - 1):\n        w1, w2 = words[i], words[i+1]\n        min_len = min(len(w1), len(w2))\n        if len(w1) > len(w2) and w1[:min_len] == w2[:min_len]:\n            return ''  # invalid\n        for j in range(min_len):\n            if w1[j] != w2[j]:\n                if w2[j] not in graph[w1[j]]:\n                    graph[w1[j]].add(w2[j])\n                    in_degree[w2[j]] += 1\n                break\n    \n    # Topological sort\n    queue = deque(c for c in in_degree if in_degree[c] == 0)\n    result = []\n    while queue:\n        c = queue.popleft()\n        result.append(c)\n        for neighbor in graph[c]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    if len(result) < len(in_degree):\n        return ''  # cycle detected\n    return ''.join(result)", explanation: "Topological Sort on character graph: Compare adjacent words to find character ordering constraints (directed edges). Then topological sort the character graph. If a cycle is detected (not all characters processed), the ordering is invalid. O(C) time where C is total characters in all words.", pattern: "Topological Sort", order: 12 },
    ]},
  };
}
