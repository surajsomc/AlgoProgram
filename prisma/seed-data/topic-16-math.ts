export function getMathData() {
  return {
    name: "Math & Geometry",
    slug: "math-and-geometry",
    description: "Mathematical patterns, modular arithmetic, matrix operations, and geometric reasoning.",
    icon: "\uD83D\uDD3A", order: 16,
    concepts: { create: [
      { title: "Matrix Operations", content: "Common matrix tricks:\n- Matrix rotation: transpose + reverse rows (90\u00B0 clockwise)\n- Spiral traversal: maintain boundaries, shrink after each direction\n- Set matrix zeroes: record which rows/cols to zero using first row/col as markers\n\nKey insight: in-place matrix transformations often use the matrix itself as storage for metadata.", timeComplexity: "O(m*n)", spaceComplexity: "O(1) for in-place", whenToUse: "Problems involving 2D grids, image rotation, spiral traversal, or zeroing rows/columns.", codeExample: "def rotate_matrix(matrix):\n    n = len(matrix)\n    # Transpose\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse each row\n    for row in matrix:\n        row.reverse()", flashcardFront: "How do you rotate an n x n matrix 90 degrees clockwise in-place?", flashcardBack: "Transpose the matrix (swap matrix[i][j] with matrix[j][i]), then reverse each row. This achieves 90-degree clockwise rotation in O(n^2) time and O(1) space.", order: 1 },
      { title: "Number Theory Patterns", content: "Common math tricks for coding problems:\n- GCD via Euclidean algorithm: gcd(a, b) = gcd(b, a % b)\n- Power of 2 check: n > 0 and n & (n-1) == 0\n- Modular arithmetic: (a + b) % m = ((a % m) + (b % m)) % m\n- Sieve of Eratosthenes for primes up to n in O(n log log n)\n- Happy number detection: use Floyd's cycle detection on the digit-square sequence", timeComplexity: "Varies", spaceComplexity: "Varies", whenToUse: "Problems involving primes, GCD/LCM, powers, digit manipulation, or cyclic number sequences.", codeExample: "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef sieve(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n+1, i):\n                is_prime[j] = False\n    return [i for i in range(n+1) if is_prime[i]]", flashcardFront: "What is the Euclidean algorithm for computing GCD and what is its time complexity?", flashcardBack: "gcd(a, b) = gcd(b, a % b), with base case gcd(a, 0) = a. Time complexity is O(log(min(a, b))). This is the foundation for LCM: lcm(a, b) = a * b / gcd(a, b).", order: 2 },
      { title: "Geometric Reasoning", content: "Geometry problems in coding interviews:\n- Distance formula: sqrt((x2-x1)^2 + (y2-y1)^2)\n- To avoid floating point, compare squared distances\n- Cross product for orientation: positive = counterclockwise, negative = clockwise, zero = collinear\n- Area of triangle with vertices: 0.5 * |x1(y2-y3) + x2(y3-y1) + x3(y1-y2)|", timeComplexity: "Varies", spaceComplexity: "O(1) typically", whenToUse: "Problems involving points, distances, areas, or determining if points are collinear.", codeExample: "def dist_squared(p1, p2):\n    return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2\n\ndef cross_product(o, a, b):\n    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])", flashcardFront: "Why should you compare squared distances instead of actual distances in geometry problems?", flashcardBack: "Comparing squared distances avoids floating-point precision issues from the square root operation. Since sqrt is monotonic, if a^2 < b^2 (for non-negative values), then a < b. This keeps all computations in integers.", order: 3 },
    ]},
    problems: { create: [
      { title: "Rotate Image", slug: "rotate-image", difficulty: "Medium", description: "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees clockwise. You have to rotate it in-place.", examples: JSON.stringify([{input:"matrix = [[1,2,3],[4,5,6],[7,8,9]]",output:"[[7,4,1],[8,5,2],[9,6,3]]"},{input:"matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",output:"[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"}]), hints: JSON.stringify(["90\u00B0 clockwise rotation = transpose + reverse each row.","Transpose: swap matrix[i][j] with matrix[j][i].","Then reverse each row."]), solution: "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for row in matrix:\n        row.reverse()", explanation: "Math / Matrix: 90\u00B0 clockwise = transpose + reverse rows. Transpose swaps across the diagonal. Both operations are in-place. O(n\u00B2) time, O(1) space.", pattern: "Matrix Manipulation", order: 1 },
      { title: "Spiral Matrix", slug: "spiral-matrix", difficulty: "Medium", description: "Given an m x n matrix, return all elements of the matrix in spiral order (clockwise from the outside in).", examples: JSON.stringify([{input:"matrix = [[1,2,3],[4,5,6],[7,8,9]]",output:"[1,2,3,6,9,8,7,4,5]"},{input:"matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",output:"[1,2,3,4,8,12,11,10,9,5,6,7]"}]), hints: JSON.stringify(["Maintain four boundaries: top, bottom, left, right.","Traverse right, down, left, up in order.","After each direction, shrink the corresponding boundary."]), solution: "def spiral_order(matrix):\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1):\n            result.append(matrix[top][c])\n        top += 1\n        for r in range(top, bottom + 1):\n            result.append(matrix[r][right])\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1):\n                result.append(matrix[bottom][c])\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1):\n                result.append(matrix[r][left])\n            left += 1\n    return result", explanation: "Boundary shrinking: Maintain top/bottom/left/right boundaries. Traverse in spiral order, shrinking boundaries after each direction. O(m*n) time.", pattern: "Matrix Manipulation", order: 2 },
      { title: "Happy Number", slug: "happy-number", difficulty: "Easy", description: "Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n\nReturn true if n is a happy number, false otherwise.", examples: JSON.stringify([{input:"n = 19",output:"true",explanation:"1^2 + 9^2 = 82, 8^2 + 2^2 = 68, 6^2 + 8^2 = 100, 1^2 + 0^2 + 0^2 = 1"},{input:"n = 2",output:"false"}]), hints: JSON.stringify(["Compute the sum of squares of digits repeatedly.","The process either reaches 1 or enters a cycle.","Use a set to detect cycles, or use Floyd's cycle detection (fast/slow pointers)."]), solution: "def is_happy(n):\n    def get_next(num):\n        total = 0\n        while num > 0:\n            num, digit = divmod(num, 10)\n            total += digit ** 2\n        return total\n    \n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = get_next(n)\n    return n == 1", explanation: "Digit manipulation + cycle detection: Repeatedly compute sum of squared digits. Use a hash set to detect if we enter a cycle. If we reach 1, it's happy. O(log n) per step, terminates in bounded steps.", pattern: "Math", order: 3 },
      { title: "Plus One", slug: "plus-one", difficulty: "Easy", description: "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant. Increment the large integer by one and return the resulting array of digits.", examples: JSON.stringify([{input:"digits = [1,2,3]",output:"[1,2,4]",explanation:"The array represents 123. 123 + 1 = 124."},{input:"digits = [9,9,9]",output:"[1,0,0,0]",explanation:"999 + 1 = 1000."}]), hints: JSON.stringify(["Start from the last digit and add one.","If a digit becomes 10, set it to 0 and carry 1 to the next digit.","If after processing all digits there's still a carry, prepend 1."]), solution: "def plus_one(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n    return [1] + digits", explanation: "Carry propagation: Start from the rightmost digit. If it's less than 9, increment and return. If it's 9, set to 0 and carry. If all digits were 9, prepend 1. O(n) time, O(1) space (ignoring output).", pattern: "Math", order: 4 },
      { title: "Count Primes", slug: "count-primes", difficulty: "Easy", description: "Given an integer n, return the number of prime numbers that are strictly less than n.", examples: JSON.stringify([{input:"n = 10",output:"4",explanation:"There are 4 primes less than 10: 2, 3, 5, 7."},{input:"n = 0",output:"0"},{input:"n = 1",output:"0"}]), hints: JSON.stringify(["Checking each number for primality is too slow.","Sieve of Eratosthenes: mark multiples of each prime as composite.","Start marking from i*i since smaller multiples are already marked."]), solution: "def count_primes(n):\n    if n < 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)", explanation: "Sieve of Eratosthenes: Create a boolean array. For each prime i, mark all multiples starting from i*i as not prime. Count remaining True values. O(n log log n) time, O(n) space.", pattern: "Math", order: 5 },
      { title: "Set Matrix Zeroes", slug: "set-matrix-zeroes", difficulty: "Medium", description: "Given an m x n integer matrix, if an element is 0, set its entire row and column to 0. You must do it in-place.\n\nCan you solve it using O(1) extra space?", examples: JSON.stringify([{input:"matrix = [[1,1,1],[1,0,1],[1,1,1]]",output:"[[1,0,1],[0,0,0],[1,0,1]]"},{input:"matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",output:"[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"}]), hints: JSON.stringify(["You need to know which rows and columns should be zeroed before zeroing anything.","Use the first row and first column as markers to record which rows/cols contain zeros.","Handle the first row and column separately since they're used as markers."]), solution: "def set_zeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    first_row_zero = any(matrix[0][j] == 0 for j in range(n))\n    first_col_zero = any(matrix[i][0] == 0 for i in range(m))\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][j] == 0:\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n    \n    for i in range(1, m):\n        for j in range(1, n):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n    \n    if first_row_zero:\n        for j in range(n):\n            matrix[0][j] = 0\n    if first_col_zero:\n        for i in range(m):\n            matrix[i][0] = 0", explanation: "In-place markers: Use the first row and column to mark which rows/cols should be zeroed. First scan for zeros, mark in first row/col. Then zero based on markers. Handle first row/col separately. O(m*n) time, O(1) space.", pattern: "Matrix Manipulation", order: 6 },
      { title: "Pow(x, n)", slug: "pow-x-n", difficulty: "Hard", description: "Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).\n\nConstraints: -100.0 < x < 100.0, -2^31 <= n <= 2^31 - 1, n is an integer, and the result fits in a 64-bit floating point number.", examples: JSON.stringify([{input:"x = 2.00000, n = 10",output:"1024.00000"},{input:"x = 2.10000, n = 3",output:"9.26100"},{input:"x = 2.00000, n = -2",output:"0.25000"}]), hints: JSON.stringify(["Naive multiplication is O(n) which is too slow for large n.","Use fast exponentiation: x^n = (x^(n/2))^2 for even n.","Handle negative exponents: x^(-n) = 1 / x^n. Watch out for integer overflow with n = -2^31."]), solution: "def my_pow(x, n):\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    while n > 0:\n        if n % 2 == 1:\n            result *= x\n        x *= x\n        n //= 2\n    return result", explanation: "Fast exponentiation (binary exponentiation): Square x and halve n each step. If n is odd, multiply result by x. This reduces O(n) multiplications to O(log n). Handle negative n by inverting x.", pattern: "Math", order: 7 },
      { title: "Multiply Strings", slug: "multiply-strings", difficulty: "Hard", description: "Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nYou must not use any built-in BigInteger library or convert the inputs to integer directly.", examples: JSON.stringify([{input:'num1 = "2", num2 = "3"',output:'"6"'},{input:'num1 = "123", num2 = "456"',output:'"56088"'}]), hints: JSON.stringify(["Simulate grade-school multiplication.","The product of digit at index i and digit at index j contributes to position i+j and i+j+1 in the result.","Use an array of length m+n to store intermediate results, then handle carries."]), solution: "def multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    result = [0] * (m + n)\n    \n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            mul = int(num1[i]) * int(num2[j])\n            p1, p2 = i + j, i + j + 1\n            total = mul + result[p2]\n            result[p2] = total % 10\n            result[p1] += total // 10\n    \n    result_str = ''.join(map(str, result)).lstrip('0')\n    return result_str or '0'", explanation: "Grade-school multiplication: Multiply each digit pair and place the result at the correct position (i+j and i+j+1). Handle carries as you go. The result of multiplying an m-digit and n-digit number has at most m+n digits. O(m*n) time.", pattern: "Math", order: 8 },
    ]},
  };
}
