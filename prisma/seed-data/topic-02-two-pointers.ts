export function getTwoPointersData() {
  return {
    name: "Two Pointers",
    slug: "two-pointers",
    description: "Use two indices moving through a sorted array to solve problems in O(n) time and O(1) space.",
    icon: "\uD83D\uDC46", order: 2,
    concepts: { create: [
      {
        title: "Opposite Direction Pointers",
        content: "Place one pointer at the start and one at the end. Move them toward each other based on a condition.\n\nWorks on sorted arrays: if sum too small, move left pointer right. If too large, move right pointer left.\n\nKey insight: the sorted order lets you eliminate possibilities with each move.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(1)",
        whenToUse: "Sorted array + finding pairs that meet a condition. Also works for palindrome checking.",
        codeExample: "def two_sum_sorted(nums, target):\n    l, r = 0, len(nums) - 1\n    while l < r:\n        s = nums[l] + nums[r]\n        if s == target: return [l, r]\n        elif s < target: l += 1\n        else: r -= 1",
        flashcardFront: "When using opposite-direction two pointers on a sorted array, how do you decide which pointer to move?",
        flashcardBack: "If the current sum is too small, move the left pointer right to increase it. If too large, move the right pointer left to decrease it. The sorted order guarantees that moving left increases and moving right decreases the value at that pointer. This eliminates one candidate per step, giving O(n) time.",
        order: 1,
      },
      {
        title: "Same Direction Pointers",
        content: "Both pointers move in the same direction at different speeds or conditions. Used for removing duplicates in-place, partitioning arrays.\n\nSlow pointer marks the position to write, fast pointer scans ahead.",
        timeComplexity: "O(n)",
        spaceComplexity: "O(1)",
        whenToUse: "In-place array modifications, removing elements, partitioning.",
        codeExample: "def remove_duplicates(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1",
        flashcardFront: "In the slow/fast pointer technique for in-place array modification, what role does each pointer play?",
        flashcardBack: "The slow pointer marks the position where the next valid element should be written. The fast pointer scans ahead through the array to find valid elements. When the fast pointer finds a valid element, it is written at the slow pointer's position, and the slow pointer advances. This allows O(n) time, O(1) space modifications.",
        order: 2,
      },
    ]},
    problems: { create: [
      // ===== EXISTING 3 PROBLEMS =====
      {
        title: "Valid Palindrome",
        slug: "valid-palindrome",
        difficulty: "Easy",
        description: "Given a string s, return true if it is a palindrome after converting all uppercase letters to lowercase and removing all non-alphanumeric characters.",
        examples: JSON.stringify([
          { input: 's = "A man, a plan, a canal: Panama"', output: "true", explanation: '"amanaplanacanalpanama" is a palindrome' },
          { input: 's = "race a car"', output: "false" },
        ]),
        hints: JSON.stringify([
          "Use two pointers from both ends.",
          "Skip non-alphanumeric characters.",
          "Compare lowercase versions of characters at both pointers.",
        ]),
        solution: "def is_palindrome(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        while l < r and not s[l].isalnum(): l += 1\n        while l < r and not s[r].isalnum(): r -= 1\n        if s[l].lower() != s[r].lower():\n            return False\n        l += 1\n        r -= 1\n    return True",
        explanation: "Two pointers from opposite ends: Skip non-alphanumeric chars, compare lowercase chars moving inward. O(n) time, O(1) space.",
        pattern: "Two Pointers",
        order: 1,
      },
      {
        title: "3Sum",
        slug: "three-sum",
        difficulty: "Medium",
        description: "Given an integer array nums, return all triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nThe solution set must not contain duplicate triplets.",
        examples: JSON.stringify([
          { input: "nums = [-1,0,1,2,-1,-4]", output: "[[-1,-1,2],[-1,0,1]]" },
          { input: "nums = [0,1,1]", output: "[]" },
        ]),
        hints: JSON.stringify([
          "Sort the array first.",
          "Fix one element, then use two pointers on the remaining array to find pairs.",
          "Skip duplicates to avoid repeated triplets.",
        ]),
        solution: "def three_sum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                result.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]: l += 1\n                while l < r and nums[r] == nums[r-1]: r -= 1\n                l += 1; r -= 1\n    return result",
        explanation: "Sort + Two Pointers: Sort array, fix each element, then use two pointers on the rest to find pairs summing to the negative of the fixed element. Skip duplicates. O(n^2) time.",
        pattern: "Two Pointers",
        order: 2,
      },
      {
        title: "Container With Most Water",
        slug: "container-most-water",
        difficulty: "Medium",
        description: "You are given an integer array height of length n. There are n vertical lines drawn. Find two lines that together with the x-axis form a container that holds the most water.\n\nReturn the maximum amount of water a container can store.",
        examples: JSON.stringify([
          { input: "height = [1,8,6,2,5,4,8,3,7]", output: "49", explanation: "Lines at index 1 and 8 form a container with area = min(8,7) * (8-1) = 49" },
          { input: "height = [1,1]", output: "1" },
        ]),
        hints: JSON.stringify([
          "Start with the widest container (pointers at both ends).",
          "Area = min(height[l], height[r]) * (r - l). Width decreases as pointers move in.",
          "Move the pointer pointing to the shorter line -- keeping the shorter one can't help.",
        ]),
        solution: "def max_area(height):\n    l, r = 0, len(height) - 1\n    best = 0\n    while l < r:\n        area = min(height[l], height[r]) * (r - l)\n        best = max(best, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return best",
        explanation: "Two Pointers from opposite ends: Start wide, compute area at each step. Always move the shorter side inward since moving the taller side can only decrease area. O(n) time, O(1) space.",
        pattern: "Two Pointers",
        order: 3,
      },

      // ===== NEW PROBLEMS =====
      {
        title: "Remove Duplicates from Sorted Array",
        slug: "remove-duplicates-sorted-array",
        difficulty: "Easy",
        description: "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.\n\nReturn k after placing the final result in the first k slots of nums.",
        examples: JSON.stringify([
          { input: "nums = [1,1,2]", output: "2, nums = [1,2,_]", explanation: "Function returns k = 2, with the first two elements being 1 and 2." },
          { input: "nums = [0,0,1,1,1,2,2,3,3,4]", output: "5, nums = [0,1,2,3,4,_,_,_,_,_]" },
        ]),
        hints: JSON.stringify([
          "Use a slow pointer to track where the next unique element should go.",
          "Use a fast pointer to scan through the array.",
          "When the fast pointer finds a new value different from slow's value, copy it to slow+1.",
        ]),
        solution: "def remove_duplicates(nums):\n    if not nums:\n        return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1",
        explanation: "Same Direction Pointers: Slow pointer marks the end of the unique portion. Fast pointer scans ahead. When a new unique value is found, it is placed at slow+1. O(n) time, O(1) space.",
        pattern: "Two Pointers (Same Direction)",
        order: 4,
      },
      {
        title: "Two Sum II - Input Array Is Sorted",
        slug: "two-sum-ii-input-sorted",
        difficulty: "Easy",
        description: "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space.",
        examples: JSON.stringify([
          { input: "numbers = [2,7,11,15], target = 9", output: "[1,2]", explanation: "2 + 7 = 9, so index1 = 1, index2 = 2." },
          { input: "numbers = [2,3,4], target = 6", output: "[1,3]" },
          { input: "numbers = [-1,0], target = -1", output: "[1,2]" },
        ]),
        hints: JSON.stringify([
          "The array is sorted. Use two pointers at both ends.",
          "If the sum of two elements is less than target, move the left pointer to increase the sum.",
          "If the sum is greater, move the right pointer to decrease the sum.",
        ]),
        solution: "def two_sum(numbers, target):\n    l, r = 0, len(numbers) - 1\n    while l < r:\n        current_sum = numbers[l] + numbers[r]\n        if current_sum == target:\n            return [l + 1, r + 1]\n        elif current_sum < target:\n            l += 1\n        else:\n            r -= 1\n    return []",
        explanation: "Opposite Direction Pointers: Since the array is sorted, start with pointers at both ends. Move left pointer right if sum is too small, or right pointer left if too large. Guaranteed O(n) time, O(1) space.",
        pattern: "Two Pointers",
        order: 5,
      },
      {
        title: "3Sum Closest",
        slug: "three-sum-closest",
        difficulty: "Medium",
        description: "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n\nReturn the sum of the three integers. You may assume that each input would have exactly one solution.",
        examples: JSON.stringify([
          { input: "nums = [-1,2,1,-4], target = 1", output: "2", explanation: "The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)." },
          { input: "nums = [0,0,0], target = 1", output: "0" },
        ]),
        hints: JSON.stringify([
          "Sort the array first, similar to 3Sum.",
          "Fix one element, then use two pointers to find the closest pair sum.",
          "Track the closest sum seen so far and update it when a closer one is found.",
        ]),
        solution: "def three_sum_closest(nums, target):\n    nums.sort()\n    closest = float('inf')\n    for i in range(len(nums) - 2):\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if abs(s - target) < abs(closest - target):\n                closest = s\n            if s < target:\n                l += 1\n            elif s > target:\n                r -= 1\n            else:\n                return s\n    return closest",
        explanation: "Sort + Two Pointers: Same approach as 3Sum but instead of finding exact zero, track the sum closest to target. Move pointers based on comparison with target. O(n^2) time, O(1) space.",
        pattern: "Two Pointers",
        order: 6,
      },
      {
        title: "4Sum",
        slug: "four-sum",
        difficulty: "Medium",
        description: "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n- 0 <= a, b, c, d < n\n- a, b, c, d are distinct\n- nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.",
        examples: JSON.stringify([
          { input: "nums = [1,0,-1,0,-2,2], target = 0", output: "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]" },
          { input: "nums = [2,2,2,2,2], target = 8", output: "[[2,2,2,2]]" },
        ]),
        hints: JSON.stringify([
          "This extends the 3Sum pattern: fix two elements, then use two pointers for the remaining two.",
          "Sort the array first and use two nested loops, with two pointers inside.",
          "Skip duplicates at every level to avoid duplicate quadruplets.",
        ]),
        solution: "def four_sum(nums, target):\n    nums.sort()\n    result = []\n    n = len(nums)\n    for i in range(n - 3):\n        if i > 0 and nums[i] == nums[i-1]: continue\n        for j in range(i + 1, n - 2):\n            if j > i + 1 and nums[j] == nums[j-1]: continue\n            l, r = j + 1, n - 1\n            while l < r:\n                s = nums[i] + nums[j] + nums[l] + nums[r]\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]: l += 1\n                    while l < r and nums[r] == nums[r-1]: r -= 1\n                    l += 1; r -= 1\n    return result",
        explanation: "Sort + Two Pointers (extended): Fix two elements with nested loops, then use two pointers for the inner pair. Skip duplicates at all levels. O(n^3) time, O(1) space (excluding output).",
        pattern: "Two Pointers",
        order: 7,
      },
      {
        title: "Sort Colors",
        slug: "sort-colors-dutch-flag",
        difficulty: "Medium",
        description: "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red (0), white (1), and blue (2).\n\nYou must solve this problem without using the library's sort function.",
        examples: JSON.stringify([
          { input: "nums = [2,0,2,1,1,0]", output: "[0,0,1,1,2,2]" },
          { input: "nums = [2,0,1]", output: "[0,1,2]" },
        ]),
        hints: JSON.stringify([
          "This is the Dutch National Flag problem. Use three pointers.",
          "Maintain three regions: 0s (before low), 1s (between low and mid), 2s (after high).",
          "Iterate with mid pointer, swapping elements to the correct region.",
        ]),
        solution: "def sort_colors(nums):\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1",
        explanation: "Dutch National Flag (Three Pointers): Use low, mid, and high pointers. Swap 0s to the front (low), 2s to the back (high), and leave 1s in the middle. Single pass, O(n) time, O(1) space.",
        pattern: "Two Pointers (Partitioning)",
        order: 8,
      },
      {
        title: "Trapping Rain Water",
        slug: "trapping-rain-water",
        difficulty: "Hard",
        description: "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        examples: JSON.stringify([
          { input: "height = [0,1,0,2,1,0,1,3,2,1,2,1]", output: "6", explanation: "The elevation map traps 6 units of rain water." },
          { input: "height = [4,2,0,3,2,5]", output: "9" },
        ]),
        hints: JSON.stringify([
          "The water above each bar depends on the max height to its left and right.",
          "Water at position i = min(max_left, max_right) - height[i].",
          "Use two pointers from both ends, tracking max heights from each side.",
        ]),
        solution: "def trap(height):\n    l, r = 0, len(height) - 1\n    left_max = right_max = 0\n    water = 0\n    while l < r:\n        if height[l] < height[r]:\n            if height[l] >= left_max:\n                left_max = height[l]\n            else:\n                water += left_max - height[l]\n            l += 1\n        else:\n            if height[r] >= right_max:\n                right_max = height[r]\n            else:\n                water += right_max - height[r]\n            r -= 1\n    return water",
        explanation: "Two Pointers: Track left_max and right_max from both ends. The water at each position is determined by the smaller of the two max values. Process the side with the smaller max first, since the other side guarantees at least that height. O(n) time, O(1) space.",
        pattern: "Two Pointers",
        order: 9,
      },
      {
        title: "4Sum II",
        slug: "four-sum-ii",
        difficulty: "Hard",
        description: "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",
        examples: JSON.stringify([
          { input: "nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]", output: "2", explanation: "(0,0,0,1) -> 1+(-2)+(-1)+2=0 and (1,1,0,0) -> 2+(-1)+(-1)+0=0" },
          { input: "nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]", output: "1" },
        ]),
        hints: JSON.stringify([
          "Brute force is O(n^4). Can you reduce it?",
          "Compute all pairwise sums of nums1 and nums2, store in a hash map.",
          "For each pair sum of nums3 and nums4, check if the negation exists in the map.",
        ]),
        solution: "from collections import Counter\ndef four_sum_count(nums1, nums2, nums3, nums4):\n    sum_ab = Counter()\n    for a in nums1:\n        for b in nums2:\n            sum_ab[a + b] += 1\n    count = 0\n    for c in nums3:\n        for d in nums4:\n            count += sum_ab.get(-(c + d), 0)\n    return count",
        explanation: "Hash Map Split: Split four arrays into two groups. Compute all sums of the first two arrays and store counts in a hash map. For each sum from the last two arrays, look up the complement. O(n^2) time, O(n^2) space.",
        pattern: "Hash Map / Two Pointers",
        order: 10,
      },
    ]},
  };
}
