export function getBitManipulationData() {
  return {
    name: "Bit Manipulation",
    slug: "bit-manipulation",
    description: "Use binary operations (AND, OR, XOR, shift) for efficient solutions. XOR is especially useful for finding unique elements.",
    icon: "ðŸ’»", order: 15,
    concepts: { create: [
      { title: "Bit Operations", content: "Key operations:\n- XOR (^): same bits -> 0, different -> 1. a ^ a = 0, a ^ 0 = a\n- AND (&): both 1 -> 1. Clear bits, check if bit is set\n- OR (|): either 1 -> 1. Set bits\n- Left shift (<<): multiply by 2\n- Right shift (>>): divide by 2\n- n & (n-1): removes lowest set bit\n\nXOR trick: XOR all elements. Duplicates cancel out, leaving the unique one.", timeComplexity: "O(n) for linear scan", spaceComplexity: "O(1)", whenToUse: "Find single/unique numbers among duplicates, check powers of 2, count set bits, toggle bits.", codeExample: "def single_number(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", flashcardFront: "What are the key bit manipulation operations and their common uses?", flashcardBack: "XOR (^): a^a=0, a^0=a -- find unique elements. AND (&): check/clear bits, n&(n-1) removes lowest set bit. OR (|): set bits. Left shift (<<): multiply by 2. Right shift (>>): divide by 2. Common uses: find unique numbers (XOR all), check power of 2 (n & (n-1) == 0), count set bits (repeatedly clear lowest).", order: 1 },
      { title: "Bit Masks and Subsets", content: "An n-bit integer can represent a subset of n elements. Bit i is set if element i is included.\n\nIterate all subsets of n elements: loop from 0 to 2^n - 1.\nCheck if element i is in subset: (mask >> i) & 1.\nAdd element i: mask | (1 << i).\nRemove element i: mask & ~(1 << i).\nToggle element i: mask ^ (1 << i).\n\nUseful for DP with bitmask states (e.g., TSP, assignment problems).", timeComplexity: "O(2^n) to enumerate all subsets", spaceComplexity: "O(1) per mask", whenToUse: "When the set size is small (n <= 20) and you need to track which elements are used. Bitmask DP, subset enumeration, permission flags.", codeExample: "def subsets(nums):\n    n = len(nums)\n    result = []\n    for mask in range(1 << n):\n        subset = []\n        for i in range(n):\n            if (mask >> i) & 1:\n                subset.append(nums[i])\n        result.append(subset)\n    return result", flashcardFront: "How do you use bitmasks to represent and enumerate subsets?", flashcardBack: "An n-bit integer represents a subset: bit i set means element i is included. Enumerate all subsets: loop mask from 0 to 2^n-1. Check membership: (mask >> i) & 1. Add: mask | (1 << i). Remove: mask & ~(1 << i). Toggle: mask ^ (1 << i). Useful for bitmask DP when n <= 20.", order: 2 },
    ]},
    problems: { create: [
      { title: "Single Number", slug: "single-number", difficulty: "Easy", description: "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with O(n) time and O(1) space.", examples: JSON.stringify([{input:"nums = [2,2,1]",output:"1"},{input:"nums = [4,1,2,1,2]",output:"4"}]), hints: JSON.stringify(["XOR has a special property: a ^ a = 0 and a ^ 0 = a.","If you XOR all numbers together, pairs cancel out.","The remaining value is the single number."]), solution: "def single_number(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", explanation: "Bit Manipulation (XOR): XOR all elements. Since a ^ a = 0 and a ^ 0 = a, all pairs cancel out, leaving only the unique element. O(n) time, O(1) space.", pattern: "Bit Manipulation", order: 1 },
      { title: "Number of 1 Bits", slug: "number-of-1-bits", difficulty: "Easy", description: "Write a function that takes the binary representation of a positive integer and returns the number of set bits (1 bits), also known as the Hamming weight.", examples: JSON.stringify([{input:"n = 11 (binary: 1011)",output:"3"},{input:"n = 128 (binary: 10000000)",output:"1"}]), hints: JSON.stringify(["n & (n-1) removes the lowest set bit.","Count how many times you can remove a set bit before reaching 0.","Alternatively, check each bit with n & 1 and shift right."]), solution: "def hamming_weight(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count", explanation: "Bit Manipulation: n & (n-1) clears the lowest set bit. Count iterations until n becomes 0. O(k) where k = number of set bits.", pattern: "Bit Manipulation", order: 2 },
      { title: "Counting Bits", slug: "counting-bits", difficulty: "Easy", description: "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.", examples: JSON.stringify([{input:"n = 2",output:"[0,1,1]"},{input:"n = 5",output:"[0,1,1,2,1,2]"}]), hints: JSON.stringify(["Can you use previously computed results?","i >> 1 is i with the last bit removed. ans[i] = ans[i >> 1] + (i & 1).","This is DP on bit patterns."]), solution: "def count_bits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i >> 1] + (i & 1)\n    return ans", explanation: "DP + Bit Manipulation: ans[i] = ans[i >> 1] + (i & 1). The number of set bits in i equals the bits in i/2 plus whether i is odd. O(n) time.", pattern: "Bit Manipulation", order: 3 },
      { title: "Reverse Bits", slug: "reverse-bits", difficulty: "Medium", description: "Reverse bits of a given 32 bits unsigned integer.\n\nFor example, the input 43261596 (binary: 00000010100101000001111010011100) becomes 964176192 (binary: 00111001011110000010100101000000).", examples: JSON.stringify([{input:"n = 43261596 (00000010100101000001111010011100)",output:"964176192 (00111001011110000010100101000000)"},{input:"n = 4294967293 (11111111111111111111111111111101)",output:"3221225471 (10111111111111111111111111111111)"}]), hints: JSON.stringify(["Process each bit one at a time from least significant to most significant.","Extract the last bit with n & 1, then shift n right.","Build the result by shifting it left and adding each extracted bit."]), solution: "def reverse_bits(n):\n    result = 0\n    for i in range(32):\n        result = (result << 1) | (n & 1)\n        n >>= 1\n    return result", explanation: "Bit-by-bit reversal: Extract the last bit of n (n & 1), append it to result by shifting result left. Repeat 32 times. O(1) time (fixed 32 iterations), O(1) space.", pattern: "Bit Manipulation", order: 4 },
      { title: "Missing Number", slug: "missing-number-bits", difficulty: "Medium", description: "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.", examples: JSON.stringify([{input:"nums = [3,0,1]",output:"2"},{input:"nums = [0,1]",output:"2"},{input:"nums = [9,6,4,2,3,5,7,0,1]",output:"8"}]), hints: JSON.stringify(["XOR a number with itself gives 0.","XOR all numbers 0 to n, then XOR with all elements in the array.","All present numbers cancel out, leaving only the missing one."]), solution: "def missing_number(nums):\n    n = len(nums)\n    result = n\n    for i in range(n):\n        result ^= i ^ nums[i]\n    return result", explanation: "Bit Manipulation (XOR): XOR all indices 0..n with all array values. Every number present appears twice (once as index, once as value) and cancels out. The missing number appears only once. O(n) time, O(1) space.", pattern: "Bit Manipulation", order: 5 },
      { title: "Sum of Two Integers", slug: "sum-two-integers", difficulty: "Medium", description: "Given two integers a and b, return the sum of the two integers without using the operators + and -.", examples: JSON.stringify([{input:"a = 1, b = 2",output:"3"},{input:"a = 2, b = 3",output:"5"}]), hints: JSON.stringify(["XOR gives the sum without carries: a ^ b.","AND then left shift gives the carries: (a & b) << 1.","Repeat until there are no more carries."]), solution: "def get_sum(a, b):\n    mask = 0xFFFFFFFF\n    while b & mask:\n        carry = (a & b) << 1\n        a = a ^ b\n        b = carry\n    return a & mask if b > mask else a", explanation: "Bit Manipulation: XOR computes sum without carry, AND+shift computes carry. Repeat until no carry remains. Use 32-bit mask for Python to handle negative numbers. O(1) time (at most 32 iterations).", pattern: "Bit Manipulation", order: 6 },
      { title: "Reverse Integer", slug: "reverse-integer-bits", difficulty: "Hard", description: "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers.", examples: JSON.stringify([{input:"x = 123",output:"321"},{input:"x = -123",output:"-321"},{input:"x = 120",output:"21"}]), hints: JSON.stringify(["Extract digits from the end using modulo.","Build the reversed number digit by digit.","Check for overflow before each multiplication by 10."]), solution: "def reverse(x):\n    INT_MAX = 2**31 - 1\n    INT_MIN = -2**31\n    result = 0\n    sign = 1 if x >= 0 else -1\n    x = abs(x)\n    while x:\n        digit = x % 10\n        x //= 10\n        if result > (INT_MAX - digit) // 10:\n            return 0\n        result = result * 10 + digit\n    return sign * result", explanation: "Math with overflow check: Extract digits via modulo, build reversed number. Check for 32-bit overflow before each step. Handle sign separately. O(log x) time for number of digits, O(1) space.", pattern: "Bit Manipulation", order: 7 },
      { title: "Single Number III", slug: "single-number-iii", difficulty: "Hard", description: "Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\n\nYou must implement a solution with O(n) time and O(1) space.", examples: JSON.stringify([{input:"nums = [1,2,1,3,2,5]",output:"[3,5]"},{input:"nums = [-1,0]",output:"[-1,0]"}]), hints: JSON.stringify(["XOR all elements to get xor = a ^ b (the two unique numbers XORed together).","Find a bit where a and b differ (any set bit in xor). Use xor & (-xor) for the lowest set bit.","Partition all numbers into two groups based on that bit and XOR each group separately."]), solution: "def single_number_iii(nums):\n    xor = 0\n    for num in nums:\n        xor ^= num\n    diff_bit = xor & (-xor)\n    a = b = 0\n    for num in nums:\n        if num & diff_bit:\n            a ^= num\n        else:\n            b ^= num\n    return [a, b]", explanation: "Bit Manipulation: XOR all to get a^b. Find a differing bit (lowest set bit via xor & -xor). Partition numbers into two groups by that bit. XOR each group to isolate a and b separately. O(n) time, O(1) space.", pattern: "Bit Manipulation", order: 8 },
    ]},
  };
}
