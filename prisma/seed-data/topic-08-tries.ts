export function getTriesData() {
  return {
    name: "Tries",
    slug: "tries",
    description: "Prefix tree data structure for efficient string operations: prefix search, autocomplete, and word dictionaries.",
    icon: "ðŸ”¤", order: 8,
    concepts: { create: [
      { title: "Trie Implementation", content: "A trie (prefix tree) stores strings character by character. Each node has children (one per character) and an end-of-word flag.\n\nInsert: walk down creating nodes as needed. Search: walk down checking each char exists. Prefix search: same as search but don't require end-of-word.\n\nMuch faster than checking every word for prefix operations.", timeComplexity: "O(m) per operation, m = word length", spaceComplexity: "O(total characters)", whenToUse: "Prefix-based search, autocomplete, spell checking, word games (Boggle), when you need to check if any word starts with a prefix.", codeExample: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end", flashcardFront: "What is a trie (prefix tree) and what are its key operations' time complexities?", flashcardBack: "A trie is a tree data structure where each node represents a character and paths from root to nodes represent prefixes of stored strings. Each node has a children map (char -> node) and an is_end flag. Insert, search, and startsWith all take O(m) time where m is the word/prefix length -- they walk down the tree one character at a time. Space is O(total characters stored). Tries excel at prefix-based lookups compared to hash sets.", order: 1 },
      { title: "Trie with DFS/Backtracking", content: "Combining a trie with DFS enables powerful pattern matching. Build a trie from a dictionary, then DFS on a grid or string to find all words.\n\nThe trie acts as a guide: at each step, only continue if the current prefix exists in the trie. This prunes the search space dramatically compared to checking each word individually.", timeComplexity: "O(m * n * 4^L) for grid search", spaceComplexity: "O(total characters in dictionary)", whenToUse: "Word search on a grid, finding all dictionary words in a board, autocomplete with constraints, wildcard pattern matching.", codeExample: "def find_words(board, words):\n    # Build trie from words\n    root = {}\n    for w in words:\n        node = root\n        for c in w:\n            node = node.setdefault(c, {})\n        node['#'] = w\n    # DFS on board using trie\n    result = []\n    for r in range(len(board)):\n        for c in range(len(board[0])):\n            dfs(board, r, c, root, result)", flashcardFront: "How does combining a trie with DFS/backtracking improve word search problems?", flashcardBack: "Instead of searching for each word independently (which would be O(words * cells * 4^L)), build a trie from all target words first. Then DFS from each cell on the board, following the trie structure. If the current path prefix doesn't exist in the trie, prune that branch immediately. This way you search for all words simultaneously in one pass, and the trie eliminates dead-end paths early.", order: 2 },
    ]},
    problems: { create: [
      // === Existing 2 problems ===
      { title: "Implement Trie (Prefix Tree)", slug: "implement-trie", difficulty: "Medium", description: "Implement a trie with insert, search, and startsWith methods.\n\n- insert(word): Inserts the string word into the trie.\n- search(word): Returns true if the string word is in the trie.\n- startsWith(prefix): Returns true if any word in the trie starts with the given prefix.", examples: JSON.stringify([{input:'insert("apple"), search("apple"), search("app"), startsWith("app"), insert("app"), search("app")',output:"true, false, true, true"}]), hints: JSON.stringify(["Each node should store children (map of char -> node) and an is_end flag.","Insert: create nodes as you go, mark the last node as end-of-word.","startsWith: same as search, but don't require the node to be end-of-word."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self._find(word)\n        return node is not None and node.is_end\n    \n    def startsWith(self, prefix):\n        return self._find(prefix) is not None\n    \n    def _find(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return None\n            node = node.children[c]\n        return node", explanation: "Trie: Each node stores a map of children and an end-of-word flag. Insert walks down creating nodes. Search/startsWith walk down checking existence. O(m) per operation.", pattern: "Trie", order: 1 },
      { title: "Word Search II", slug: "word-search-ii", difficulty: "Hard", description: "Given an m x n board of characters and a list of strings words, return all words that can be found in the board.\n\nEach word must be constructed from letters of sequentially adjacent cells (horizontally or vertically). The same cell may not be used more than once in a word.", examples: JSON.stringify([{input:'board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]',output:'["eat","oath"]'}]), hints: JSON.stringify(["Searching for each word independently is slow.","Build a trie from all words, then DFS from each cell.","The trie lets you prune branches early â€” if no word starts with the current prefix, stop."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef find_words(board, words):\n    root = TrieNode()\n    for w in words:\n        node = root\n        for c in w:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = w\n    \n    result = []\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, node):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        char = board[r][c]\n        if char not in node.children:\n            return\n        node = node.children[char]\n        if node.word:\n            result.append(node.word)\n            node.word = None\n        board[r][c] = '#'\n        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n            dfs(r+dr, c+dc, node)\n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, root)\n    return result", explanation: "Trie + Backtracking/DFS: Build a trie from all words, then DFS from each cell on the board. The trie allows efficient prefix pruning â€” stop exploring if no word has the current prefix. O(m*n*4^L) worst case.", pattern: "Trie", order: 2 },
      // === New problems: 2E + 3M + 1H to reach 2E/4M/2H total ===
      { title: "Longest Common Prefix", slug: "longest-common-prefix", difficulty: "Easy", description: "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string.", examples: JSON.stringify([{input:'strs = ["flower","flow","flight"]',output:'"fl"',explanation:"'fl' is the longest common prefix shared by all three strings"},{input:'strs = ["dog","racecar","car"]',output:'""',explanation:"There is no common prefix among the input strings"}]), hints: JSON.stringify(["A trie built from all strings will share common prefixes along single-child paths.","Alternatively, compare characters column by column across all strings.","The common prefix ends when characters diverge or any string runs out."]), solution: "def longest_common_prefix(strs):\n    if not strs:\n        return ''\n    # Build a trie\n    root = {}\n    for word in strs:\n        node = root\n        for c in word:\n            if c not in node:\n                node[c] = {}\n            node = node[c]\n        node['#'] = True\n    # Walk trie while single child and not end-of-word\n    prefix = []\n    node = root\n    while len(node) == 1 and '#' not in node:\n        char = next(iter(node))\n        prefix.append(char)\n        node = node[char]\n    return ''.join(prefix)", explanation: "Trie approach: Insert all strings into a trie. Then walk from the root as long as there is exactly one child and no end-of-word marker. The path traversed is the longest common prefix. O(S) time where S is the sum of all string lengths.", pattern: "Trie", order: 3 },
      { title: "Search Suggestions System", slug: "search-suggestions-system", difficulty: "Easy", description: "You are given an array of strings products and a string searchWord. Design a system that suggests at most three product names from products after each character of searchWord is typed.\n\nSuggested products should have a common prefix with searchWord. If there are more than three products with a common prefix, return the three lexicographically smallest. Return a list of lists of suggested products after each character of searchWord is typed.", examples: JSON.stringify([{input:'products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"',output:'[["mobile","moneypot","monitor"],["mobile","moneypot","monitor"],["mouse","mousepad"],["mouse","mousepad"],["mouse","mousepad"]]',explanation:"After typing 'm', 'mo', 'mou', 'mous', 'mouse', return top 3 lexicographic matches"},{input:'products = ["havana"], searchWord = "havana"',output:'[["havana"],["havana"],["havana"],["havana"],["havana"],["havana"]]'}]), hints: JSON.stringify(["Sort the products first so lexicographic order is maintained.","Build a trie from the sorted products. At each node, store up to 3 suggestions.","For each prefix of searchWord, walk the trie and collect the suggestions stored at that node."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.suggestions = []\n\ndef suggested_products(products, search_word):\n    products.sort()\n    root = TrieNode()\n    for product in products:\n        node = root\n        for c in product:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n            if len(node.suggestions) < 3:\n                node.suggestions.append(product)\n    result = []\n    node = root\n    for c in search_word:\n        if node and c in node.children:\n            node = node.children[c]\n            result.append(node.suggestions)\n        else:\n            node = None\n            result.append([])\n    return result", explanation: "Trie with suggestions: Sort products first, then insert into a trie. At each node, store up to 3 product names (since products are sorted, the first 3 reaching each node are lexicographically smallest). For each character of searchWord, walk the trie and return stored suggestions. O(S + m) where S = total chars in products, m = length of searchWord.", pattern: "Trie", order: 4 },
      { title: "Design Add and Search Words Data Structure", slug: "design-add-search-words", difficulty: "Medium", description: "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n- addWord(word): Adds word to the data structure.\n- search(word): Returns true if there is any string that matches word. word may contain dots '.' where a dot can match any letter.", examples: JSON.stringify([{input:'addWord("bad"), addWord("dad"), addWord("mad"), search("pad"), search("bad"), search(".ad"), search("b..")',output:"false, true, true, true",explanation:"'.' matches any single character, so '.ad' matches 'bad', 'dad', 'mad'"},{input:'addWord("a"), addWord("ab"), search("a"), search("a."), search("ab"), search(".a"), search(".b")',output:"true, true, true, false, true"}]), hints: JSON.stringify(["Use a trie for the basic add/search operations.","For the '.' wildcard, you need to explore all children at that level.","Use recursion/DFS when you hit a '.': try every child and return true if any path matches."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def addWord(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    \n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.is_end\n            if word[i] == '.':\n                for child in node.children.values():\n                    if dfs(child, i + 1):\n                        return True\n                return False\n            if word[i] not in node.children:\n                return False\n            return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)", explanation: "Trie with DFS for wildcards: Standard trie insertion for addWord. For search, when encountering '.', branch out and try all children using DFS. If any branch matches, return true. O(m) for add, O(26^m) worst case for search with all dots, but typically much faster.", pattern: "Trie", order: 5 },
      { title: "Replace Words", slug: "replace-words", difficulty: "Medium", description: "In a dictionary of root words and a sentence of words separated by spaces, replace each word in the sentence with the shortest root that is a prefix of that word. If a word has no matching root, leave it unchanged.\n\nReturn the modified sentence.", examples: JSON.stringify([{input:'dictionary = ["cat","bat","rat"], sentence = "the cattle was rattled by the battery"',output:'"the cat was rat by the bat"',explanation:"cattle -> cat, rattled -> rat, battery -> bat"},{input:'dictionary = ["a","b","c"], sentence = "aadsfasf absbd bbab cadsfabd"',output:'"a]" b b c"'}]), hints: JSON.stringify(["Build a trie from the dictionary roots.","For each word in the sentence, walk the trie character by character.","Return the first root found (shortest prefix match) or the original word if no root matches."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef replace_words(dictionary, sentence):\n    root = TrieNode()\n    for word in dictionary:\n        node = root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        if node.word is None or len(word) < len(node.word):\n            node.word = word\n    \n    def find_root(word):\n        node = root\n        for c in word:\n            if c not in node.children:\n                return word\n            node = node.children[c]\n            if node.word:\n                return node.word\n        return word\n    \n    return ' '.join(find_root(w) for w in sentence.split())", explanation: "Trie prefix search: Build a trie from dictionary roots. For each sentence word, walk the trie and return the first complete root found (shortest prefix). If no root matches, keep the original word. O(D + S) where D = total chars in dictionary, S = total chars in sentence.", pattern: "Trie", order: 6 },
      { title: "Map Sum Pairs", slug: "map-sum-pairs", difficulty: "Medium", description: "Design a map that allows you to:\n- insert(key, val): Insert or update the key-value pair.\n- sum(prefix): Return the sum of all values whose key starts with the given prefix.", examples: JSON.stringify([{input:'insert("apple", 3), sum("ap"), insert("app", 2), sum("ap")',output:"3, 5",explanation:"sum('ap') = 3 initially (only 'apple'). After inserting 'app' with value 2, sum('ap') = 3 + 2 = 5"},{input:'insert("a", 3), sum("ap"), insert("ap", 2), sum("ap")',output:"0, 5",explanation:"No key starts with 'ap' initially. After insert, 'a'=3 and 'ap'=2 both match, sum = 5"}]), hints: JSON.stringify(["A trie naturally handles prefix queries.","Store the value at the end-of-word node, or propagate values through prefix nodes.","For sum, walk to the prefix node, then DFS to sum all values in that subtree."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.val = 0\n\nclass MapSum:\n    def __init__(self):\n        self.root = TrieNode()\n        self.map = {}\n    \n    def insert(self, key, val):\n        delta = val - self.map.get(key, 0)\n        self.map[key] = val\n        node = self.root\n        node.val += delta\n        for c in key:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n            node.val += delta\n    \n    def sum(self, prefix):\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return 0\n            node = node.children[c]\n        return node.val", explanation: "Trie with prefix sums: Each node stores the cumulative sum of all words passing through it. On insert, compute the delta (new value - old value) and propagate it along the path. For sum, just walk to the prefix node and return its stored sum. O(m) for both insert and sum.", pattern: "Trie", order: 7 },
      { title: "Palindrome Pairs", slug: "palindrome-pairs", difficulty: "Hard", description: "Given a list of unique words, return all pairs of distinct indices (i, j) such that the concatenation of words[i] + words[j] is a palindrome.\n\nReturn all such pairs.", examples: JSON.stringify([{input:'words = ["abcd","dcba","lls","s","sssll"]',output:"[[0,1],[1,0],[3,2],[2,4]]",explanation:'"abcddcba", "dcbaabcd", "slls", "llssssll" are palindromes'},{input:'words = ["bat","tab","cat"]',output:"[[0,1],[1,0]]"}]), hints: JSON.stringify(["Build a trie from the reversed words.","For each word, search the trie to find words whose reverse is a prefix or suffix of the current word.","Handle three cases: exact reverse match, word is longer (check if remainder is a palindrome), trie word is longer (check if remainder stored in trie is a palindrome)."]), solution: "def palindrome_pairs(words):\n    word_map = {w: i for i, w in enumerate(words)}\n    result = []\n    for i, word in enumerate(words):\n        for j in range(len(word) + 1):\n            prefix = word[:j]\n            suffix = word[j:]\n            # Case 1: prefix is palindrome, reverse of suffix exists\n            if prefix == prefix[::-1]:\n                rev_suffix = suffix[::-1]\n                if rev_suffix in word_map and word_map[rev_suffix] != i:\n                    result.append([word_map[rev_suffix], i])\n            # Case 2: suffix is palindrome, reverse of prefix exists\n            if j < len(word) and suffix == suffix[::-1]:\n                rev_prefix = prefix[::-1]\n                if rev_prefix in word_map and word_map[rev_prefix] != i:\n                    result.append([i, word_map[rev_prefix]])\n    return result", explanation: "Hash map with palindrome checks: For each word, consider all possible splits into prefix and suffix. If the prefix is a palindrome, look for the reverse of the suffix in the dictionary (it would go before our word). If the suffix is a palindrome, look for the reverse of the prefix (it would go after). O(n * k^2) where k is average word length.", pattern: "Trie / Hash Map", order: 8 },
    ]},
  };
}
