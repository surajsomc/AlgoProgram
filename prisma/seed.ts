import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

async function main() {
  console.log("Clearing existing data...");
  await prisma.problemAttempt.deleteMany();
  await prisma.userProgress.deleteMany();
  await prisma.concept.deleteMany();
  await prisma.problem.deleteMany();
  await prisma.topic.deleteMany();

  // ===== TOPIC 1: Arrays & Hashing =====
  console.log("Seeding: Arrays & Hashing");
  await prisma.topic.create({
    data: {
      name: "Arrays & Hashing",
      slug: "arrays-and-hashing",
      description: "Use hash maps for O(1) lookups, frequency counting, and grouping. Converts brute-force O(nÂ²) to O(n).",
      icon: "ðŸ”¢", order: 1,
      concepts: { create: [
        { title: "Hash Map Lookup", content: "Store key-value pairs for O(1) average lookups. Instead of scanning the array to find a match, store seen values and check the map.\n\nCore pattern: iterate once, check map, update map.\n\nCommon uses: counting frequencies, finding complements (Two Sum), grouping anagrams, detecting duplicates.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "When you need O(1) existence checks, frequency counts, or pair-finding.", codeExample: "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        comp = target - num\n        if comp in seen:\n            return [seen[comp], i]\n        seen[num] = i", order: 1 },
        { title: "Frequency Counting", content: "Count occurrences of elements using a hash map or Counter. Useful for finding duplicates, top-K elements, and validating anagrams.\n\nPattern: build a frequency map, then query it.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "When you need to count occurrences, find most/least common elements, or check if two collections have same element frequencies.", codeExample: "from collections import Counter\ndef is_anagram(s, t):\n    return Counter(s) == Counter(t)", order: 2 },
      ]},
      problems: { create: [
        { title: "Two Sum", slug: "two-sum", difficulty: "Easy", description: "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.", examples: JSON.stringify([{input:"nums = [2,7,11,15], target = 9",output:"[0,1]",explanation:"nums[0] + nums[1] = 2 + 7 = 9"},{input:"nums = [3,2,4], target = 6",output:"[1,2]"}]), hints: JSON.stringify(["Think about what value you need to find for each number.","For each number, the complement is target - num. How can you check if you've seen the complement before?","Use a hash map to store numbers you've seen with their indices."]), solution: "def two_sum(nums, target):\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []", explanation: "Hash Map Lookup: For each number, compute complement = target - num. Check if complement exists in hash map. If yes, return both indices. If no, store current number and index. One pass, O(n) time, O(n) space.", pattern: "Hash Map / Hash Set", order: 1 },
        { title: "Contains Duplicate", slug: "contains-duplicate", difficulty: "Easy", description: "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.", examples: JSON.stringify([{input:"nums = [1,2,3,1]",output:"true"},{input:"nums = [1,2,3,4]",output:"false"}]), hints: JSON.stringify(["What data structure gives O(1) lookup?","Add elements to a set as you iterate. If you try to add one that's already there...","A set automatically handles uniqueness."]), solution: "def contains_duplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False", explanation: "Hash Set: Iterate through the array, adding each element to a set. If an element is already in the set, we found a duplicate. O(n) time, O(n) space.", pattern: "Hash Map / Hash Set", order: 2 },
        { title: "Group Anagrams", slug: "group-anagrams", difficulty: "Medium", description: "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.", examples: JSON.stringify([{input:'strs = ["eat","tea","tan","ate","nat","bat"]',output:'[["bat"],["nat","tan"],["ate","eat","tea"]]'},{input:'strs = [""]',output:'[[""]]'}]), hints: JSON.stringify(["Two words are anagrams if they have the same characters in the same frequencies.","What if you sorted each word? Anagrams would have the same sorted form.","Use sorted word as a hash map key, group words with the same key."]), solution: "from collections import defaultdict\ndef group_anagrams(strs):\n    groups = defaultdict(list)\n    for s in strs:\n        key = tuple(sorted(s))\n        groups[key].append(s)\n    return list(groups.values())", explanation: "Hash Map with sorted key: Sort each string to create a canonical form. Use that as a hash map key. All anagrams map to the same key. O(n * k log k) where k is max string length.", pattern: "Hash Map / Hash Set", order: 3 },
        { title: "Top K Frequent Elements", slug: "top-k-frequent", difficulty: "Medium", description: "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.", examples: JSON.stringify([{input:"nums = [1,1,1,2,2,3], k = 2",output:"[1,2]"},{input:"nums = [1], k = 1",output:"[1]"}]), hints: JSON.stringify(["First, count the frequency of each element.","How can you efficiently find the top-k from a frequency map?","Bucket sort: create buckets where index = frequency, then collect from highest bucket down."]), solution: "def top_k_frequent(nums, k):\n    count = {}\n    for n in nums:\n        count[n] = count.get(n, 0) + 1\n    buckets = [[] for _ in range(len(nums) + 1)]\n    for num, freq in count.items():\n        buckets[freq].append(num)\n    result = []\n    for i in range(len(buckets) - 1, 0, -1):\n        for num in buckets[i]:\n            result.append(num)\n            if len(result) == k:\n                return result", explanation: "Frequency counting + bucket sort: Count frequencies with hash map, then use bucket sort where index = frequency. Iterate from highest frequency bucket to collect top-k. O(n) time.", pattern: "Hash Map / Hash Set", order: 4 },
      ]},
    },
  });

  // ===== TOPIC 2: Two Pointers =====
  console.log("Seeding: Two Pointers");
  await prisma.topic.create({
    data: {
      name: "Two Pointers",
      slug: "two-pointers",
      description: "Use two indices moving through a sorted array to solve problems in O(n) time and O(1) space.",
      icon: "ðŸ‘†", order: 2,
      concepts: { create: [
        { title: "Opposite Direction Pointers", content: "Place one pointer at the start and one at the end. Move them toward each other based on a condition.\n\nWorks on sorted arrays: if sum too small, move left pointer right. If too large, move right pointer left.\n\nKey insight: the sorted order lets you eliminate possibilities with each move.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "Sorted array + finding pairs that meet a condition. Also works for palindrome checking.", codeExample: "def two_sum_sorted(nums, target):\n    l, r = 0, len(nums) - 1\n    while l < r:\n        s = nums[l] + nums[r]\n        if s == target: return [l, r]\n        elif s < target: l += 1\n        else: r -= 1", order: 1 },
        { title: "Same Direction Pointers", content: "Both pointers move in the same direction at different speeds or conditions. Used for removing duplicates in-place, partitioning arrays.\n\nSlow pointer marks the position to write, fast pointer scans ahead.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "In-place array modifications, removing elements, partitioning.", codeExample: "def remove_duplicates(nums):\n    if not nums: return 0\n    slow = 0\n    for fast in range(1, len(nums)):\n        if nums[fast] != nums[slow]:\n            slow += 1\n            nums[slow] = nums[fast]\n    return slow + 1", order: 2 },
      ]},
      problems: { create: [
        { title: "Valid Palindrome", slug: "valid-palindrome", difficulty: "Easy", description: "Given a string s, return true if it is a palindrome after converting all uppercase letters to lowercase and removing all non-alphanumeric characters.", examples: JSON.stringify([{input:'s = "A man, a plan, a canal: Panama"',output:"true",explanation:'"amanaplanacanalpanama" is a palindrome'},{input:'s = "race a car"',output:"false"}]), hints: JSON.stringify(["Use two pointers from both ends.","Skip non-alphanumeric characters.","Compare lowercase versions of characters at both pointers."]), solution: "def is_palindrome(s):\n    l, r = 0, len(s) - 1\n    while l < r:\n        while l < r and not s[l].isalnum(): l += 1\n        while l < r and not s[r].isalnum(): r -= 1\n        if s[l].lower() != s[r].lower():\n            return False\n        l += 1\n        r -= 1\n    return True", explanation: "Two pointers from opposite ends: Skip non-alphanumeric chars, compare lowercase chars moving inward. O(n) time, O(1) space.", pattern: "Two Pointers", order: 1 },
        { title: "3Sum", slug: "three-sum", difficulty: "Medium", description: "Given an integer array nums, return all triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nThe solution set must not contain duplicate triplets.", examples: JSON.stringify([{input:"nums = [-1,0,1,2,-1,-4]",output:"[[-1,-1,2],[-1,0,1]]"},{input:"nums = [0,1,1]",output:"[]"}]), hints: JSON.stringify(["Sort the array first.","Fix one element, then use two pointers on the remaining array to find pairs.","Skip duplicates to avoid repeated triplets."]), solution: "def three_sum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 2):\n        if i > 0 and nums[i] == nums[i-1]: continue\n        l, r = i + 1, len(nums) - 1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0: l += 1\n            elif s > 0: r -= 1\n            else:\n                result.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]: l += 1\n                while l < r and nums[r] == nums[r-1]: r -= 1\n                l += 1; r -= 1\n    return result", explanation: "Sort + Two Pointers: Sort array, fix each element, then use two pointers on the rest to find pairs summing to the negative of the fixed element. Skip duplicates. O(nÂ²) time.", pattern: "Two Pointers", order: 2 },
        { title: "Container With Most Water", slug: "container-most-water", difficulty: "Medium", description: "You are given an integer array height of length n. There are n vertical lines drawn. Find two lines that together with the x-axis form a container that holds the most water.\n\nReturn the maximum amount of water a container can store.", examples: JSON.stringify([{input:"height = [1,8,6,2,5,4,8,3,7]",output:"49",explanation:"Lines at index 1 and 8 form a container with area = min(8,7) * (8-1) = 49"},{input:"height = [1,1]",output:"1"}]), hints: JSON.stringify(["Start with the widest container (pointers at both ends).","Area = min(height[l], height[r]) * (r - l). Width decreases as pointers move in.","Move the pointer pointing to the shorter line â€” keeping the shorter one can't help."]), solution: "def max_area(height):\n    l, r = 0, len(height) - 1\n    best = 0\n    while l < r:\n        area = min(height[l], height[r]) * (r - l)\n        best = max(best, area)\n        if height[l] < height[r]:\n            l += 1\n        else:\n            r -= 1\n    return best", explanation: "Two Pointers from opposite ends: Start wide, compute area at each step. Always move the shorter side inward since moving the taller side can only decrease area. O(n) time, O(1) space.", pattern: "Two Pointers", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 3: Sliding Window =====
  console.log("Seeding: Sliding Window");
  await prisma.topic.create({
    data: {
      name: "Sliding Window",
      slug: "sliding-window",
      description: "Maintain a window over a contiguous subarray/substring. Expand and shrink the window to find optimal subarrays.",
      icon: "ðŸªŸ", order: 3,
      concepts: { create: [
        { title: "Fixed-Size Window", content: "Window of size k slides across the array. Add the new element entering the window, remove the element leaving.\n\nUseful for: max sum of subarray of size k, averages of subarrays.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "When the problem specifies a fixed window size k.", codeExample: "def max_sum_subarray(nums, k):\n    window_sum = sum(nums[:k])\n    best = window_sum\n    for i in range(k, len(nums)):\n        window_sum += nums[i] - nums[i-k]\n        best = max(best, window_sum)\n    return best", order: 1 },
        { title: "Variable-Size Window", content: "Expand the right pointer to include elements. When a constraint is violated, shrink from the left.\n\nPattern: right pointer always moves forward. Left pointer moves forward only when needed to restore validity.\n\nUseful for: longest substring without repeating chars, minimum window substring.", timeComplexity: "O(n)", spaceComplexity: "O(k) where k = character set", whenToUse: "Finding longest/shortest subarray or substring that satisfies a condition.", codeExample: "def longest_unique_substring(s):\n    seen = set()\n    l = best = 0\n    for r in range(len(s)):\n        while s[r] in seen:\n            seen.remove(s[l])\n            l += 1\n        seen.add(s[r])\n        best = max(best, r - l + 1)\n    return best", order: 2 },
      ]},
      problems: { create: [
        { title: "Best Time to Buy and Sell Stock", slug: "best-time-buy-sell-stock", difficulty: "Easy", description: "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy and a single day to sell in the future. Return the maximum profit. If no profit is possible, return 0.", examples: JSON.stringify([{input:"prices = [7,1,5,3,6,4]",output:"5",explanation:"Buy on day 2 (price=1), sell on day 5 (price=6), profit=5."},{input:"prices = [7,6,4,3,1]",output:"0"}]), hints: JSON.stringify(["Track the minimum price seen so far.","At each day, the profit is current price - minimum price so far.","This is like a sliding window where left is the buy day and right is the sell day."]), solution: "def max_profit(prices):\n    min_price = float('inf')\n    max_profit = 0\n    for price in prices:\n        min_price = min(min_price, price)\n        max_profit = max(max_profit, price - min_price)\n    return max_profit", explanation: "Sliding Window / Greedy: Track minimum price as you scan. At each price, check profit against the minimum seen so far. The window conceptually stretches from the min-price day to the current day. O(n) time, O(1) space.", pattern: "Sliding Window", order: 1 },
        { title: "Longest Substring Without Repeating Characters", slug: "longest-substring-no-repeat", difficulty: "Medium", description: "Given a string s, find the length of the longest substring without repeating characters.", examples: JSON.stringify([{input:'s = "abcabcbb"',output:"3",explanation:'The answer is "abc" with length 3.'},{input:'s = "bbbbb"',output:"1"},{input:'s = "pwwkew"',output:"3"}]), hints: JSON.stringify(["Use a set to track characters in the current window.","Expand the window by moving the right pointer.","When you find a duplicate, shrink from the left until the duplicate is removed."]), solution: "def length_of_longest_substring(s):\n    char_set = set()\n    l = 0\n    result = 0\n    for r in range(len(s)):\n        while s[r] in char_set:\n            char_set.remove(s[l])\n            l += 1\n        char_set.add(s[r])\n        result = max(result, r - l + 1)\n    return result", explanation: "Variable-size Sliding Window: Expand right pointer, adding chars to set. When a duplicate is found, shrink from left until the window is valid again. Track the maximum window size. O(n) time.", pattern: "Sliding Window", order: 2 },
        { title: "Minimum Window Substring", slug: "minimum-window-substring", difficulty: "Hard", description: "Given two strings s and t, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If no such substring exists, return empty string.", examples: JSON.stringify([{input:'s = "ADOBECODEBANC", t = "ABC"',output:'"BANC"'},{input:'s = "a", t = "a"',output:'"a"'}]), hints: JSON.stringify(["Use a frequency map for characters in t.","Expand the window until all characters are covered.","Then shrink from the left to find the minimum valid window."]), solution: "from collections import Counter\ndef min_window(s, t):\n    need = Counter(t)\n    missing = len(t)\n    l = start = end = 0\n    for r, char in enumerate(s, 1):\n        if need[char] > 0:\n            missing -= 1\n        need[char] -= 1\n        if missing == 0:\n            while need[s[l]] < 0:\n                need[s[l]] += 1\n                l += 1\n            if not end or r - l <= end - start:\n                start, end = l, r\n            need[s[l]] += 1\n            missing += 1\n            l += 1\n    return s[start:end]", explanation: "Variable Sliding Window with frequency map: Track how many chars from t are still needed. Expand right to cover all chars, then shrink left to minimize. O(n) time.", pattern: "Sliding Window", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 4: Binary Search =====
  console.log("Seeding: Binary Search");
  await prisma.topic.create({
    data: {
      name: "Binary Search",
      slug: "binary-search",
      description: "Divide the search space in half each step. Works on sorted arrays and monotonic functions. O(log n) time.",
      icon: "ðŸ”", order: 4,
      concepts: { create: [
        { title: "Classic Binary Search", content: "Search for a target in a sorted array by repeatedly halving the search space.\n\nMaintain left and right pointers. Compute mid. If target < mid, search left half. If target > mid, search right half.", timeComplexity: "O(log n)", spaceComplexity: "O(1)", whenToUse: "Sorted array + find target, or any situation where you can eliminate half the search space.", codeExample: "def binary_search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target: return mid\n        elif nums[mid] < target: l = mid + 1\n        else: r = mid - 1\n    return -1", order: 1 },
        { title: "Binary Search on Answer", content: "Instead of searching in an array, search on the answer space. If you can check whether an answer is feasible in O(n), and the feasibility is monotonic, binary search on the answer.\n\nPattern: define a range [lo, hi] for possible answers. Binary search for the minimum/maximum feasible answer.", timeComplexity: "O(n log(range))", spaceComplexity: "O(1)", whenToUse: "Minimize the maximum or maximize the minimum of something. 'What is the smallest X such that...'", codeExample: "def min_eating_speed(piles, h):\n    lo, hi = 1, max(piles)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        hours = sum((p + mid - 1) // mid for p in piles)\n        if hours <= h: hi = mid\n        else: lo = mid + 1\n    return lo", order: 2 },
      ]},
      problems: { create: [
        { title: "Binary Search", slug: "binary-search", difficulty: "Easy", description: "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, return its index. Otherwise, return -1.", examples: JSON.stringify([{input:"nums = [-1,0,3,5,9,12], target = 9",output:"4"},{input:"nums = [-1,0,3,5,9,12], target = 2",output:"-1"}]), hints: JSON.stringify(["The array is sorted â€” you can eliminate half the elements each step.","Compare the middle element with the target.","Adjust left or right boundary based on comparison."]), solution: "def search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n    return -1", explanation: "Classic binary search: Compare target with middle element, narrow search space by half each iteration. O(log n) time, O(1) space.", pattern: "Binary Search", order: 1 },
        { title: "Search in Rotated Sorted Array", slug: "search-rotated-array", difficulty: "Medium", description: "Given a rotated sorted array nums and a target, return the index of target or -1. The array was originally sorted in ascending order and then rotated at some pivot.\n\nYou must write an algorithm with O(log n) runtime.", examples: JSON.stringify([{input:"nums = [4,5,6,7,0,1,2], target = 0",output:"4"},{input:"nums = [4,5,6,7,0,1,2], target = 3",output:"-1"}]), hints: JSON.stringify(["One half of the array is always sorted.","Check which half is sorted by comparing nums[left] with nums[mid].","Determine if the target lies in the sorted half or the other half."]), solution: "def search(nums, target):\n    l, r = 0, len(nums) - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[l] <= nums[mid]:  # left half sorted\n            if nums[l] <= target < nums[mid]:\n                r = mid - 1\n            else:\n                l = mid + 1\n        else:  # right half sorted\n            if nums[mid] < target <= nums[r]:\n                l = mid + 1\n            else:\n                r = mid - 1\n    return -1", explanation: "Modified Binary Search: In a rotated sorted array, one half is always sorted. Determine which half is sorted, check if target is in that half, and narrow accordingly. O(log n).", pattern: "Binary Search", order: 2 },
        { title: "Koko Eating Bananas", slug: "koko-eating-bananas", difficulty: "Medium", description: "Koko loves bananas. There are n piles of bananas. She can eat at speed k bananas per hour (one pile at a time). She has h hours. Return the minimum integer k such that she can eat all bananas within h hours.", examples: JSON.stringify([{input:"piles = [3,6,7,11], h = 8",output:"4"},{input:"piles = [30,11,23,4,20], h = 5",output:"30"}]), hints: JSON.stringify(["The answer k is between 1 and max(piles).","For a given k, can you calculate total hours needed?","Binary search on the answer: find the minimum k where total hours <= h."]), solution: "import math\ndef min_eating_speed(piles, h):\n    lo, hi = 1, max(piles)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        hours = sum(math.ceil(p / mid) for p in piles)\n        if hours <= h:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo", explanation: "Binary Search on Answer: Search the range [1, max(piles)] for the minimum speed k. For each candidate k, check if Koko can finish in h hours. Feasibility is monotonic â€” higher k always works if lower k works. O(n log m) time.", pattern: "Binary Search on Answer", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 5: Linked Lists =====
  console.log("Seeding: Linked Lists");
  await prisma.topic.create({
    data: {
      name: "Linked Lists",
      slug: "linked-lists",
      description: "Master pointer manipulation: fast/slow pointers for cycles and midpoints, reversal for reordering, and merge techniques.",
      icon: "ðŸ”—", order: 5,
      concepts: { create: [
        { title: "Fast & Slow Pointers", content: "Two pointers move at different speeds (slow by 1, fast by 2). They meet if there's a cycle. When fast reaches the end, slow is at the middle.\n\nCycle detection (Floyd's): if fast and slow meet, there's a cycle. To find the cycle start, reset one pointer to head and move both by 1.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "Detect cycles, find the middle node, find the start of a cycle, check if a linked list is a palindrome.", codeExample: "def has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False", order: 1 },
        { title: "Linked List Reversal", content: "Reverse a linked list by redirecting the next pointers. Use three pointers: prev, curr, next.\n\nPattern: save next, point curr.next to prev, advance prev and curr.", timeComplexity: "O(n)", spaceComplexity: "O(1)", whenToUse: "When you need to reverse all or part of a linked list, check palindromes, or reorder nodes.", codeExample: "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev", order: 2 },
      ]},
      problems: { create: [
        { title: "Reverse Linked List", slug: "reverse-linked-list", difficulty: "Easy", description: "Given the head of a singly linked list, reverse the list, and return the reversed list.", examples: JSON.stringify([{input:"head = [1,2,3,4,5]",output:"[5,4,3,2,1]"},{input:"head = [1,2]",output:"[2,1]"}]), hints: JSON.stringify(["You need to redirect each node's next pointer.","Use three pointers: prev, current, and next.","At each step: save next, reverse the link, advance pointers."]), solution: "def reverse_list(head):\n    prev = None\n    curr = head\n    while curr:\n        nxt = curr.next\n        curr.next = prev\n        prev = curr\n        curr = nxt\n    return prev", explanation: "Linked List Reversal: Iterate through the list, reversing each pointer. Maintain prev, curr, nxt pointers. After the loop, prev is the new head. O(n) time, O(1) space.", pattern: "Linked List Reversal", order: 1 },
        { title: "Linked List Cycle", slug: "linked-list-cycle", difficulty: "Easy", description: "Given head, the head of a linked list, determine if the linked list has a cycle in it. A cycle exists if some node can be reached again by continuously following the next pointer.", examples: JSON.stringify([{input:"head = [3,2,0,-4], pos = 1",output:"true",explanation:"Tail connects to node at index 1"},{input:"head = [1], pos = -1",output:"false"}]), hints: JSON.stringify(["Can you use two pointers moving at different speeds?","If there's a cycle, a faster pointer will eventually catch the slower one.","Floyd's cycle detection: slow moves 1 step, fast moves 2 steps."]), solution: "def has_cycle(head):\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False", explanation: "Fast & Slow Pointers (Floyd's): Slow moves 1 step, fast moves 2 steps. If there's a cycle, they'll eventually meet. If fast reaches null, no cycle. O(n) time, O(1) space.", pattern: "Fast & Slow Pointers", order: 2 },
        { title: "Merge Two Sorted Lists", slug: "merge-two-sorted-lists", difficulty: "Easy", description: "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list by splicing together the nodes. Return the head of the merged list.", examples: JSON.stringify([{input:"list1 = [1,2,4], list2 = [1,3,4]",output:"[1,1,2,3,4,4]"},{input:"list1 = [], list2 = [0]",output:"[0]"}]), hints: JSON.stringify(["Use a dummy node to build the result.","Compare current nodes of both lists, append the smaller one.","When one list is exhausted, append the remainder of the other."]), solution: "def merge_two_lists(l1, l2):\n    dummy = ListNode(0)\n    curr = dummy\n    while l1 and l2:\n        if l1.val <= l2.val:\n            curr.next = l1\n            l1 = l1.next\n        else:\n            curr.next = l2\n            l2 = l2.next\n        curr = curr.next\n    curr.next = l1 or l2\n    return dummy.next", explanation: "Merge technique with dummy node: Compare heads of both lists, always pick the smaller one. Use a dummy node to simplify building the result. O(n + m) time, O(1) space.", pattern: "Linked List Reversal", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 6: Stacks & Queues =====
  console.log("Seeding: Stacks & Queues");
  await prisma.topic.create({
    data: {
      name: "Stacks & Queues",
      slug: "stacks-and-queues",
      description: "Stacks (LIFO) for matching, parsing, and monotonic problems. Queues (FIFO) for BFS and order processing.",
      icon: "ðŸ“š", order: 6,
      concepts: { create: [
        { title: "Monotonic Stack", content: "A stack that maintains elements in increasing or decreasing order. When you push a new element, pop all elements that violate the order.\n\nUseful for: finding the next greater/smaller element for each position in O(n) total.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "Next greater element, next smaller element, daily temperatures, stock span, largest rectangle in histogram.", codeExample: "def next_greater(nums):\n    result = [-1] * len(nums)\n    stack = []  # indices\n    for i, num in enumerate(nums):\n        while stack and nums[stack[-1]] < num:\n            result[stack.pop()] = num\n        stack.append(i)\n    return result", order: 1 },
        { title: "Stack for Matching", content: "Use a stack to match opening/closing pairs. Push opening symbols, pop when you see the matching closing symbol.\n\nIf the stack is empty when you need to pop, or non-empty at the end, the string is invalid.", timeComplexity: "O(n)", spaceComplexity: "O(n)", whenToUse: "Valid parentheses, matching brackets, nested structures, expression evaluation.", codeExample: "def is_valid(s):\n    stack = []\n    pairs = {')':'(', ']':'[', '}':'{'}\n    for c in s:\n        if c in pairs:\n            if not stack or stack[-1] != pairs[c]:\n                return False\n            stack.pop()\n        else:\n            stack.append(c)\n    return len(stack) == 0", order: 2 },
      ]},
      problems: { create: [
        { title: "Valid Parentheses", slug: "valid-parentheses", difficulty: "Easy", description: "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.", examples: JSON.stringify([{input:'s = "()"',output:"true"},{input:'s = "()[]{}"',output:"true"},{input:'s = "(]"',output:"false"}]), hints: JSON.stringify(["When you see an opening bracket, you need its closing bracket later.","A stack preserves the order â€” the most recent opening bracket should be closed first.","Push opening brackets, pop and check when you see closing brackets."]), solution: "def is_valid(s):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in s:\n        if char in mapping:\n            if not stack or stack[-1] != mapping[char]:\n                return False\n            stack.pop()\n        else:\n            stack.append(char)\n    return len(stack) == 0", explanation: "Stack for Matching: Push opening brackets onto stack. For each closing bracket, check if the top of the stack is the matching opening bracket. Stack ensures correct nesting order. O(n) time.", pattern: "Stack (Matching/Parsing)", order: 1 },
        { title: "Daily Temperatures", slug: "daily-temperatures", difficulty: "Medium", description: "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day with warmer temperature, answer[i] = 0.", examples: JSON.stringify([{input:"temperatures = [73,74,75,71,69,72,76,73]",output:"[1,1,4,2,1,1,0,0]"},{input:"temperatures = [30,40,50,60]",output:"[1,1,1,0]"}]), hints: JSON.stringify(["For each day, you need the next day with a higher temperature.","This is the 'next greater element' pattern.","Use a monotonic decreasing stack of indices."]), solution: "def daily_temperatures(temps):\n    n = len(temps)\n    answer = [0] * n\n    stack = []  # indices of decreasing temps\n    for i in range(n):\n        while stack and temps[i] > temps[stack[-1]]:\n            j = stack.pop()\n            answer[j] = i - j\n        stack.append(i)\n    return answer", explanation: "Monotonic Stack: Maintain a stack of indices with decreasing temperatures. When a warmer day is found, pop all cooler days from the stack and record the difference. O(n) time, each element pushed/popped at most once.", pattern: "Monotonic Stack", order: 2 },
        { title: "Min Stack", slug: "min-stack", difficulty: "Medium", description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n- push(val): pushes element onto stack\n- pop(): removes the element on the top\n- top(): gets the top element\n- getMin(): retrieves the minimum element", examples: JSON.stringify([{input:"push(-2), push(0), push(-3), getMin(), pop(), top(), getMin()",output:"-3, 0, -2"}]), hints: JSON.stringify(["You need O(1) for getMin â€” you can't scan the whole stack each time.","What if you stored the current minimum alongside each element?","Use a second stack (or store tuples) that tracks the min at each level."]), solution: "class MinStack:\n    def __init__(self):\n        self.stack = []  # (val, current_min)\n    \n    def push(self, val):\n        curr_min = min(val, self.stack[-1][1] if self.stack else val)\n        self.stack.append((val, curr_min))\n    \n    def pop(self):\n        self.stack.pop()\n    \n    def top(self):\n        return self.stack[-1][0]\n    \n    def getMin(self):\n        return self.stack[-1][1]", explanation: "Design (Data Structure): Store each element as a tuple (value, current_minimum). The minimum at each level is min(value, previous_minimum). All operations are O(1).", pattern: "Design (Data Structure)", order: 3 },
      ]},
    },
  });

  // Continued in next section...
  await seedPart2();
}

async function seedPart2() {
  // ===== TOPIC 7: Trees =====
  console.log("Seeding: Trees");
  await prisma.topic.create({
    data: {
      name: "Trees",
      slug: "trees",
      description: "Binary trees, BSTs, and tree traversals. Master DFS (preorder, inorder, postorder) and BFS (level order).",
      icon: "ðŸŒ³", order: 7,
      concepts: { create: [
        { title: "Tree DFS (Recursive)", content: "Depth-first traversal visits nodes by going as deep as possible before backtracking.\n\nThree orders:\n- Preorder: process node, then left, then right\n- Inorder: left, process node, right (gives sorted order for BSTs)\n- Postorder: left, right, process node (useful for computing heights)\n\nMost tree problems use recursive DFS.", timeComplexity: "O(n)", spaceComplexity: "O(h) where h = height", whenToUse: "Most tree problems: depth, height, path sum, validate BST, subtree problems.", codeExample: "def max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(\n        max_depth(root.left),\n        max_depth(root.right)\n    )", order: 1 },
        { title: "Tree BFS (Level Order)", content: "Breadth-first traversal processes nodes level by level using a queue.\n\nPattern: add root to queue. While queue is not empty, process all nodes at current level, add their children for the next level.", timeComplexity: "O(n)", spaceComplexity: "O(w) where w = max width", whenToUse: "Level order traversal, right side view, zigzag order, minimum depth, connecting nodes at the same level.", codeExample: "from collections import deque\ndef level_order(root):\n    if not root: return []\n    result, queue = [], deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        result.append(level)\n    return result", order: 2 },
      ]},
      problems: { create: [
        { title: "Maximum Depth of Binary Tree", slug: "max-depth-binary-tree", difficulty: "Easy", description: "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.", examples: JSON.stringify([{input:"root = [3,9,20,null,null,15,7]",output:"3"},{input:"root = [1,null,2]",output:"2"}]), hints: JSON.stringify(["The depth of a tree = 1 + max depth of its subtrees.","Base case: an empty tree has depth 0.","This is a natural recursive problem â€” DFS."]), solution: "def max_depth(root):\n    if not root:\n        return 0\n    return 1 + max(max_depth(root.left), max_depth(root.right))", explanation: "Tree DFS (Recursive): The depth of a tree is 1 + max(left depth, right depth). Base case: null node returns 0. Classic postorder DFS. O(n) time, O(h) space.", pattern: "DFS (Recursive)", order: 1 },
        { title: "Validate Binary Search Tree", slug: "validate-bst", difficulty: "Medium", description: "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid BST:\n- The left subtree only contains nodes less than the node.\n- The right subtree only contains nodes greater than the node.\n- Both subtrees must also be BSTs.", examples: JSON.stringify([{input:"root = [2,1,3]",output:"true"},{input:"root = [5,1,4,null,null,3,6]",output:"false",explanation:"The root's right child is 4, which is less than 5."}]), hints: JSON.stringify(["Each node must be within a valid range.","Going left narrows the upper bound, going right narrows the lower bound.","Pass min and max bounds through the recursion."]), solution: "def is_valid_bst(root, lo=float('-inf'), hi=float('inf')):\n    if not root:\n        return True\n    if root.val <= lo or root.val >= hi:\n        return False\n    return (is_valid_bst(root.left, lo, root.val) and\n            is_valid_bst(root.right, root.val, hi))", explanation: "DFS with bounds: Each node must be within (min, max) range. Going left, the current node becomes the new max. Going right, it becomes the new min. O(n) time.", pattern: "DFS (Recursive)", order: 2 },
        { title: "Binary Tree Level Order Traversal", slug: "level-order-traversal", difficulty: "Medium", description: "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).", examples: JSON.stringify([{input:"root = [3,9,20,null,null,15,7]",output:"[[3],[9,20],[15,7]]"},{input:"root = [1]",output:"[[1]]"}]), hints: JSON.stringify(["Process nodes level by level â€” which traversal does this?","Use a queue (FIFO) to process nodes in order.","At each level, process all nodes currently in the queue and add their children."]), solution: "from collections import deque\ndef level_order(root):\n    if not root: return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        result.append(level)\n    return result", explanation: "BFS (Level Order): Use a queue to process all nodes at each level. The queue size at the start of each iteration tells you how many nodes are at that level. O(n) time.", pattern: "BFS (Level Order)", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 8: Tries =====
  console.log("Seeding: Tries");
  await prisma.topic.create({
    data: {
      name: "Tries",
      slug: "tries",
      description: "Prefix tree data structure for efficient string operations: prefix search, autocomplete, and word dictionaries.",
      icon: "ðŸ”¤", order: 8,
      concepts: { create: [
        { title: "Trie Implementation", content: "A trie (prefix tree) stores strings character by character. Each node has children (one per character) and an end-of-word flag.\n\nInsert: walk down creating nodes as needed. Search: walk down checking each char exists. Prefix search: same as search but don't require end-of-word.\n\nMuch faster than checking every word for prefix operations.", timeComplexity: "O(m) per operation, m = word length", spaceComplexity: "O(total characters)", whenToUse: "Prefix-based search, autocomplete, spell checking, word games (Boggle), when you need to check if any word starts with a prefix.", codeExample: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.is_end", order: 1 },
      ]},
      problems: { create: [
        { title: "Implement Trie (Prefix Tree)", slug: "implement-trie", difficulty: "Medium", description: "Implement a trie with insert, search, and startsWith methods.\n\n- insert(word): Inserts the string word into the trie.\n- search(word): Returns true if the string word is in the trie.\n- startsWith(prefix): Returns true if any word in the trie starts with the given prefix.", examples: JSON.stringify([{input:'insert("apple"), search("apple"), search("app"), startsWith("app"), insert("app"), search("app")',output:"true, false, true, true"}]), hints: JSON.stringify(["Each node should store children (map of char -> node) and an is_end flag.","Insert: create nodes as you go, mark the last node as end-of-word.","startsWith: same as search, but don't require the node to be end-of-word."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.is_end = True\n    \n    def search(self, word):\n        node = self._find(word)\n        return node is not None and node.is_end\n    \n    def startsWith(self, prefix):\n        return self._find(prefix) is not None\n    \n    def _find(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return None\n            node = node.children[c]\n        return node", explanation: "Trie: Each node stores a map of children and an end-of-word flag. Insert walks down creating nodes. Search/startsWith walk down checking existence. O(m) per operation.", pattern: "Trie", order: 1 },
        { title: "Word Search II", slug: "word-search-ii", difficulty: "Hard", description: "Given an m x n board of characters and a list of strings words, return all words that can be found in the board.\n\nEach word must be constructed from letters of sequentially adjacent cells (horizontally or vertically). The same cell may not be used more than once in a word.", examples: JSON.stringify([{input:'board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]',output:'["eat","oath"]'}]), hints: JSON.stringify(["Searching for each word independently is slow.","Build a trie from all words, then DFS from each cell.","The trie lets you prune branches early â€” if no word starts with the current prefix, stop."]), solution: "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.word = None\n\ndef find_words(board, words):\n    root = TrieNode()\n    for w in words:\n        node = root\n        for c in w:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.word = w\n    \n    result = []\n    rows, cols = len(board), len(board[0])\n    \n    def dfs(r, c, node):\n        if r < 0 or r >= rows or c < 0 or c >= cols:\n            return\n        char = board[r][c]\n        if char not in node.children:\n            return\n        node = node.children[char]\n        if node.word:\n            result.append(node.word)\n            node.word = None\n        board[r][c] = '#'\n        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n            dfs(r+dr, c+dc, node)\n        board[r][c] = char\n    \n    for r in range(rows):\n        for c in range(cols):\n            dfs(r, c, root)\n    return result", explanation: "Trie + Backtracking/DFS: Build a trie from all words, then DFS from each cell on the board. The trie allows efficient prefix pruning â€” stop exploring if no word has the current prefix. O(m*n*4^L) worst case.", pattern: "Trie", order: 2 },
      ]},
    },
  });

  // ===== TOPIC 9: Heap / Priority Queue =====
  console.log("Seeding: Heap / Priority Queue");
  await prisma.topic.create({
    data: {
      name: "Heap / Priority Queue",
      slug: "heap-priority-queue",
      description: "Efficiently find the min/max element. Use for top-K problems, median finding, and merge-K-sorted operations.",
      icon: "â›°ï¸", order: 9,
      concepts: { create: [
        { title: "Min/Max Heap", content: "A heap is a complete binary tree where each parent is smaller (min-heap) or larger (max-heap) than its children.\n\nKey operations: push O(log n), pop O(log n), peek O(1).\n\nPython: heapq module (min-heap). For max-heap, negate values.", timeComplexity: "O(n log k) for top-K", spaceComplexity: "O(k)", whenToUse: "Top-K elements, K-th largest/smallest, merge K sorted lists, running median, scheduling with priorities.", codeExample: "import heapq\ndef top_k_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap", order: 1 },
      ]},
      problems: { create: [
        { title: "Kth Largest Element in an Array", slug: "kth-largest-element", difficulty: "Medium", description: "Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.", examples: JSON.stringify([{input:"nums = [3,2,1,5,6,4], k = 2",output:"5"},{input:"nums = [3,2,3,1,2,4,5,5,6], k = 4",output:"4"}]), hints: JSON.stringify(["You could sort in O(n log n), but can you do better?","A min-heap of size k always has the k-th largest at the top.","Push elements and pop when heap size exceeds k."]), solution: "import heapq\ndef find_kth_largest(nums, k):\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap[0]", explanation: "Min-Heap of size K: Maintain a min-heap of size k. After processing all elements, the top of the heap is the k-th largest. O(n log k) time, O(k) space.", pattern: "Heap / Top-K", order: 1 },
        { title: "Merge K Sorted Lists", slug: "merge-k-sorted-lists", difficulty: "Hard", description: "You are given an array of k linked lists, each sorted in ascending order. Merge all the linked lists into one sorted linked list and return it.", examples: JSON.stringify([{input:"lists = [[1,4,5],[1,3,4],[2,6]]",output:"[1,1,2,3,4,4,5,6]"},{input:"lists = []",output:"[]"}]), hints: JSON.stringify(["You need to always pick the smallest element among k candidates.","A min-heap can give you the smallest in O(log k).","Push the head of each list into a heap, pop the smallest, push its next."]), solution: "import heapq\ndef merge_k_lists(lists):\n    heap = []\n    for i, l in enumerate(lists):\n        if l:\n            heapq.heappush(heap, (l.val, i, l))\n    dummy = ListNode(0)\n    curr = dummy\n    while heap:\n        val, i, node = heapq.heappop(heap)\n        curr.next = node\n        curr = curr.next\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    return dummy.next", explanation: "Heap merge: Use a min-heap to always pick the smallest head among k lists. Pop the min, advance that list, push the new head. O(n log k) where n = total nodes.", pattern: "Heap / Top-K", order: 2 },
        { title: "Find Median from Data Stream", slug: "find-median-data-stream", difficulty: "Hard", description: "Design a data structure that supports:\n- addNum(num): adds an integer from the data stream\n- findMedian(): returns the median of all elements so far\n\nThe median is the middle value in an ordered list.", examples: JSON.stringify([{input:"addNum(1), addNum(2), findMedian(), addNum(3), findMedian()",output:"1.5, 2.0"}]), hints: JSON.stringify(["You need to efficiently access the middle element(s).","What if you split the data into two halves?","Use a max-heap for the lower half and a min-heap for the upper half."]), solution: "import heapq\nclass MedianFinder:\n    def __init__(self):\n        self.lo = []  # max-heap (negated)\n        self.hi = []  # min-heap\n    \n    def addNum(self, num):\n        heapq.heappush(self.lo, -num)\n        heapq.heappush(self.hi, -heapq.heappop(self.lo))\n        if len(self.hi) > len(self.lo):\n            heapq.heappush(self.lo, -heapq.heappop(self.hi))\n    \n    def findMedian(self):\n        if len(self.lo) > len(self.hi):\n            return -self.lo[0]\n        return (-self.lo[0] + self.hi[0]) / 2", explanation: "Two Heaps: A max-heap stores the lower half, a min-heap stores the upper half. Keep them balanced. The median is the top of the max-heap (odd count) or average of both tops (even count). O(log n) add, O(1) find.", pattern: "Heap / Top-K", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 10: Graphs =====
  console.log("Seeding: Graphs");
  await prisma.topic.create({
    data: {
      name: "Graphs",
      slug: "graphs",
      description: "BFS for shortest paths, DFS for exploring all paths and connectivity, topological sort for ordering dependencies.",
      icon: "ðŸ•¸ï¸", order: 10,
      concepts: { create: [
        { title: "Graph BFS", content: "Breadth-first search explores nodes level by level using a queue. In unweighted graphs, BFS finds the shortest path.\n\nPattern: add start to queue + visited set. Process each node, add unvisited neighbors to queue.", timeComplexity: "O(V + E)", spaceComplexity: "O(V)", whenToUse: "Shortest path in unweighted graph, minimum steps/moves, level-by-level exploration.", codeExample: "from collections import deque\ndef bfs_shortest_path(graph, start, end):\n    queue = deque([(start, 0)])\n    visited = {start}\n    while queue:\n        node, dist = queue.popleft()\n        if node == end: return dist\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + 1))\n    return -1", order: 1 },
        { title: "Graph DFS", content: "Depth-first search explores as deep as possible before backtracking. Use recursion or an explicit stack.\n\nGood for: finding all paths, connected components, cycle detection, topological ordering.", timeComplexity: "O(V + E)", spaceComplexity: "O(V)", whenToUse: "Connected components, cycle detection, all paths, topological sort, island counting.", codeExample: "def count_islands(grid):\n    def dfs(r, c):\n        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n            return\n        if grid[r][c] != '1': return\n        grid[r][c] = '0'\n        for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n            dfs(r+dr, c+dc)\n    \n    count = 0\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1\n    return count", order: 2 },
      ]},
      problems: { create: [
        { title: "Number of Islands", slug: "number-of-islands", difficulty: "Medium", description: "Given an m x n 2D grid of '1's (land) and '0's (water), return the number of islands. An island is surrounded by water and formed by connecting adjacent land cells horizontally or vertically.", examples: JSON.stringify([{input:'grid = [["1","1","0","0","0"],["1","1","0","0","0"],["0","0","1","0","0"],["0","0","0","1","1"]]',output:"3"}]), hints: JSON.stringify(["Each island is a connected component of '1's.","When you find a '1', explore all connected '1's (DFS/BFS) and mark them visited.","Count how many times you start a new exploration."]), solution: "def num_islands(grid):\n    def dfs(r, c):\n        if r < 0 or r >= len(grid) or c < 0 or c >= len(grid[0]):\n            return\n        if grid[r][c] != '1': return\n        grid[r][c] = '0'\n        dfs(r+1,c); dfs(r-1,c); dfs(r,c+1); dfs(r,c-1)\n    \n    count = 0\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == '1':\n                dfs(r, c)\n                count += 1\n    return count", explanation: "Graph DFS: Treat the grid as a graph. For each unvisited '1', run DFS to mark all connected land as visited. Each DFS call = one island. O(m*n) time.", pattern: "Graph DFS", order: 1 },
        { title: "Clone Graph", slug: "clone-graph", difficulty: "Medium", description: "Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node has a value and a list of neighbors.", examples: JSON.stringify([{input:"adjList = [[2,4],[1,3],[2,4],[1,3]]",output:"[[2,4],[1,3],[2,4],[1,3]]",explanation:"Deep copy of the graph"}]), hints: JSON.stringify(["You need to create new nodes and map old nodes to new ones.","Use a hash map to track which nodes have been cloned.","DFS or BFS: for each node, clone it, then recursively clone its neighbors."]), solution: "def clone_graph(node):\n    if not node: return None\n    cloned = {}\n    def dfs(n):\n        if n in cloned: return cloned[n]\n        copy = Node(n.val)\n        cloned[n] = copy\n        for neighbor in n.neighbors:\n            copy.neighbors.append(dfs(neighbor))\n        return copy\n    return dfs(node)", explanation: "Graph DFS with hash map: Clone each node, store the mapping old->new. When visiting a neighbor, if already cloned, use the clone. Otherwise, recurse. O(V+E) time.", pattern: "Graph DFS", order: 2 },
        { title: "Course Schedule", slug: "course-schedule", difficulty: "Medium", description: "There are numCourses courses labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates you must take course bi before course ai.\n\nReturn true if you can finish all courses (i.e., no circular dependency).", examples: JSON.stringify([{input:"numCourses = 2, prerequisites = [[1,0]]",output:"true"},{input:"numCourses = 2, prerequisites = [[1,0],[0,1]]",output:"false",explanation:"Circular dependency"}]), hints: JSON.stringify(["This is a directed graph. Courses are nodes, prerequisites are edges.","You can finish all courses if and only if there's no cycle.","Use topological sort (BFS with in-degree counting) or DFS cycle detection."]), solution: "from collections import deque\ndef can_finish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    for a, b in prerequisites:\n        graph[b].append(a)\n        in_degree[a] += 1\n    queue = deque(i for i in range(numCourses) if in_degree[i] == 0)\n    count = 0\n    while queue:\n        node = queue.popleft()\n        count += 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return count == numCourses", explanation: "Topological Sort (Kahn's BFS): Build adjacency list and count in-degrees. Start with nodes having in-degree 0. Process them, decrement neighbors' in-degrees. If all nodes processed, no cycle exists. O(V+E).", pattern: "Topological Sort", order: 3 },
      ]},
    },
  });

  await seedPart3();
}

async function seedPart3() {
  // ===== TOPIC 11: Backtracking =====
  console.log("Seeding: Backtracking");
  await prisma.topic.create({
    data: {
      name: "Backtracking",
      slug: "backtracking",
      description: "Systematically explore all possibilities by making choices, exploring, and undoing (backtracking). Used for combinations, permutations, and constraint satisfaction.",
      icon: "ðŸ”™", order: 11,
      concepts: { create: [
        { title: "Backtracking Template", content: "Backtracking explores a decision tree. At each step, make a choice, recurse, then undo the choice.\n\nTemplate:\ndef backtrack(path, choices):\n    if goal_reached: add path to result\n    for choice in choices:\n        make choice\n        backtrack(path, remaining_choices)\n        undo choice\n\nKey: pruning invalid branches early makes it efficient.", timeComplexity: "O(2^n) or O(n!) depending on problem", spaceComplexity: "O(n) for recursion depth", whenToUse: "Generate all subsets, permutations, combinations. Solve constraint problems like N-Queens, Sudoku. Any 'find all possible...' question.", codeExample: "def subsets(nums):\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", order: 1 },
      ]},
      problems: { create: [
        { title: "Subsets", slug: "subsets", difficulty: "Medium", description: "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution must not contain duplicate subsets.", examples: JSON.stringify([{input:"nums = [1,2,3]",output:"[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"},{input:"nums = [0]",output:"[[],[0]]"}]), hints: JSON.stringify(["For each element, you have two choices: include it or skip it.","Use backtracking: at each position, either add the element or don't.","Use a start index to avoid duplicates."]), solution: "def subsets(nums):\n    result = []\n    def backtrack(start, path):\n        result.append(path[:])\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i + 1, path)\n            path.pop()\n    backtrack(0, [])\n    return result", explanation: "Backtracking: At each step, add current path to result, then try including each remaining element. The start index ensures we don't revisit earlier elements. O(2^n) subsets.", pattern: "Backtracking", order: 1 },
        { title: "Permutations", slug: "permutations", difficulty: "Medium", description: "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.", examples: JSON.stringify([{input:"nums = [1,2,3]",output:"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"}]), hints: JSON.stringify(["A permutation uses all elements in different orders.","At each position, try each unused element.","Track used elements with a set or by swapping."]), solution: "def permute(nums):\n    result = []\n    def backtrack(path, remaining):\n        if not remaining:\n            result.append(path)\n            return\n        for i in range(len(remaining)):\n            backtrack(path + [remaining[i]],\n                      remaining[:i] + remaining[i+1:])\n    backtrack([], nums)\n    return result", explanation: "Backtracking: At each position, try each remaining element. Remove it from available choices and recurse. When no elements remain, we have a complete permutation. O(n!) permutations.", pattern: "Backtracking", order: 2 },
        { title: "Combination Sum", slug: "combination-sum", difficulty: "Medium", description: "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. The same number may be used unlimited times.", examples: JSON.stringify([{input:"candidates = [2,3,6,7], target = 7",output:"[[2,2,3],[7]]"},{input:"candidates = [2,3,5], target = 8",output:"[[2,2,2,2],[2,3,3],[3,5]]"}]), hints: JSON.stringify(["Try including each candidate and recursing with reduced target.","Since we can reuse numbers, don't advance the start index after picking a number.","Prune: if remaining target < 0, stop."]), solution: "def combination_sum(candidates, target):\n    result = []\n    def backtrack(start, path, remaining):\n        if remaining == 0:\n            result.append(path[:])\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > remaining:\n                continue\n            path.append(candidates[i])\n            backtrack(i, path, remaining - candidates[i])\n            path.pop()\n    backtrack(0, [], target)\n    return result", explanation: "Backtracking with reuse: Try each candidate from the current index (allowing reuse by not incrementing start). Prune when the remaining target goes below 0. O(n^(T/M)) where T=target, M=min candidate.", pattern: "Backtracking", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 12: Dynamic Programming =====
  console.log("Seeding: Dynamic Programming");
  await prisma.topic.create({
    data: {
      name: "Dynamic Programming",
      slug: "dynamic-programming",
      description: "Break problems into overlapping subproblems. Build solutions bottom-up using previously computed results. The hardest and most common interview category.",
      icon: "ðŸ“Š", order: 12,
      concepts: { create: [
        { title: "1D Dynamic Programming", content: "Each state depends on one or a few previous states along a single dimension.\n\nPattern: define dp[i] = answer for subproblem ending at i. Find the recurrence: dp[i] = f(dp[i-1], dp[i-2], ...).\n\nExamples: climbing stairs, house robber, longest increasing subsequence.", timeComplexity: "O(n) to O(nÂ²)", spaceComplexity: "O(n) or O(1) with optimization", whenToUse: "When current answer depends on previous answers along a sequence, and you see overlapping subproblems.", codeExample: "def climb_stairs(n):\n    if n <= 2: return n\n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    return prev1", order: 1 },
        { title: "2D Dynamic Programming", content: "States depend on two dimensions, typically a grid or two sequences.\n\nPattern: dp[i][j] = answer considering first i elements of one thing and first j of another.\n\nExamples: edit distance, longest common subsequence, unique paths in grid, knapsack.", timeComplexity: "O(m*n)", spaceComplexity: "O(m*n) or O(n) with optimization", whenToUse: "Comparing two strings/sequences, grid pathfinding with constraints, knapsack-style optimization.", codeExample: "def longest_common_subseq(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0]*(n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]", order: 2 },
      ]},
      problems: { create: [
        { title: "Climbing Stairs", slug: "climbing-stairs", difficulty: "Easy", description: "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?", examples: JSON.stringify([{input:"n = 2",output:"2",explanation:"1+1 or 2"},{input:"n = 3",output:"3",explanation:"1+1+1, 1+2, or 2+1"}]), hints: JSON.stringify(["To reach step n, you came from step n-1 or step n-2.","ways(n) = ways(n-1) + ways(n-2). Sound familiar?","This is the Fibonacci sequence! Use DP to avoid recomputation."]), solution: "def climb_stairs(n):\n    if n <= 2:\n        return n\n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        curr = prev1 + prev2\n        prev2 = prev1\n        prev1 = curr\n    return prev1", explanation: "1D DP (Fibonacci-like): dp[i] = dp[i-1] + dp[i-2]. Ways to reach step i = ways from step i-1 + ways from step i-2. Optimize space to O(1) by keeping only two previous values.", pattern: "1D Dynamic Programming", order: 1 },
        { title: "House Robber", slug: "house-robber", difficulty: "Medium", description: "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money. Adjacent houses have connected security systems â€” if two adjacent houses are broken into, the alarm triggers.\n\nGiven an array of non-negative integers representing money at each house, return the maximum amount you can rob without triggering alarms.", examples: JSON.stringify([{input:"nums = [1,2,3,1]",output:"4",explanation:"Rob house 1 ($1) and house 3 ($3) = $4"},{input:"nums = [2,7,9,3,1]",output:"12",explanation:"Rob house 1 ($2) + house 3 ($9) + house 5 ($1) = $12"}]), hints: JSON.stringify(["For each house, you either rob it or skip it.","If you rob house i, you can't rob house i-1. Your total is nums[i] + best up to house i-2.","If you skip house i, your total is the best up to house i-1.","dp[i] = max(dp[i-1], dp[i-2] + nums[i])"]), solution: "def rob(nums):\n    if len(nums) <= 2:\n        return max(nums) if nums else 0\n    prev2, prev1 = nums[0], max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        curr = max(prev1, prev2 + nums[i])\n        prev2 = prev1\n        prev1 = curr\n    return prev1", explanation: "1D DP: At each house, choose max of (skip this house = dp[i-1]) or (rob this house = dp[i-2] + nums[i]). Space-optimized to O(1) using two variables.", pattern: "1D Dynamic Programming", order: 2 },
        { title: "Longest Common Subsequence", slug: "longest-common-subsequence", difficulty: "Medium", description: "Given two strings text1 and text2, return the length of their longest common subsequence. A subsequence is derived by deleting some (or no) characters without changing the relative order.", examples: JSON.stringify([{input:'text1 = "abcde", text2 = "ace"',output:"3",explanation:'"ace" is the LCS'},{input:'text1 = "abc", text2 = "def"',output:"0"}]), hints: JSON.stringify(["Compare characters from both strings one at a time.","If chars match, the LCS extends by 1 from both strings shortened.","If they don't match, try skipping a char from either string.","This is classic 2D DP: dp[i][j] = LCS of text1[:i] and text2[:j]."]), solution: "def longest_common_subsequence(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]", explanation: "2D DP: dp[i][j] = LCS of first i chars of text1 and first j chars of text2. If chars match, extend from dp[i-1][j-1]+1. Otherwise, max of skipping either char. O(m*n) time and space.", pattern: "2D Dynamic Programming", order: 3 },
        { title: "Coin Change", slug: "coin-change", difficulty: "Medium", description: "Given an integer array coins representing coin denominations and an integer amount, return the fewest number of coins needed to make up that amount. If not possible, return -1.", examples: JSON.stringify([{input:"coins = [1,5,11], amount = 15",output:"3",explanation:"5 + 5 + 5 = 15"},{input:"coins = [2], amount = 3",output:"-1"}]), hints: JSON.stringify(["dp[i] = fewest coins to make amount i.","For each amount, try subtracting each coin and take the minimum.","dp[i] = min(dp[i - coin] + 1) for all valid coins."]), solution: "def coin_change(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i:\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1", explanation: "1D DP: For each amount from 1 to target, try each coin. dp[amount] = min(dp[amount - coin] + 1). Bottom-up approach. O(amount * coins) time.", pattern: "1D Dynamic Programming", order: 4 },
      ]},
    },
  });

  // ===== TOPIC 13: Greedy =====
  console.log("Seeding: Greedy");
  await prisma.topic.create({
    data: {
      name: "Greedy Algorithms",
      slug: "greedy",
      description: "Make the locally optimal choice at each step. Works when local optimality leads to global optimality. Simpler than DP when applicable.",
      icon: "ðŸƒ", order: 13,
      concepts: { create: [
        { title: "Greedy Strategy", content: "At each step, make the choice that looks best right now without considering future consequences.\n\nGreedy works when: the problem has 'greedy choice property' (local optimal leads to global optimal) and 'optimal substructure'.\n\nHow to verify: can you prove that a greedy choice is always part of an optimal solution? Or does a counterexample exist?", timeComplexity: "Usually O(n) or O(n log n)", spaceComplexity: "Usually O(1)", whenToUse: "Activity selection, jump game, gas station, task scheduling, when sorting + greedy choice gives optimal result.", codeExample: "def can_jump(nums):\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return True", order: 1 },
      ]},
      problems: { create: [
        { title: "Jump Game", slug: "jump-game", difficulty: "Medium", description: "You are given an integer array nums. You are initially positioned at the first index. Each element represents your maximum jump length from that position.\n\nReturn true if you can reach the last index.", examples: JSON.stringify([{input:"nums = [2,3,1,1,4]",output:"true",explanation:"Jump 1 to index 1, then 3 to last index."},{input:"nums = [3,2,1,0,4]",output:"false"}]), hints: JSON.stringify(["Track the farthest index you can reach.","At each position, update the max reach.","If your current index exceeds max reach, you're stuck."]), solution: "def can_jump(nums):\n    max_reach = 0\n    for i in range(len(nums)):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + nums[i])\n    return True", explanation: "Greedy: Track the maximum reachable index. At each step, if current index is beyond max reach, return false. Otherwise, update max reach. O(n) time, O(1) space.", pattern: "Greedy", order: 1 },
        { title: "Jump Game II", slug: "jump-game-ii", difficulty: "Medium", description: "Given an array of non-negative integers nums, you are initially at the first index. Each element represents your maximum jump length.\n\nYour goal is to reach the last index in the minimum number of jumps. You can always reach the last index.", examples: JSON.stringify([{input:"nums = [2,3,1,1,4]",output:"2",explanation:"Jump 1 step to index 1, then 3 steps to the last index."}]), hints: JSON.stringify(["Think of it as BFS: each jump is a 'level'.","Track the farthest you can reach in the current jump.","When you reach the end of the current jump's range, increment jumps."]), solution: "def jump(nums):\n    jumps = 0\n    curr_end = 0\n    farthest = 0\n    for i in range(len(nums) - 1):\n        farthest = max(farthest, i + nums[i])\n        if i == curr_end:\n            jumps += 1\n            curr_end = farthest\n    return jumps", explanation: "Greedy / BFS-style: Track the farthest reachable index within the current jump. When you reach the boundary of the current jump, take the next jump to the farthest point. O(n) time.", pattern: "Greedy", order: 2 },
        { title: "Gas Station", slug: "gas-station", difficulty: "Medium", description: "There are n gas stations along a circular route. You have gas[i] fuel at station i and it costs cost[i] to travel to the next station.\n\nReturn the starting gas station's index if you can travel around the circuit once clockwise, otherwise return -1. If a solution exists, it is unique.", examples: JSON.stringify([{input:"gas = [1,2,3,4,5], cost = [3,4,5,1,2]",output:"3",explanation:"Start at station 3 (index 3), travel the full circuit."}]), hints: JSON.stringify(["If total gas >= total cost, a solution must exist.","If you run out of gas at station i, starting from any station between start and i won't work.","Reset the start to i+1 whenever tank goes negative."]), solution: "def can_complete_circuit(gas, cost):\n    total = 0\n    tank = 0\n    start = 0\n    for i in range(len(gas)):\n        diff = gas[i] - cost[i]\n        total += diff\n        tank += diff\n        if tank < 0:\n            start = i + 1\n            tank = 0\n    return start if total >= 0 else -1", explanation: "Greedy: If total gas >= total cost, a solution exists. Track running tank; whenever it goes negative, the start must be after this point. Reset start and tank. O(n) time, O(1) space.", pattern: "Greedy", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 14: Intervals =====
  console.log("Seeding: Intervals");
  await prisma.topic.create({
    data: {
      name: "Intervals",
      slug: "intervals",
      description: "Sort intervals and process them in order. Merge overlapping intervals, find gaps, or count overlaps.",
      icon: "â†”ï¸", order: 14,
      concepts: { create: [
        { title: "Interval Merging", content: "Sort intervals by start time. Iterate and merge overlapping ones.\n\nTwo intervals overlap if the second starts before the first ends: b.start <= a.end.\n\nWhen merging: new_end = max(a.end, b.end).", timeComplexity: "O(n log n) for sorting", spaceComplexity: "O(n)", whenToUse: "Merge overlapping intervals, insert interval, find minimum meeting rooms, determine if person can attend all meetings.", codeExample: "def merge(intervals):\n    intervals.sort()\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", order: 1 },
      ]},
      problems: { create: [
        { title: "Merge Intervals", slug: "merge-intervals", difficulty: "Medium", description: "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals.", examples: JSON.stringify([{input:"intervals = [[1,3],[2,6],[8,10],[15,18]]",output:"[[1,6],[8,10],[15,18]]",explanation:"[1,3] and [2,6] overlap, merged to [1,6]."},{input:"intervals = [[1,4],[4,5]]",output:"[[1,5]]"}]), hints: JSON.stringify(["Sort intervals by start time.","If current interval overlaps with previous, merge them.","Two intervals overlap if the second's start <= the first's end."]), solution: "def merge(intervals):\n    intervals.sort(key=lambda x: x[0])\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        if start <= merged[-1][1]:\n            merged[-1][1] = max(merged[-1][1], end)\n        else:\n            merged.append([start, end])\n    return merged", explanation: "Merge Intervals: Sort by start time, then iterate. If current overlaps with last merged (start <= prev_end), extend the end. Otherwise, start a new interval. O(n log n) time.", pattern: "Merge Intervals", order: 1 },
        { title: "Non-Overlapping Intervals", slug: "non-overlapping-intervals", difficulty: "Medium", description: "Given an array of intervals, return the minimum number of intervals you need to remove to make the rest non-overlapping.", examples: JSON.stringify([{input:"intervals = [[1,2],[2,3],[3,4],[1,3]]",output:"1",explanation:"Remove [1,3] to make the rest non-overlapping."},{input:"intervals = [[1,2],[1,2],[1,2]]",output:"2"}]), hints: JSON.stringify(["Sort by end time.","Greedily keep intervals that end earliest.","If an interval overlaps with the previous kept interval, remove it."]), solution: "def erase_overlap_intervals(intervals):\n    intervals.sort(key=lambda x: x[1])\n    count = 0\n    prev_end = float('-inf')\n    for start, end in intervals:\n        if start >= prev_end:\n            prev_end = end\n        else:\n            count += 1\n    return count", explanation: "Greedy (sort by end time): Keep intervals that end earliest to leave maximum room. Count intervals that overlap with the previously kept one. O(n log n) time.", pattern: "Merge Intervals", order: 2 },
        { title: "Meeting Rooms II", slug: "meeting-rooms-ii", difficulty: "Medium", description: "Given an array of meeting time intervals consisting of start and end times, find the minimum number of conference rooms required.", examples: JSON.stringify([{input:"intervals = [[0,30],[5,10],[15,20]]",output:"2",explanation:"Meetings [0,30] and [5,10] overlap, need 2 rooms."},{input:"intervals = [[7,10],[2,4]]",output:"1"}]), hints: JSON.stringify(["Think about it as counting maximum concurrent meetings.","Separate start times and end times, sort both.","Use two pointers: increment rooms at each start, decrement at each end."]), solution: "def min_meeting_rooms(intervals):\n    starts = sorted(i[0] for i in intervals)\n    ends = sorted(i[1] for i in intervals)\n    rooms = max_rooms = 0\n    s = e = 0\n    while s < len(starts):\n        if starts[s] < ends[e]:\n            rooms += 1\n            max_rooms = max(max_rooms, rooms)\n            s += 1\n        else:\n            rooms -= 1\n            e += 1\n    return max_rooms", explanation: "Sort start/end times separately, sweep through with two pointers. Each start adds a room, each end frees a room. Track the maximum concurrent rooms. O(n log n) time.", pattern: "Merge Intervals", order: 3 },
      ]},
    },
  });

  // ===== TOPIC 15: Bit Manipulation =====
  console.log("Seeding: Bit Manipulation");
  await prisma.topic.create({
    data: {
      name: "Bit Manipulation",
      slug: "bit-manipulation",
      description: "Use binary operations (AND, OR, XOR, shift) for efficient solutions. XOR is especially useful for finding unique elements.",
      icon: "ðŸ’»", order: 15,
      concepts: { create: [
        { title: "Bit Operations", content: "Key operations:\n- XOR (^): same bits â†’ 0, different â†’ 1. a ^ a = 0, a ^ 0 = a\n- AND (&): both 1 â†’ 1. Clear bits, check if bit is set\n- OR (|): either 1 â†’ 1. Set bits\n- Left shift (<<): multiply by 2\n- Right shift (>>): divide by 2\n- n & (n-1): removes lowest set bit\n\nXOR trick: XOR all elements. Duplicates cancel out, leaving the unique one.", timeComplexity: "O(n) for linear scan", spaceComplexity: "O(1)", whenToUse: "Find single/unique numbers among duplicates, check powers of 2, count set bits, toggle bits.", codeExample: "def single_number(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", order: 1 },
      ]},
      problems: { create: [
        { title: "Single Number", slug: "single-number", difficulty: "Easy", description: "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with O(n) time and O(1) space.", examples: JSON.stringify([{input:"nums = [2,2,1]",output:"1"},{input:"nums = [4,1,2,1,2]",output:"4"}]), hints: JSON.stringify(["XOR has a special property: a ^ a = 0 and a ^ 0 = a.","If you XOR all numbers together, pairs cancel out.","The remaining value is the single number."]), solution: "def single_number(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result", explanation: "Bit Manipulation (XOR): XOR all elements. Since a ^ a = 0 and a ^ 0 = a, all pairs cancel out, leaving only the unique element. O(n) time, O(1) space.", pattern: "Bit Manipulation", order: 1 },
        { title: "Number of 1 Bits", slug: "number-of-1-bits", difficulty: "Easy", description: "Write a function that takes the binary representation of a positive integer and returns the number of set bits (1 bits), also known as the Hamming weight.", examples: JSON.stringify([{input:"n = 11 (binary: 1011)",output:"3"},{input:"n = 128 (binary: 10000000)",output:"1"}]), hints: JSON.stringify(["n & (n-1) removes the lowest set bit.","Count how many times you can remove a set bit before reaching 0.","Alternatively, check each bit with n & 1 and shift right."]), solution: "def hamming_weight(n):\n    count = 0\n    while n:\n        n &= (n - 1)\n        count += 1\n    return count", explanation: "Bit Manipulation: n & (n-1) clears the lowest set bit. Count iterations until n becomes 0. O(k) where k = number of set bits.", pattern: "Bit Manipulation", order: 2 },
        { title: "Counting Bits", slug: "counting-bits", difficulty: "Easy", description: "Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.", examples: JSON.stringify([{input:"n = 2",output:"[0,1,1]"},{input:"n = 5",output:"[0,1,1,2,1,2]"}]), hints: JSON.stringify(["Can you use previously computed results?","i >> 1 is i with the last bit removed. ans[i] = ans[i >> 1] + (i & 1).","This is DP on bit patterns."]), solution: "def count_bits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i >> 1] + (i & 1)\n    return ans", explanation: "DP + Bit Manipulation: ans[i] = ans[i >> 1] + (i & 1). The number of set bits in i equals the bits in i/2 plus whether i is odd. O(n) time.", pattern: "Bit Manipulation", order: 3 },
      ]},
    },
  });

  await seedPart4();
}

async function seedPart4() {
  // ===== TOPIC 16: Math & Geometry =====
  console.log("Seeding: Math & Geometry");
  await prisma.topic.create({
    data: {
      name: "Math & Geometry",
      slug: "math-and-geometry",
      description: "Mathematical patterns, modular arithmetic, matrix operations, and geometric reasoning.",
      icon: "ðŸ”º", order: 16,
      concepts: { create: [
        { title: "Math Patterns", content: "Common math tricks:\n- Modular arithmetic for cyclic problems\n- GCD (Euclidean algorithm) for fraction simplification\n- Power of 2 check: n & (n-1) == 0\n- Matrix rotation: transpose + reverse rows\n- Spiral traversal: maintain boundaries, shrink after each direction", timeComplexity: "Varies", spaceComplexity: "Varies", whenToUse: "Problems involving number theory, matrix manipulation, geometric properties.", codeExample: "def rotate_matrix(matrix):\n    n = len(matrix)\n    # Transpose\n    for i in range(n):\n        for j in range(i+1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    # Reverse each row\n    for row in matrix:\n        row.reverse()", order: 1 },
      ]},
      problems: { create: [
        { title: "Rotate Image", slug: "rotate-image", difficulty: "Medium", description: "You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees clockwise. You have to rotate it in-place.", examples: JSON.stringify([{input:"matrix = [[1,2,3],[4,5,6],[7,8,9]]",output:"[[7,4,1],[8,5,2],[9,6,3]]"}]), hints: JSON.stringify(["90Â° clockwise rotation = transpose + reverse each row.","Transpose: swap matrix[i][j] with matrix[j][i].","Then reverse each row."]), solution: "def rotate(matrix):\n    n = len(matrix)\n    for i in range(n):\n        for j in range(i + 1, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n    for row in matrix:\n        row.reverse()", explanation: "Math / Matrix: 90Â° clockwise = transpose + reverse rows. Transpose swaps across the diagonal. Both operations are in-place. O(nÂ²) time, O(1) space.", pattern: "Math", order: 1 },
        { title: "Spiral Matrix", slug: "spiral-matrix", difficulty: "Medium", description: "Given an m x n matrix, return all elements of the matrix in spiral order (clockwise from the outside in).", examples: JSON.stringify([{input:"matrix = [[1,2,3],[4,5,6],[7,8,9]]",output:"[1,2,3,6,9,8,7,4,5]"},{input:"matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",output:"[1,2,3,4,8,12,11,10,9,5,6,7]"}]), hints: JSON.stringify(["Maintain four boundaries: top, bottom, left, right.","Traverse right, down, left, up in order.","After each direction, shrink the corresponding boundary."]), solution: "def spiral_order(matrix):\n    result = []\n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    while top <= bottom and left <= right:\n        for c in range(left, right + 1):\n            result.append(matrix[top][c])\n        top += 1\n        for r in range(top, bottom + 1):\n            result.append(matrix[r][right])\n        right -= 1\n        if top <= bottom:\n            for c in range(right, left - 1, -1):\n                result.append(matrix[bottom][c])\n            bottom -= 1\n        if left <= right:\n            for r in range(bottom, top - 1, -1):\n                result.append(matrix[r][left])\n            left += 1\n    return result", explanation: "Boundary shrinking: Maintain top/bottom/left/right boundaries. Traverse in spiral order, shrinking boundaries after each direction. O(m*n) time.", pattern: "Math", order: 2 },
      ]},
    },
  });

  // ===== TOPIC 17: Union Find =====
  console.log("Seeding: Union Find");
  await prisma.topic.create({
    data: {
      name: "Union Find",
      slug: "union-find",
      description: "Disjoint set data structure for grouping elements. Efficiently determine if two elements are in the same group and merge groups.",
      icon: "ðŸ¤", order: 17,
      concepts: { create: [
        { title: "Union Find / Disjoint Set", content: "Maintains disjoint sets with two operations:\n- Find(x): which set does x belong to? (returns root)\n- Union(x, y): merge the sets containing x and y\n\nOptimizations: path compression (point nodes directly to root) and union by rank (attach smaller tree to larger).\n\nWith both optimizations, operations are nearly O(1) amortized.", timeComplexity: "O(Î±(n)) â‰ˆ O(1) amortized", spaceComplexity: "O(n)", whenToUse: "Connected components, redundant connections, accounts merge, when you need to dynamically group elements.", codeExample: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True", order: 1 },
      ]},
      problems: { create: [
        { title: "Number of Connected Components", slug: "connected-components", difficulty: "Medium", description: "You have n nodes labeled from 0 to n - 1 and a list of undirected edges. Write a function to find the number of connected components in the graph.", examples: JSON.stringify([{input:"n = 5, edges = [[0,1],[1,2],[3,4]]",output:"2",explanation:"Components: {0,1,2} and {3,4}"},{input:"n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",output:"1"}]), hints: JSON.stringify(["Start with n separate components.","Each edge merges two components.","Union Find: union the endpoints of each edge, count remaining distinct roots."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n        self.components = n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        self.components -= 1\n\ndef count_components(n, edges):\n    uf = UnionFind(n)\n    for a, b in edges:\n        uf.union(a, b)\n    return uf.components", explanation: "Union Find: Start with n components. For each edge, union the two nodes. If they were in different components, decrement count. Final count = connected components. O(n + E * Î±(n)).", pattern: "Union Find", order: 1 },
        { title: "Redundant Connection", slug: "redundant-connection", difficulty: "Medium", description: "A tree is a connected graph with n nodes and n-1 edges. You are given a graph that started as a tree with one additional edge added. Return the edge that can be removed so the result is a tree.\n\nIf there are multiple answers, return the edge that occurs last in the input.", examples: JSON.stringify([{input:"edges = [[1,2],[1,3],[2,3]]",output:"[2,3]",explanation:"Removing [2,3] makes it a valid tree."},{input:"edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",output:"[1,4]"}]), hints: JSON.stringify(["Process edges one by one. The first edge that creates a cycle is redundant.","How do you check if adding an edge creates a cycle?","Union Find: if both endpoints are already in the same component, this edge creates a cycle."]), solution: "class UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n + 1))\n        self.rank = [0] * (n + 1)\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]: px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]: self.rank[px] += 1\n        return True\n\ndef find_redundant(edges):\n    uf = UnionFind(len(edges))\n    for a, b in edges:\n        if not uf.union(a, b):\n            return [a, b]", explanation: "Union Find: Process each edge. If both endpoints already share the same root, this edge creates a cycle â€” it's the redundant one. O(n * Î±(n)) time.", pattern: "Union Find", order: 2 },
      ]},
    },
  });

  // ===== TOPIC 18: Sorting =====
  console.log("Seeding: Sorting");
  await prisma.topic.create({
    data: {
      name: "Sorting & Searching",
      slug: "sorting-and-searching",
      description: "Sorting algorithms and their applications. Know merge sort, quick sort, counting sort, and when to use each.",
      icon: "ðŸ“‹", order: 18,
      concepts: { create: [
        { title: "Sorting Algorithms", content: "Key algorithms:\n- Merge Sort: O(n log n), stable, divide-and-conquer. Split, sort halves, merge.\n- Quick Sort: O(n log n) avg, in-place. Pick pivot, partition, recurse.\n- Counting/Bucket Sort: O(n + k) for bounded integer ranges.\n\nKnow which to use: stable needed â†’ merge sort, in-place needed â†’ quick sort, bounded range â†’ counting sort.", timeComplexity: "O(n log n) comparison-based", spaceComplexity: "O(n) merge sort, O(log n) quick sort", whenToUse: "When order matters, as a preprocessing step for other algorithms, custom sorting for greedy approaches.", codeExample: "def merge_sort(arr):\n    if len(arr) <= 1: return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)\n\ndef merge(l, r):\n    result = []\n    i = j = 0\n    while i < len(l) and j < len(r):\n        if l[i] <= r[j]:\n            result.append(l[i]); i += 1\n        else:\n            result.append(r[j]); j += 1\n    return result + l[i:] + r[j:]", order: 1 },
      ]},
      problems: { create: [
        { title: "Sort Colors", slug: "sort-colors", difficulty: "Medium", description: "Given an array nums with n objects colored red (0), white (1), or blue (2), sort them in-place so that objects of the same color are adjacent, in the order red, white, and blue.\n\nCan you solve it without using the library's sort function?", examples: JSON.stringify([{input:"nums = [2,0,2,1,1,0]",output:"[0,0,1,1,2,2]"},{input:"nums = [2,0,1]",output:"[0,1,2]"}]), hints: JSON.stringify(["Only 3 distinct values â€” can you do better than O(n log n)?","Dutch National Flag problem: use 3 pointers.","low pointer for 0s, mid for scanning, high for 2s."]), solution: "def sort_colors(nums):\n    low, mid, high = 0, 0, len(nums) - 1\n    while mid <= high:\n        if nums[mid] == 0:\n            nums[low], nums[mid] = nums[mid], nums[low]\n            low += 1\n            mid += 1\n        elif nums[mid] == 1:\n            mid += 1\n        else:\n            nums[mid], nums[high] = nums[high], nums[mid]\n            high -= 1", explanation: "Dutch National Flag (3-way partition): Three pointers â€” low (boundary of 0s), mid (current), high (boundary of 2s). Swap 0s to front, 2s to back. O(n) time, O(1) space, single pass.", pattern: "Sorting", order: 1 },
        { title: "Largest Number", slug: "largest-number", difficulty: "Medium", description: "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it as a string.", examples: JSON.stringify([{input:"nums = [10,2]",output:'"210"'},{input:"nums = [3,30,34,5,9]",output:'"9534330"'}]), hints: JSON.stringify(["This is a custom sorting problem.","Compare two numbers a and b: which order gives a bigger result, ab or ba?","Sort using the comparator: a+b vs b+a (as strings)."]), solution: "from functools import cmp_to_key\ndef largest_number(nums):\n    strs = [str(n) for n in nums]\n    strs.sort(key=cmp_to_key(lambda a, b: -1 if a+b > b+a else 1))\n    result = ''.join(strs)\n    return '0' if result[0] == '0' else result", explanation: "Custom sort: Compare two numbers by which concatenation order produces a larger number. If '9'+'34' > '34'+'9', then 9 should come before 34. O(n log n * k) where k = avg digit length.", pattern: "Sorting", order: 2 },
      ]},
    },
  });

  // ===== TOPIC 19: Prefix Sum =====
  console.log("Seeding: Prefix Sum");
  await prisma.topic.create({
    data: {
      name: "Prefix Sum",
      slug: "prefix-sum",
      description: "Precompute cumulative sums for O(1) range sum queries. Combines with hash maps for subarray sum problems.",
      icon: "âž•", order: 19,
      concepts: { create: [
        { title: "Prefix Sum Array", content: "Build an array where prefix[i] = sum of elements from index 0 to i.\n\nRange sum from i to j = prefix[j] - prefix[i-1].\n\nCombine with hash map: to find subarrays summing to k, check if (current_prefix - k) exists in the map of seen prefix sums.", timeComplexity: "O(n) build, O(1) query", spaceComplexity: "O(n)", whenToUse: "Range sum queries, subarray sum equals k, count subarrays with given sum, running totals.", codeExample: "def subarray_sum(nums, k):\n    count = 0\n    prefix = 0\n    seen = {0: 1}\n    for num in nums:\n        prefix += num\n        if prefix - k in seen:\n            count += seen[prefix - k]\n        seen[prefix] = seen.get(prefix, 0) + 1\n    return count", order: 1 },
      ]},
      problems: { create: [
        { title: "Subarray Sum Equals K", slug: "subarray-sum-equals-k", difficulty: "Medium", description: "Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.", examples: JSON.stringify([{input:"nums = [1,1,1], k = 2",output:"2"},{input:"nums = [1,2,3], k = 3",output:"2"}]), hints: JSON.stringify(["Prefix sum at index i = sum of nums[0..i].","Subarray sum from i to j = prefix[j] - prefix[i-1].","If prefix[j] - k = prefix[i], there's a subarray summing to k. Use a hash map to count prefix sums."]), solution: "def subarray_sum(nums, k):\n    count = 0\n    prefix = 0\n    seen = {0: 1}\n    for num in nums:\n        prefix += num\n        if prefix - k in seen:\n            count += seen[prefix - k]\n        seen[prefix] = seen.get(prefix, 0) + 1\n    return count", explanation: "Prefix Sum + Hash Map: Track prefix sums in a map. For each position, check if (prefix - k) exists in the map â€” that means there's a subarray ending here with sum k. O(n) time, O(n) space.", pattern: "Prefix Sum", order: 1 },
        { title: "Product of Array Except Self", slug: "product-except-self", difficulty: "Medium", description: "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all elements of nums except nums[i].\n\nYou must solve it without division and in O(n) time.", examples: JSON.stringify([{input:"nums = [1,2,3,4]",output:"[24,12,8,6]"},{input:"nums = [-1,1,0,-3,3]",output:"[0,0,9,0,0]"}]), hints: JSON.stringify(["For each position, you need the product of everything to its left AND everything to its right.","Build a prefix product (left to right) and a suffix product (right to left).","answer[i] = left_product[i] * right_product[i]."]), solution: "def product_except_self(nums):\n    n = len(nums)\n    answer = [1] * n\n    # Left products\n    left = 1\n    for i in range(n):\n        answer[i] = left\n        left *= nums[i]\n    # Right products\n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    return answer", explanation: "Prefix/Suffix products: First pass builds left products, second pass multiplies by right products. Each position gets the product of all elements except itself. O(n) time, O(1) extra space.", pattern: "Prefix Sum", order: 2 },
      ]},
    },
  });

  // ===== TOPIC 20: Recursion & Divide and Conquer =====
  console.log("Seeding: Recursion & Divide and Conquer");
  await prisma.topic.create({
    data: {
      name: "Recursion & Divide and Conquer",
      slug: "recursion",
      description: "Break problems into smaller subproblems, solve each recursively, and combine results. Foundation of many algorithms.",
      icon: "ðŸ”„", order: 20,
      concepts: { create: [
        { title: "Divide and Conquer", content: "Split the problem into subproblems, solve each recursively, combine results.\n\nExamples: merge sort (split, sort halves, merge), binary search (split, search one half), quick sort (partition, sort halves).\n\nKey: identify how to split and how to combine.", timeComplexity: "O(n log n) typical", spaceComplexity: "O(log n) to O(n)", whenToUse: "When the problem can be split into independent subproblems of the same type. Merge sort, quick select, closest pair of points.", codeExample: "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    return merge(left, right)", order: 1 },
      ]},
      problems: { create: [
        { title: "Sort an Array (Merge Sort)", slug: "sort-array", difficulty: "Medium", description: "Given an array of integers nums, sort the array in ascending order and return it. You must solve it in O(n log n) time and with the smallest space complexity possible.", examples: JSON.stringify([{input:"nums = [5,2,3,1]",output:"[1,2,3,5]"},{input:"nums = [5,1,1,2,0,0]",output:"[0,0,1,1,2,5]"}]), hints: JSON.stringify(["Merge sort splits the array in half, sorts each, and merges.","Base case: array of size 0 or 1 is already sorted.","The merge step combines two sorted arrays into one."]), solution: "def sort_array(nums):\n    if len(nums) <= 1:\n        return nums\n    mid = len(nums) // 2\n    left = sort_array(nums[:mid])\n    right = sort_array(nums[mid:])\n    return merge(left, right)\n\ndef merge(l, r):\n    result = []\n    i = j = 0\n    while i < len(l) and j < len(r):\n        if l[i] <= r[j]:\n            result.append(l[i]); i += 1\n        else:\n            result.append(r[j]); j += 1\n    result.extend(l[i:])\n    result.extend(r[j:])\n    return result", explanation: "Divide and Conquer (Merge Sort): Split array in half, recursively sort each half, merge the sorted halves. O(n log n) time, O(n) space for merge step.", pattern: "Divide and Conquer", order: 1 },
        { title: "Maximum Subarray", slug: "maximum-subarray", difficulty: "Medium", description: "Given an integer array nums, find the subarray with the largest sum, and return its sum.", examples: JSON.stringify([{input:"nums = [-2,1,-3,4,-1,2,1,-5,4]",output:"6",explanation:"The subarray [4,-1,2,1] has the largest sum 6."},{input:"nums = [1]",output:"1"}]), hints: JSON.stringify(["At each position, decide: start a new subarray or extend the previous one?","If the previous subarray sum is negative, starting fresh is better.","Kadane's algorithm: curr_max = max(num, curr_max + num)."]), solution: "def max_subarray(nums):\n    curr_max = global_max = nums[0]\n    for num in nums[1:]:\n        curr_max = max(num, curr_max + num)\n        global_max = max(global_max, curr_max)\n    return global_max", explanation: "Kadane's Algorithm: At each element, either extend the current subarray or start a new one. Track the global maximum. O(n) time, O(1) space.", pattern: "Kadane's Algorithm", order: 2 },
      ]},
    },
  });

  console.log("Seeding complete! 20 topics with 55+ problems.");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
